{
  "id": "4890657c-0104-4aa7-b941-a8053d30da37",
  "title": "Business Analytics Journeys",
  "tasks": {
    "property_sales": {
      "name": "property_sales",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Property Sales\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Property Listing\",\n      kpi: \"Listing Success Rate\",\n      details: \"Property is listed for sale\",\n      subSteps: [\"Listing Created\", \"Listing Published\"],\n      errorSteps: [\"Listing Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PropertyType: [\"Residential\", \"Commercial\", \"Industrial\", \"Land\"],\n        ListingChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Buyer Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Buyer searches for properties\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        BuyerType: [\"Individual\", \"Corporate\"]\n      }\n    },\n    {\n      stepName: \"Property Viewing\",\n      kpi: \"Viewing Success Rate\",\n      details: \"Buyer views the property\",\n      subSteps: [\"Viewing Scheduled\", \"Viewing Completed\"],\n      errorSteps: [\"Viewing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ViewingType: [\"Virtual Tour\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Offer Submission\",\n      kpi: \"Offer Submission Success Rate\",\n      details: \"Buyer submits an offer\",\n      subSteps: [\"Offer Made\", \"Offer Submitted\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        OfferType: [\"Cash\", \"Financed\"]\n      }\n    },\n    {\n      stepName: \"Negotiation\",\n      kpi: \"Negotiation Success Rate\",\n      details: \"Buyer and seller negotiate the deal\",\n      subSteps: [\"Negotiation Started\", \"Deal Agreed\"],\n      errorSteps: [\"Negotiation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        NegotiationOutcome: [\"Accepted\", \"Rejected\", \"Counter Offer\"]\n      }\n    },\n    {\n      stepName: \"Contract Signing\",\n      kpi: \"Signing Success Rate\",\n      details: \"Buyer signs the property contract\",\n      subSteps: [\"Contract Prepared\", \"Contract Signed\"],\n      errorSteps: [\"Signing Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SigningMethod: [\"Electronic\", \"In-Person\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 3
      },
      "conditions": {
        "states": {
          "real_estate_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "real_estate_management"
      ]
    },
    "event_ticketing": {
      "name": "event_ticketing",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Event Ticketing\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Ticket Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for an event ticket\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        EventType: [\"Concert\", \"Sports\", \"Theatre\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Ticket Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects an event ticket\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TicketCategory: [\"VIP\", \"Standard\", \"Economy\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Ticket Delivery\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Customer receives their event ticket\",\n      subSteps: [\"Delivery Initiated\", \"Delivery Completed\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryMethod: [\"Email\", \"Mobile App\", \"Postal Mail\"]\n      }\n    },\n    {\n      stepName: \"Event Attendance\",\n      kpi: \"Attendance Success Rate\",\n      details: \"Customer attends the event\",\n      subSteps: [\"Arrival\", \"Event Enjoyed\"],\n      errorSteps: [\"Unable to Attend\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AttendanceType: [\"In-Person\", \"Virtual\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 6
      },
      "conditions": {
        "states": {
          "public_sector_operational_readiness": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "public_sector_operational_readiness"
      ]
    },
    "farm_management": {
      "name": "farm_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Farm Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Soil Preparation\",\n      kpi: \"Preparation Success Rate\",\n      details: \"Preparing the soil for planting\",\n      subSteps: [\"Soil Testing\", \"Tilling\", \"Fertilization\"],\n      errorSteps: [\"Preparation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SoilType: [\"Sandy\", \"Clay\", \"Loamy\"],\n        FertilizerType: [\"Organic\", \"Inorganic\"]\n      }\n    },\n    {\n      stepName: \"Planting\",\n      kpi: \"Planting Success Rate\",\n      details: \"Planting seeds or seedlings\",\n      subSteps: [\"Seed Selection\", \"Planting\", \"Initial Watering\"],\n      errorSteps: [\"Planting Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CropType: [\"Wheat\", \"Corn\", \"Soybeans\", \"Vegetables\"]\n      }\n    },\n    {\n      stepName: \"Irrigation\",\n      kpi: \"Irrigation Success Rate\",\n      details: \"Watering crops to promote growth\",\n      subSteps: [\"Irrigation Scheduling\", \"Water Distribution\"],\n      errorSteps: [\"Irrigation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        IrrigationMethod: [\"Drip\", \"Sprinkler\", \"Flood\"]\n      }\n    },\n    {\n      stepName: \"Pest Control\",\n      kpi: \"Control Success Rate\",\n      details: \"Protecting crops from pests\",\n      subSteps: [\"Pest Identification\", \"Application of Pesticides\"],\n      errorSteps: [\"Control Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PesticideType: [\"Chemical\", \"Biological\"]\n      }\n    },\n    {\n      stepName: \"Harvesting\",\n      kpi: \"Harvest Success Rate\",\n      details: \"Gathering mature crops from the fields\",\n      subSteps: [\"Harvest Scheduling\", \"Crop Collection\"],\n      errorSteps: [\"Harvest Failed\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        HarvestMethod: [\"Manual\", \"Mechanical\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on farm management services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 10
      },
      "conditions": {
        "states": {
          "agriculture_supply_chain": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "agriculture_supply_chain"
      ]
    },
    "online_tutoring": {
      "name": "online_tutoring",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Tutoring\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Tutor Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Student searches for a tutor\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Subject: [\"Math\", \"Science\", \"English\", \"History\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Tutor Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Student selects a tutor\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TutorExperience: [\"Beginner\", \"Intermediate\", \"Expert\"]\n      }\n    },\n    {\n      stepName: \"Session Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Student schedules a tutoring session\",\n      subSteps: [\"Scheduling Initiated\", \"Scheduling Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SessionType: [\"One-on-One\", \"Group\"],\n        Availability: [\"Weekdays\", \"Weekends\", \"Evenings\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Student submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Student completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Tutoring Session\",\n      kpi: \"Session Success Rate\",\n      details: \"Student attends the tutoring session\",\n      subSteps: [\"Session Started\", \"Session Completed\"],\n      errorSteps: [\"Session Not Attended\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SessionMode: [\"Video\", \"Audio\", \"Chat\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 1
      },
      "description": "Run custom JavaScript code.",
      "predecessors": []
    },
    "fintech_services": {
      "name": "fintech_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Fintech Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about fintech services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Digital Banking\", \"Payment Solutions\", \"Investment Platforms\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects fintech services\",\n      subSteps: [\"Selection Initiated\", \"Selection Completed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServicePackage: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Fintech service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"App\", \"Customer Support\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the fintech service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Transactions\", \"Account Management\", \"Investment Tracking\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the fintech service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 8
      },
      "conditions": {
        "states": {
          "grocery_shopping": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "grocery_shopping"
      ]
    },
    "game_development": {
      "name": "game_development",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Game Development\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Concept Development\",\n      kpi: \"Concept Approval Rate\",\n      details: \"Developing and approving the game concept\",\n      subSteps: [\"Concept Creation\", \"Concept Approval\"],\n      errorSteps: [\"Concept Rejection\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        GameGenre: [\"Action\", \"Adventure\", \"Puzzle\", \"RPG\"],\n        ConceptSource: [\"Internal Team\", \"External Proposal\"]\n      }\n    },\n    {\n      stepName: \"Pre-Production\",\n      kpi: \"Pre-Production Success Rate\",\n      details: \"Planning and organizing game development\",\n      subSteps: [\"Project Planning\", \"Resource Allocation\"],\n      errorSteps: [\"Pre-Production Failure\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PlanningTool: [\"Gantt Chart\", \"Scrum Board\"]\n      }\n    },\n    {\n      stepName: \"Production\",\n      kpi: \"Development Success Rate\",\n      details: \"Creating and coding the game\",\n      subSteps: [\"Development Started\", \"Development Completed\"],\n      errorSteps: [\"Development Failure\"],\n      errorProbability: 0.08,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DevelopmentPlatform: [\"Unity\", \"Unreal Engine\", \"Custom Engine\"]\n      }\n    },\n    {\n      stepName: \"Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the game for bugs and issues\",\n      subSteps: [\"Alpha Testing\", \"Beta Testing\", \"Final Testing\"],\n      errorSteps: [\"Testing Failure\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestType: [\"Automated\", \"Manual\"],\n        TestCoverage: [\"Functional\", \"Performance\", \"Usability\"]\n      }\n    },\n    {\n      stepName: \"Launch\",\n      kpi: \"Launch Success Rate\",\n      details: \"Releasing the game to the market\",\n      subSteps: [\"Launch Planning\", \"Launch Execution\"],\n      errorSteps: [\"Launch Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        LaunchPlatform: [\"Steam\", \"App Store\", \"Google Play\"]\n      }\n    },\n    {\n      stepName: \"Post-Launch Support\",\n      kpi: \"Support Success Rate\",\n      details: \"Providing support and updates after launch\",\n      subSteps: [\"Support Initiated\", \"Support Completed\"],\n      errorSteps: [\"Support Failure\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SupportType: [\"Patches\", \"DLC\", \"Community Management\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 6
      },
      "conditions": {
        "states": {
          "software_development_lifecycle": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "software_development_lifecycle"
      ]
    },
    "grocery_shopping": {
      "name": "grocery_shopping",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Grocery Shopping\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Product Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for grocery items\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProductCategory: [\"Fruits\", \"Vegetables\", \"Dairy\", \"Snacks\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Item Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects grocery items\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ItemType: [\"Organic\", \"Non-Organic\"]\n      }\n    },\n    {\n      stepName: \"Add to Cart\",\n      kpi: \"Add to Cart Success Rate\",\n      details: \"Customer adds items to cart\",\n      subSteps: [\"Cart Updated\"],\n      errorSteps: [\"Add to Cart Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CartType: [\"Regular\", \"Express\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Delivery Address\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Delivery\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Groceries are delivered to the customer\",\n      subSteps: [\"Delivery Initiated\", \"Delivery Completed\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryMode: [\"Bike\", \"Van\", \"Drone\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 7
      },
      "conditions": {
        "states": {
          "met_police_incident_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "met_police_incident_management"
      ]
    },
    "loan_application": {
      "name": "loan_application",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Loan Application\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits a loan application\", \n      subSteps: [\"Form Completion\", \"Submitted\"], \n      errorSteps: [\"Application Incomplete\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        LoanType: [\"Personal\", \"Home\", \"Car\"],\n        ApplicationChannel: [\"Online\", \"In-Person\", \"Mobile\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Identity Verification Success Rate\", \n      details: \"Customer's identity is verified\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.07,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        VerificationMethod: [\"Online\", \"In-Person\"],\n        IDType: [\"Passport\", \"Drivers License\", \"Utility Bill\"]\n      },\n    },\n    { \n      stepName: \"Credit Check\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Customer's credit history is verified\", \n      subSteps: [\"Credit Check Initiated\", \"Credit Score Verified\"],\n      errorSteps: [\"Credit Check Failed\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CreditAgency: [\"Experian\", \"Equifax\", \"TransUnion\"],\n        CreditScoreRange: [\"300-500\", \"500-700\", \"700-850\"]\n      },\n    },\n    { \n      stepName: \"Document Submission\", \n      kpi: \"Document Submission Success Rate\", \n      details: \"Customer submits required documents\", \n      subSteps: [\"Documents Uploaded\", \"Verification Underway\"], \n      errorSteps: [\"Document Rejected\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DocumentType: [\"Income Proof\", \"Address Proof\", \"Bank Statements\"],\n        SubmissionChannel: [\"Mobile Upload\", \"Online Portal\"]\n      },\n    },\n    { \n      stepName: \"Loan Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Loan is approved or rejected\", \n      subSteps: [\"Approval Under Review\", \"Decision Made\"],  \n      errorSteps: [\"Approval Denied\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApprovalDecision: [\"Approved\", \"Rejected\", \"Conditionally Approved\"],\n        LoanAmount: [\"<10,000\", \"10,000-50,000\", \">50,000\"]\n      },\n    },\n    { \n      stepName: \"Loan Disbursement\", \n      kpi: \"Disbursement Success Rate\", \n      details: \"Loan amount is disbursed to customer\", \n      subSteps: [\"Funds Transferred\", \"Confirmation Sent\"],  \n      errorSteps: [\"Transfer Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DisbursementMethod: [\"Bank Transfer\", \"Cheque\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "personal_banking": {
      "name": "personal_banking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Personal Banking\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Account Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about personal banking services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Checking Account\", \"Savings Account\", \"Loans\"]\n      }\n    },\n    {\n      stepName: \"Account Opening\",\n      kpi: \"Opening Success Rate\",\n      details: \"Customer opens a personal banking account\",\n      subSteps: [\"Account Application Submitted\", \"Account Opened\"],\n      errorSteps: [\"Opening Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AccountType: [\"Checking\", \"Savings\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the personal banking service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Online Banking\", \"Mobile Banking\", \"Branch Visits\"]\n      }\n    },\n    {\n      stepName: \"Account Maintenance\",\n      kpi: \"Maintenance Success Rate\",\n      details: \"Routine maintenance of personal banking accounts\",\n      subSteps: [\"Maintenance Initiated\", \"Maintenance Completed\"],\n      errorSteps: [\"Maintenance Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaintenanceType: [\"Account Updates\", \"Fee Management\", \"Service Upgrades\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on personal banking services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 9
      },
      "conditions": {
        "states": {
          "banking_-_wealth_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "banking_-_wealth_management"
      ]
    },
    "smart_home_setup": {
      "name": "smart_home_setup",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Smart Home Setup\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about smart home setup services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Home Security\", \"Energy Management\", \"Home Automation\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects smart home setup services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServicePackage: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Installation\",\n      kpi: \"Installation Success Rate\",\n      details: \"Smart home devices are installed\",\n      subSteps: [\"Installation Scheduled\", \"Installation Completed\"],\n      errorSteps: [\"Installation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InstallationMethod: [\"Professional\", \"Self-Install\"]\n      }\n    },\n    {\n      stepName: \"Service Configuration\",\n      kpi: \"Configuration Success Rate\",\n      details: \"Smart home devices are configured and tested\",\n      subSteps: [\"Configuration Initiated\", \"Configuration Completed\"],\n      errorSteps: [\"Configuration Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeviceType: [\"Smart Lights\", \"Thermostats\", \"Security Cameras\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the smart home setup service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 9
      },
      "conditions": {
        "states": {
          "satellite_tv_installation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "satellite_tv_installation"
      ]
    },
    "waste_management": {
      "name": "waste_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Waste Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about waste management services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a waste management service package\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackageType: [\"Standard\", \"Premium\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Waste management service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Person\", \"Customer Support\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the waste management service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Residential Pickup\", \"Commercial Pickup\", \"Industrial Pickup\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the waste management service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 9
      },
      "conditions": {
        "states": {
          "smart_grid_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "smart_grid_management"
      ]
    },
    "corporate_banking": {
      "name": "corporate_banking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Corporate Banking\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Client Onboarding\",\n      kpi: \"Onboarding Success Rate\",\n      details: \"Corporate client onboarding and profile creation\",\n      subSteps: [\"Onboarding Initiated\", \"Profile Created\"],\n      errorSteps: [\"Onboarding Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        OnboardingChannel: [\"In-Person\", \"Online\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Credit Assessment\",\n      kpi: \"Assessment Success Rate\",\n      details: \"Assessing the creditworthiness of the corporate client\",\n      subSteps: [\"Credit Assessment Initiated\", \"Credit Assessment Completed\"],\n      errorSteps: [\"Assessment Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssessmentType: [\"Financial Analysis\", \"Credit Score Review\"]\n      }\n    },\n    {\n      stepName: \"Loan Origination\",\n      kpi: \"Origination Success Rate\",\n      details: \"Origination of corporate loans\",\n      subSteps: [\"Loan Application Submitted\", \"Loan Approved\"],\n      errorSteps: [\"Origination Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        LoanType: [\"Working Capital\", \"Term Loan\", \"Trade Finance\"]\n      }\n    },\n    {\n      stepName: \"Transaction Management\",\n      kpi: \"Transaction Success Rate\",\n      details: \"Managing corporate transactions\",\n      subSteps: [\"Transaction Initiated\", \"Transaction Completed\"],\n      errorSteps: [\"Transaction Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TransactionType: [\"Fund Transfer\", \"Payment Processing\", \"Foreign Exchange\"]\n      }\n    },\n    {\n      stepName: \"Client Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Providing clients with regular reports on their accounts\",\n      subSteps: [\"Report Generated\", \"Report Delivered\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Transaction Report\", \"Financial Statement\", \"Loan Statement\"]\n      }\n    },\n    {\n      stepName: \"Client Feedback\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from corporate clients\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"Phone\", \"In-Person\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 10
      },
      "conditions": {
        "states": {
          "personal_banking": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "personal_banking"
      ]
    },
    "mining_operations": {
      "name": "mining_operations",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mining Operations\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Site Exploration\",\n      kpi: \"Exploration Success Rate\",\n      details: \"Exploring potential mining sites\",\n      subSteps: [\"Exploration Initiated\", \"Exploration Completed\"],\n      errorSteps: [\"Exploration Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExplorationMethod: [\"Geological Survey\", \"Drilling\"]\n      }\n    },\n    {\n      stepName: \"Resource Extraction\",\n      kpi: \"Extraction Success Rate\",\n      details: \"Extracting mineral resources from the site\",\n      subSteps: [\"Extraction Initiated\", \"Extraction Completed\"],\n      errorSteps: [\"Extraction Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExtractionMethod: [\"Open-Pit\", \"Underground\", \"Placer\"]\n      }\n    },\n    {\n      stepName: \"Processing & Refinement\",\n      kpi: \"Processing Success Rate\",\n      details: \"Processing and refining extracted resources\",\n      subSteps: [\"Processing Started\", \"Refinement Completed\"],\n      errorSteps: [\"Processing Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProcessingType: [\"Crushing\", \"Milling\", \"Smelting\"]\n      }\n    },\n    {\n      stepName: \"Quality Control\",\n      kpi: \"Control Success Rate\",\n      details: \"Ensuring quality of processed resources\",\n      subSteps: [\"Quality Inspection\", \"Approval\"],\n      errorSteps: [\"Control Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InspectionMethod: [\"Visual\", \"Mechanical\"]\n      }\n    },\n    {\n      stepName: \"Distribution\",\n      kpi: \"Distribution Success Rate\",\n      details: \"Distributing refined resources to markets\",\n      subSteps: [\"Distribution Planning\", \"Distribution Executed\"],\n      errorSteps: [\"Distribution Failed\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DistributionMode: [\"Truck\", \"Ship\", \"Rail\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from clients on mining operations\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 10
      },
      "conditions": {
        "states": {
          "forestry_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "forestry_management"
      ]
    },
    "car_rental_booking": {
      "name": "car_rental_booking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Car Rental Booking\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Reservation Made\",\n      kpi: \"Reservation Success Rate\",\n      details: \"Customer makes a car rental reservation\",\n      subSteps: [\"Reservation Initiated\", \"Reservation Confirmed\"],\n      errorSteps: [\"Reservation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CarType: [\"Economy\", \"SUV\", \"Luxury\"],\n        ReservationChannel: [\"Online\", \"In-Person\", \"Mobile\"]\n      }\n    },\n    {\n      stepName: \"Pickup\",\n      kpi: \"Pickup Success Rate\",\n      details: \"Customer picks up the rental car\",\n      subSteps: [\"Pickup Scheduled\", \"Pickup Completed\"],\n      errorSteps: [\"Pickup Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PickupLocation: [\"Airport\", \"City Center\", \"Hotel\"]\n      }\n    },\n    {\n      stepName: \"Usage Period\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the rental car\",\n      subSteps: [\"Car in Use\"],\n      errorSteps: [\"Breakdown\", \"Accident\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RentalDuration: [\"<1 Day\", \"1-3 Days\", \">3 Days\"]\n      }\n    },\n    {\n      stepName: \"Return\",\n      kpi: \"Return Success Rate\",\n      details: \"Customer returns the rental car\",\n      subSteps: [\"Return Scheduled\", \"Return Completed\"],\n      errorSteps: [\"Return Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReturnLocation: [\"Airport\", \"City Center\", \"Hotel\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on their rental experience\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.02,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App\"]\n      }\n    },\n    {\n      stepName: \"Payment Processing\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer payment for rental is processed\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    }\n  ]\n};\n\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 6
      },
      "conditions": {
        "states": {
          "mobile_phone_contract": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "mobile_phone_contract"
      ]
    },
    "recycling_services": {
      "name": "recycling_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Recycling Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about recycling services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a recycling service package\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackageType: [\"Standard\", \"Premium\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Recycling service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Person\", \"Customer Support\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the recycling service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Residential Pickup\", \"Commercial Pickup\", \"Industrial Pickup\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the recycling service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 10
      },
      "conditions": {
        "states": {
          "waste_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "waste_management"
      ]
    },
    "forestry_management": {
      "name": "forestry_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Forestry Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Forest Assessment\",\n      kpi: \"Assessment Success Rate\",\n      details: \"Assessing forest conditions\",\n      subSteps: [\"Data Collection\", \"Analysis\"],\n      errorSteps: [\"Assessment Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssessmentMethod: [\"Survey\", \"Remote Sensing\"]\n      }\n    },\n    {\n      stepName: \"Tree Planting\",\n      kpi: \"Planting Success Rate\",\n      details: \"Planting trees in the forest\",\n      subSteps: [\"Planning\", \"Execution\"],\n      errorSteps: [\"Planting Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TreeSpecies: [\"Pine\", \"Oak\", \"Maple\"]\n      }\n    },\n    {\n      stepName: \"Forest Maintenance\",\n      kpi: \"Maintenance Success Rate\",\n      details: \"Maintaining forest health\",\n      subSteps: [\"Thinning\", \"Pruning\"],\n      errorSteps: [\"Maintenance Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaintenanceMethod: [\"Manual\", \"Mechanical\"]\n      }\n    },\n    {\n      stepName: \"Pest Control\",\n      kpi: \"Control Success Rate\",\n      details: \"Controlling pests in the forest\",\n      subSteps: [\"Identification\", \"Treatment\"],\n      errorSteps: [\"Control Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TreatmentType: [\"Chemical\", \"Biological\"]\n      }\n    },\n    {\n      stepName: \"Fire Management\",\n      kpi: \"Management Success Rate\",\n      details: \"Managing forest fires\",\n      subSteps: [\"Fire Risk Assessment\", \"Firefighting\"],\n      errorSteps: [\"Fire Management Failed\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FirefightingMethod: [\"Manual\", \"Aerial\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from stakeholders on forestry management\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 9
      },
      "conditions": {
        "states": {
          "fisheries_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "fisheries_management"
      ]
    },
    "it_helpdesk_support": {
      "name": "it_helpdesk_support",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - IT Helpdesk Support\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Issue Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Customer reports an IT issue\",\n      subSteps: [\"Issue Initiated\", \"Issue Logged\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportingMethod: [\"Phone\", \"Email\", \"Portal\"]\n      }\n    },\n    {\n      stepName: \"Issue Classification\",\n      kpi: \"Classification Success Rate\",\n      details: \"Helpdesk classifies the issue\",\n      subSteps: [\"Classification Initiated\", \"Classification Completed\"],\n      errorSteps: [\"Classification Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        IssueType: [\"Software\", \"Hardware\", \"Network\"]\n      }\n    },\n    {\n      stepName: \"Issue Assignment\",\n      kpi: \"Assignment Success Rate\",\n      details: \"Helpdesk assigns the issue to the appropriate team\",\n      subSteps: [\"Assignment Initiated\", \"Assignment Completed\"],\n      errorSteps: [\"Assignment Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssignmentMethod: [\"Manual\", \"Automated\"]\n      }\n    },\n    {\n      stepName: \"Issue Resolution\",\n      kpi: \"Resolution Success Rate\",\n      details: \"Assigned team resolves the issue\",\n      subSteps: [\"Resolution Initiated\", \"Resolution Completed\"],\n      errorSteps: [\"Resolution Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ResolutionType: [\"Remote\", \"On-Site\"]\n      }\n    },\n    {\n      stepName: \"Issue Verification\",\n      kpi: \"Verification Success Rate\",\n      details: \"Resolved issue is verified\",\n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],\n      errorSteps: [\"Verification Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        VerificationMethod: [\"Automated\", \"Manual\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the support experience\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"Portal\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 4
      },
      "conditions": {
        "states": {
          "landscaping_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "landscaping_services"
      ]
    },
    "real_estate_journey": {
      "name": "real_estate_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Real Estate Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Property Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for properties\", \n      subSteps: [\"Search Initiated\", \"Property Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SearchChannel: [\"Website\", \"Mobile App\", \"Agent\"],\n        PropertyType: [\"Apartment\", \"House\", \"Commercial\"]\n      },\n    },\n    { \n      stepName: \"Property Viewing\", \n      kpi: \"Viewing Success Rate\", \n      details: \"Customer schedules and attends property viewings\", \n      subSteps: [\"Viewing Scheduled\", \"Viewing Completed\"], \n      errorSteps: [\"Viewing No-Show\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ViewingMethod: [\"In-Person\", \"Virtual Tour\"],\n        ViewingDay: [\"Weekday\", \"Weekend\"]\n      },\n    },\n    { \n      stepName: \"Offer Submission\", \n      kpi: \"Offer Submission Success Rate\", \n      details: \"Customer submits an offer on a property\", \n      subSteps: [\"Offer Submitted\", \"Offer Accepted\"],\n      errorSteps: [\"Offer Rejected\"], \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OfferMethod: [\"Agent\", \"Online Portal\"],\n        OfferType: [\"Cash\", \"Mortgage\"]\n      },\n    },\n    { \n      stepName: \"Mortgage Application\", \n      kpi: \"Mortgage Application Success Rate\", \n      details: \"Customer applies for a mortgage\", \n      subSteps: [\"Application Submitted\", \"Application Approved\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.12,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApplicationChannel: [\"Bank\", \"Online\", \"Broker\"],\n        MortgageType: [\"Fixed\", \"Variable\"]\n      },\n    },\n    { \n      stepName: \"Contract Exchange\", \n      kpi: \"Contract Exchange Success Rate\", \n      details: \"Contracts are exchanged between buyer and seller\", \n      subSteps: [\"Contracts Sent\", \"Contracts Exchanged\"],  \n      errorSteps: [\"Exchange Delayed\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ContractType: [\"Sale\", \"Lease\"],\n        LegalEntity: [\"Solicitor\", \"Conveyancer\"]\n      },\n    },\n    { \n      stepName: \"Completion & Handover\", \n      kpi: \"Completion Success Rate\", \n      details: \"Property sale is completed and keys are handed over\", \n      subSteps: [\"Completion Scheduled\", \"Keys Handover\"],  \n      errorSteps: [\"Handover Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        HandoverMethod: [\"In-Person\", \"Agent\"],\n        PropertyCondition: [\"As-Is\", \"Renovated\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 2
      },
      "conditions": {
        "states": {
          "loan_application": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "loan_application"
      ]
    },
    "veterinary_services": {
      "name": "veterinary_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Veterinary Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for veterinary services\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceType: [\"General Checkup\", \"Vaccination\", \"Surgery\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects veterinary services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PetType: [\"Dog\", \"Cat\", \"Bird\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Pet Details\"]\n      }\n    },\n    {\n      stepName: \"Service Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Customer schedules the veterinary service appointment\",\n      subSteps: [\"Schedule Initiated\", \"Schedule Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Availability: [\"Weekdays\", \"Weekends\", \"Evenings\"]\n      }\n    },\n    {\n      stepName: \"Service Delivery\",\n      kpi: \"Service Completion Rate\",\n      details: \"Veterinary professional completes the service\",\n      subSteps: [\"Service Started\", \"Service Completed\"],\n      errorSteps: [\"Service Not Completed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceOutcome: [\"Successful\", \"Follow-Up Required\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the veterinary service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 7
      },
      "conditions": {
        "states": {
          "restaurant_reservation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "restaurant_reservation"
      ]
    },
    "digital_art_creation": {
      "name": "digital_art_creation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Digital Art Creation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about digital art creation services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Commission\", \"Print\", \"Digital Media\"]\n      }\n    },\n    {\n      stepName: \"Concept Design\",\n      kpi: \"Design Success Rate\",\n      details: \"Designing the concept for the digital art\",\n      subSteps: [\"Concept Sketch\", \"Client Approval\"],\n      errorSteps: [\"Design Rejected\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DesignType: [\"Character Design\", \"Landscape\", \"Abstract\"]\n      }\n    },\n    {\n      stepName: \"Digital Creation\",\n      kpi: \"Creation Success Rate\",\n      details: \"Creating the digital art piece\",\n      subSteps: [\"Base Layers\", \"Detailing\", \"Final Touches\"],\n      errorSteps: [\"Creation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ToolType: [\"Photoshop\", \"Illustrator\", \"Procreate\"]\n      }\n    },\n    {\n      stepName: \"Client Review\",\n      kpi: \"Review Success Rate\",\n      details: \"Client reviews the digital art\",\n      subSteps: [\"Review Initiated\", \"Feedback Received\"],\n      errorSteps: [\"Review Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackType: [\"Minor Edits\", \"Major Revisions\", \"Approval\"]\n      }\n    },\n    {\n      stepName: \"Final Delivery\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Delivering the final digital art to the client\",\n      subSteps: [\"Final Adjustments\", \"Delivery Completed\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryMethod: [\"Email\", \"Cloud Storage\", \"Physical Print\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on digital art creation services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 10
      },
      "conditions": {
        "states": {
          "e-sports_tournament_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "e-sports_tournament_management"
      ]
    },
    "education_enrollment": {
      "name": "education_enrollment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Education Enrollment\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Prospect Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Prospective student searches for educational programs\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProgramType: [\"Undergraduate\", \"Graduate\", \"Diploma\", \"Certificate\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Program Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Prospective student selects an educational program\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProgramField: [\"Science\", \"Arts\", \"Commerce\", \"Engineering\"]\n      }\n    },\n    {\n      stepName: \"Application Submission\",\n      kpi: \"Submission Success Rate\",\n      details: \"Prospective student submits an application\",\n      subSteps: [\"Application Completed\", \"Application Submitted\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ApplicationType: [\"Online\", \"Offline\"],\n        ApplicationChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Document Verification\",\n      kpi: \"Verification Success Rate\",\n      details: \"Submitted documents are verified\",\n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],\n      errorSteps: [\"Verification Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DocumentType: [\"Transcripts\", \"Recommendation Letters\", \"ID Proof\"]\n      }\n    },\n    {\n      stepName: \"Admission Decision\",\n      kpi: \"Decision Success Rate\",\n      details: \"Admission committee reviews the application\",\n      subSteps: [\"Decision Under Review\", \"Decision Made\"],\n      errorSteps: [\"Decision Rejected\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DecisionOutcome: [\"Accepted\", \"Rejected\", \"Waitlisted\"]\n      }\n    },\n    {\n      stepName: \"Enrollment Confirmation\",\n      kpi: \"Confirmation Success Rate\",\n      details: \"Accepted student confirms enrollment\",\n      subSteps: [\"Confirmation Sent\", \"Confirmation Received\"],\n      errorSteps: [\"Confirmation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfirmationMethod: [\"Online\", \"Mail\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 1
      },
      "description": "Run custom JavaScript code.",
      "predecessors": []
    },
    "fisheries_management": {
      "name": "fisheries_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Water Treatment Solutions\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about water treatment solutions\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Site Assessment\",\n      kpi: \"Assessment Success Rate\",\n      details: \"Conducting a site assessment for water treatment solutions\",\n      subSteps: [\"Assessment Scheduled\", \"Assessment Completed\"],\n      errorSteps: [\"Assessment Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssessmentType: [\"On-Site\", \"Remote\"]\n      }\n    },\n    {\n      stepName: \"Proposal Submission\",\n      kpi: \"Proposal Success Rate\",\n      details: \"Submitting a proposal for water treatment solutions\",\n      subSteps: [\"Proposal Created\", \"Proposal Submitted\"],\n      errorSteps: [\"Proposal Rejected\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProposalType: [\"Standard\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Implementation\",\n      kpi: \"Implementation Success Rate\",\n      details: \"Implementing the water treatment solution\",\n      subSteps: [\"Implementation Scheduled\", \"Implementation Completed\"],\n      errorSteps: [\"Implementation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ImplementationMethod: [\"In-House\", \"Contracted\"]\n      }\n    },\n    {\n      stepName: \"System Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the implemented water treatment system\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestingType: [\"Performance\", \"Safety\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on the water treatment solution\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 8
      },
      "conditions": {
        "states": {
          "home_maintenance_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "home_maintenance_services"
      ]
    },
    "landscaping_services": {
      "name": "landscaping_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Landscaping Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for landscaping services\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceType: [\"Garden Design\", \"Lawn Care\", \"Tree Planting\", \"Patio Installation\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects landscaping services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServicePackage: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Customer schedules the landscaping service\",\n      subSteps: [\"Schedule Initiated\", \"Schedule Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Availability: [\"Weekdays\", \"Weekends\"]\n      }\n    },\n    {\n      stepName: \"Service Delivery\",\n      kpi: \"Service Completion Rate\",\n      details: \"Service professional completes the landscaping service\",\n      subSteps: [\"Service Started\", \"Service Completed\"],\n      errorSteps: [\"Service Not Completed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceOutcome: [\"Successful\", \"Revisit Required\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the landscaping service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 3
      },
      "conditions": {
        "states": {
          "interior_design_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "interior_design_services"
      ]
    },
    "online_food_delivery": {
      "name": "online_food_delivery",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Food Delivery\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Food Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for food items\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CuisineType: [\"Italian\", \"Chinese\", \"Indian\", \"Fast Food\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Food Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects food items\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ItemCategory: [\"Main Course\", \"Sides\", \"Drinks\", \"Desserts\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Delivery Address\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Order Confirmation\",\n      kpi: \"Order Confirmation Success Rate\",\n      details: \"Customer receives order confirmation\",\n      subSteps: [\"Confirmation Sent\", \"Confirmation Received\"],\n      errorSteps: [\"Confirmation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfirmationChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    },\n    {\n      stepName: \"Food Delivery\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Food is delivered to the customer\",\n      subSteps: [\"Delivery Initiated\", \"Delivery Completed\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryMode: [\"Bike\", \"Car\", \"Drone\"]\n      }\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 6
      },
      "conditions": {
        "states": {
          "passenger_journey_and_flight_operations": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "passenger_journey_and_flight_operations"
      ]
    },
    "utilities_and_energy": {
      "name": "utilities_and_energy",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Utilities & Energy\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Meter Reading\", \n      kpi: \"Meter Reading Success Rate\", \n      details: \"Meter is read for usage calculation\", \n      subSteps: [\"Meter Accessed\", \"Reading Recorded\"], \n      errorSteps: [\"Reading Failed\"], \n      errorProbability: 0.02,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        MeterType: [\"Electricity\", \"Gas\", \"Water\"],\n        ReadingMethod: [\"Manual\", \"Smart Meter\"]\n      },\n    },\n    { \n      stepName: \"Usage Calculation\", \n      kpi: \"Calculation Success Rate\", \n      details: \"Customer's utility usage is calculated\", \n      subSteps: [\"Usage Data Processed\", \"Calculation Completed\"], \n      errorSteps: [\"Calculation Error\"], \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EnergySource: [\"Renewable\", \"Non-Renewable\"],\n        Region: [\"North\", \"South\"]\n      },\n    },\n    { \n      stepName: \"Bill Generation\", \n      kpi: \"Bill Generation Success\", \n      details: \"Bill is generated based on usage\", \n      subSteps: [\"Bill Created\", \"Bill Sent\"],\n      errorSteps: [\"Bill Generation Error\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\", \"PayPal\"],\n        BillingFrequency: [\"Monthly\", \"Quarterly\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Customer pays for their utility usage\", \n      subSteps: [\"Payment Received\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentChannel: [\"Mobile\", \"Online\", \"Phone\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Account Management\", \n      kpi: \"Account Update Success Rate\", \n      details: \"Customer updates account details or preferences\", \n      subSteps: [\"Preferences Updated\", \"Account Details Saved\"],  \n      errorSteps: [\"Update Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        UpdateMethod: [\"Self-Service\", \"Customer Service\"],\n        AccountType: [\"Residential\", \"Business\"]\n      },\n    },\n    { \n      stepName: \"Service Continuation\", \n      kpi: \"Service Continuation Success Rate\", \n      details: \"Service is either continued or disconnected\", \n      subSteps: [\"Service Active\", \"Service Continued\"],  \n      errorSteps: [\"Service Disconnected\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ServiceType: [\"Electricity\", \"Gas\", \"Water\"],\n        Region: [\"North\", \"South\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "cryptocurrency_mining": {
      "name": "cryptocurrency_mining",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Cryptocurrency Mining\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Equipment Setup\",\n      kpi: \"Setup Success Rate\",\n      details: \"Setting up mining equipment\",\n      subSteps: [\"Hardware Installation\", \"Software Configuration\"],\n      errorSteps: [\"Setup Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        EquipmentType: [\"ASIC\", \"GPU\", \"CPU\"]\n      }\n    },\n    {\n      stepName: \"Mining Pool Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Selecting a mining pool\",\n      subSteps: [\"Pool Research\", \"Pool Join\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PoolType: [\"Public Pool\", \"Private Pool\"]\n      }\n    },\n    {\n      stepName: \"Mining Operation\",\n      kpi: \"Operation Success Rate\",\n      details: \"Running the mining operation\",\n      subSteps: [\"Operation Start\", \"Operation Monitoring\"],\n      errorSteps: [\"Operation Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CryptocurrencyType: [\"Bitcoin\", \"Ethereum\", \"Litecoin\"]\n      }\n    },\n    {\n      stepName: \"Profit Calculation\",\n      kpi: \"Calculation Success Rate\",\n      details: \"Calculating mining profits\",\n      subSteps: [\"Revenue Calculation\", \"Expense Deduction\"],\n      errorSteps: [\"Calculation Error\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProfitMetrics: [\"Revenue\", \"Expenses\", \"Net Profit\"]\n      }\n    },\n    {\n      stepName: \"Payout Distribution\",\n      kpi: \"Distribution Success Rate\",\n      details: \"Distributing mining payouts\",\n      subSteps: [\"Payout Calculation\", \"Payout Transfer\"],\n      errorSteps: [\"Distribution Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PayoutMethod: [\"Direct Wallet Transfer\", \"Bank Transfer\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from miners on the mining process\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"Forum\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 4
      },
      "conditions": {
        "states": {
          "space_tourism_booking": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "space_tourism_booking"
      ]
    },
    "e-commerce_and_retail": {
      "name": "e-commerce_and_retail",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - E-Commerce & Retail\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Selection\", \n      kpi: \"Product Selection Success Rate\", \n      details: \"Customer selects a product to add to cart\", \n      subSteps: [\"Browsing\", \"Added to Cart\"], \n      errorSteps: [\"Product Out of Stock\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DeviceType: [\"Mobile\", \"Desktop\", \"Tablet\"],\n        Category: [\"Electronics\", \"Clothing\", \"Home Goods\"]\n      },\n    },\n    { \n      stepName: \"Cart Checkout\", \n      kpi: \"Cart Checkout Success Rate\", \n      details: \"Customer checks out the cart\", \n      subSteps: [\"Review Cart\", \"Proceed to Checkout\"], \n      errorSteps: [\"Cart Abandoned\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 20 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentOption: [\"One-Click\", \"Standard\"],\n        ShippingMethod: [\"Standard Shipping\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Customer completes the payment process\", \n      subSteps: [\"Payment Initiated\", \"Payment Processed\"],\n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Order Fulfillment\", \n      kpi: \"Order Fulfillment Success\", \n      details: \"Order is processed and fulfilled\", \n      subSteps: [\"Order Received\", \"Packed for Shipment\", \"Shipped\"],  \n      errorSteps: [\"Fulfillment Delay\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FulfillmentCenter: [\"London\", \"Manchester\", \"Birmingham\"],\n        DeliveryType: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Shipping & Delivery\", \n      kpi: \"On-Time Delivery Rate\", \n      details: \"Order is shipped and delivered to customer\", \n      subSteps: [\"Shipped\", \"Out for Delivery\", \"Delivered\"], \n      errorSteps: [\"Delivery Delayed\"], \n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CourierService: [\"DHL\", \"Royal Mail\", \"UPS\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Post-Purchase Feedback\", \n      kpi: \"Customer Feedback Rate\", \n      details: \"Customer provides feedback after order is delivered\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "hmcts_probate_journey": {
      "name": "hmcts_probate_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - HMCTS Probate\", \n  numberOfCustomers: 100, \nsteps: [\n    { \n      stepName: \"Register for MyHMCTS\", \n      kpi: \"Registration Success Rate\", \n      details: \"User completes the registration process for MyHMCTS.\", \n      subSteps: [\n        \"Set up HMCTS Payment by Account (PBA)\",\n        \"Register your organisation with MyHMCTS\",\n        \"Set up your MyHMCTS user account\"\n      ],\n      errorSteps: [\"Registration Failed\"], \n      errorProbability: 0.02,\n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AccountType: [\"Business\", \"Personal\"]\n      },\n    },\n    { \n      stepName: \"Create a Case\", \n      kpi: \"Case Creation Success Rate\", \n      details: \"User initiates a new probate case.\", \n      subSteps: [\n        \"Sign in to MyHMCTS\",\n        \"Select 'Create case'\",\n        \"Choose jurisdiction, case type, and event\",\n        \"Enter case details\"\n      ],\n      errorSteps: [\"Case Creation Failed\"], \n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CaseType: [\"With Will\", \"Without Will\"]\n      },\n    },\n    { \n      stepName: \"Apply for Grant of Probate (with a will)\", \n      kpi: \"Application Success Rate\", \n      details: \"User applies for a grant of probate.\", \n      subSteps: [\n        \"Enter deceased's details\",\n        \"Provide will information\",\n        \"Add executor details\",\n        \"Review and confirm information\"\n      ],\n      errorSteps: [\"Application Submission Error\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 60 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ExecutorCount: [\"Single Executor\", \"Multiple Executors\"]\n      },\n    },\n    { \n      stepName: \"Apply for Letters of Administration (without a will)\", \n      kpi: \"Application Completion Rate\", \n      details: \"User applies for letters of administration when no valid will exists.\", \n      subSteps: [\n        \"Enter deceased's details\",\n        \"Confirm no valid will exists\",\n        \"Add administrator details\",\n        \"Review and confirm information\"\n      ],\n      errorSteps: [\"Application Rejection\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 75 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AdministratorCount: [\"Single Administrator\", \"Multiple Administrators\"]\n      },\n    },\n    { \n      stepName: \"Complete Your Application\", \n      kpi: \"Completion Success Rate\", \n      details: \"User completes the probate application process.\", \n      subSteps: [\n        \"Sign the statement of truth\",\n        \"Upload supporting documents\",\n        \"Review application summary\",\n        \"Submit application\"\n      ],\n      errorSteps: [\"Submission Failure\"], \n      errorProbability: 0.05,\n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"Postal Submission\"]\n      },\n    },\n    { \n      stepName: \"Track the Progress of Your Case\", \n      kpi: \"Case Tracking Completion Rate\", \n      details: \"User monitors the progress of their probate application.\", \n      subSteps: [\n        \"Access 'Case list' in MyHMCTS\",\n        \"Monitor case status updates\",\n        \"Respond to requests for additional information\",\n        \"Receive grant of probate or letters of administration\"\n      ],\n      errorSteps: [\"Case Progress Error\"], \n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CaseStatus: [\"Pending Review\", \"Additional Information Requested\", \"Completed\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 5
      },
      "conditions": {
        "states": {
          "finance_investment_account_setup": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "finance_investment_account_setup"
      ]
    },
    "home_loan_application": {
      "name": "home_loan_application",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Home Loan Application\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Loan Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about home loan options\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Fixed Rate\", \"Adjustable Rate\", \"FHA\", \"VA\"]\n      }\n    },\n    {\n      stepName: \"Application Submission\",\n      kpi: \"Submission Success Rate\",\n      details: \"Customer submits a home loan application\",\n      subSteps: [\"Application Submitted\", \"Application Received\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SubmissionMethod: [\"Online\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information for the loan application\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\", \"Income Information\"]\n      }\n    },\n    {\n      stepName: \"Credit Check\",\n      kpi: \"Credit Check Success Rate\",\n      details: \"Customer's credit is checked for the loan application\",\n      subSteps: [\"Credit Check Initiated\", \"Credit Check Completed\"],\n      errorSteps: [\"Credit Check Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CreditBureau: [\"Experian\", \"TransUnion\", \"Equifax\"]\n      }\n    },\n    {\n      stepName: \"Loan Approval\",\n      kpi: \"Approval Success Rate\",\n      details: \"Home loan application is approved\",\n      subSteps: [\"Approval Initiated\", \"Approval Granted\"],\n      errorSteps: [\"Approval Denied\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ApprovalType: [\"Conditional\", \"Unconditional\"]\n      }\n    },\n    {\n      stepName: \"Loan Disbursement\",\n      kpi: \"Disbursement Success Rate\",\n      details: \"Approved loan is disbursed to the customer\",\n      subSteps: [\"Disbursement Initiated\", \"Disbursement Completed\"],\n      errorSteps: [\"Disbursement Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DisbursementMethod: [\"Direct Deposit\", \"Check\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 10
      },
      "conditions": {
        "states": {
          "cryptocurrency_exchange": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "cryptocurrency_exchange"
      ]
    },
    "hotel_booking_journey": {
      "name": "hotel_booking_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Hotel Booking Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Room Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available hotel rooms\", \n      subSteps: [\"Search Started\", \"Room Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BookingPlatform: [\"Website\", \"Mobile App\", \"Third-Party\"],\n        RoomType: [\"Single\", \"Double\", \"Suite\"]\n      },\n    },\n    { \n      stepName: \"Booking Confirmation\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer confirms their hotel room booking\", \n      subSteps: [\"Booking Details Entered\", \"Booking Confirmed\"], \n      errorSteps: [\"Booking Failed\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Customer checks into the hotel\", \n      subSteps: [\"Booking Confirmed\", \"Check-In Completed\"],\n      errorSteps: [\"Check-In Failed\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CheckInMethod: [\"In-Person\", \"Online\"],\n        RoomType: [\"Single\", \"Double\", \"Suite\"]\n      },\n    },\n    { \n      stepName: \"Stay Experience\", \n      kpi: \"Stay Experience Rating\", \n      details: \"Customer stays at the hotel and rates their experience\", \n      subSteps: [\"Check-In\", \"Stay Completed\"],  \n      errorSteps: [\"Issue During Stay\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ServiceType: [\"Room Service\", \"Spa\", \"Concierge\"],\n        StayDuration: [\"1 Night\", \"2-3 Nights\", \"1 Week\"]\n      },\n    },\n    { \n      stepName: \"Check-Out\", \n      kpi: \"Check-Out Success Rate\", \n      details: \"Customer checks out of the hotel\", \n      subSteps: [\"Check-Out Initiated\", \"Check-Out Completed\"],  \n      errorSteps: [\"Check-Out Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        FeedbackProvided: [\"Yes\", \"No\"]\n      },\n    },\n    { \n      stepName: \"Post-Stay Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after their stay\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Unsatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 2
      },
      "conditions": {
        "states": {
          "e-commerce_and_retail": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "e-commerce_and_retail"
      ]
    },
    "mobile_phone_contract": {
      "name": "mobile_phone_contract",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mobile Phone Contract\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Plan Selection\", \n      kpi: \"Plan Selection Success Rate\", \n      details: \"Customer selects a phone plan for purchase\", \n      subSteps: [\"Plan Browsed\", \"Plan Selected\"], \n      errorSteps: [\"Selection Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlanType: [\"Unlimited Data\", \"Limited Data\", \"Pay-as-you-go\"],\n        ContractLength: [\"12 Months\", \"24 Months\", \"36 Months\"]\n      },\n    },\n    { \n      stepName: \"Phone Selection\", \n      kpi: \"Phone Selection Success Rate\", \n      details: \"Customer selects a mobile phone for their contract\", \n      subSteps: [\"Phone Browsed\", \"Phone Selected\"], \n      errorSteps: [\"Phone Out of Stock\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PhoneBrand: [\"Apple\", \"Samsung\", \"Google\", \"OnePlus\"],\n        StorageOption: [\"64GB\", \"128GB\", \"256GB\"]\n      },\n    },\n    { \n      stepName: \"Credit Check\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Customer undergoes a credit check before the contract is approved\", \n      subSteps: [\"Credit Check Requested\", \"Credit Check Completed\"],  \n      errorSteps: [\"Credit Check Failed\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CreditCheckResult: [\"Approved\", \"Denied\", \"Additional Information Needed\"],\n        CreditCheckProvider: [\"Experian\", \"Equifax\", \"TransUnion\"]\n      },\n    },\n    { \n      stepName: \"Contract Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Contract is approved and ready for final review\", \n      subSteps: [\"Approval Initiated\", \"Contract Approved\"],  \n      errorSteps: [\"Contract Rejected\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApprovalMethod: [\"Manual\", \"Automatic\"],\n        ContractType: [\"New\", \"Upgrade\"]\n      },\n    },\n    { \n      stepName: \"Payment & Contract Finalization\", \n      kpi: \"Payment Success Rate\", \n      details: \"Customer makes the initial payment and finalizes the contract\", \n      subSteps: [\"Payment Submitted\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Direct Debit\", \"Bank Transfer\"],\n        PaymentType: [\"Deposit\", \"First Month Payment\"]\n      },\n    },\n    { \n      stepName: \"Phone Activation & Delivery\", \n      kpi: \"Activation Success Rate\", \n      details: \"Phone is activated and delivered to the customer\", \n      subSteps: [\"Phone Activated\", \"Delivery Confirmed\"],  \n      errorSteps: [\"Activation Delayed\", \"Delivery Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DeliveryMethod: [\"Courier\", \"In-Store Pickup\"],\n        ActivationMethod: [\"Manual Activation\", \"Automatic Activation\"]\n      },\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 5
      },
      "conditions": {
        "states": {
          "passport_application_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "passport_application_journey"
      ]
    },
    "smart_grid_management": {
      "name": "smart_grid_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Smart Grid Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Grid Status Monitoring\",\n      kpi: \"Monitoring Success Rate\",\n      details: \"Monitoring the status of the smart grid\",\n      subSteps: [\"Status Check Initiated\", \"Status Update Received\"],\n      errorSteps: [\"Monitoring Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringTool: [\"SCADA\", \"IoT Sensors\"]\n      }\n    },\n    {\n      stepName: \"Load Forecasting\",\n      kpi: \"Forecasting Success Rate\",\n      details: \"Forecasting the electrical load for the smart grid\",\n      subSteps: [\"Forecasting Initiated\", \"Forecast Generated\"],\n      errorSteps: [\"Forecasting Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ForecastingMethod: [\"Historical Data\", \"Real-Time Data\"]\n      }\n    },\n    {\n      stepName: \"Demand Response Management\",\n      kpi: \"Response Success Rate\",\n      details: \"Managing demand response for the smart grid\",\n      subSteps: [\"Demand Response Initiated\", \"Demand Response Completed\"],\n      errorSteps: [\"Demand Response Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ResponseType: [\"Automated\", \"Manual\"]\n      }\n    },\n    {\n      stepName: \"Fault Detection\",\n      kpi: \"Detection Success Rate\",\n      details: \"Detecting faults in the smart grid\",\n      subSteps: [\"Fault Detection Initiated\", \"Fault Identified\"],\n      errorSteps: [\"Detection Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DetectionMethod: [\"Real-Time Monitoring\", \"Scheduled Inspections\"]\n      }\n    },\n    {\n      stepName: \"Grid Optimization\",\n      kpi: \"Optimization Success Rate\",\n      details: \"Optimizing the operation of the smart grid\",\n      subSteps: [\"Optimization Initiated\", \"Optimization Completed\"],\n      errorSteps: [\"Optimization Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        OptimizationMethod: [\"AI Algorithms\", \"Manual Adjustments\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback on the smart grid management system\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 8
      },
      "conditions": {
        "states": {
          "fitness_class_enrollment": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "fitness_class_enrollment"
      ]
    },
    "smart_home_automation": {
      "name": "smart_home_automation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Smart Home Automation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about smart home automation services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Lighting Control\", \"Climate Control\", \"Security Systems\"]\n      }\n    },\n    {\n      stepName: \"System Design\",\n      kpi: \"Design Success Rate\",\n      details: \"Designing the smart home automation system\",\n      subSteps: [\"Design Consultation\", \"Design Finalization\"],\n      errorSteps: [\"Design Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SystemType: [\"Basic\", \"Advanced\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Installation\",\n      kpi: \"Installation Success Rate\",\n      details: \"Installing the smart home automation system\",\n      subSteps: [\"Installation Scheduled\", \"Installation Completed\"],\n      errorSteps: [\"Installation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InstallationType: [\"Professional\", \"DIY\"]\n      }\n    },\n    {\n      stepName: \"System Integration\",\n      kpi: \"Integration Success Rate\",\n      details: \"Integrating the smart home devices\",\n      subSteps: [\"Integration Initiated\", \"Integration Completed\"],\n      errorSteps: [\"Integration Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        IntegrationType: [\"Voice Control\", \"App Control\", \"Remote Control\"]\n      }\n    },\n    {\n      stepName: \"Testing and Calibration\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing and calibrating the smart home automation system\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CalibrationMethod: [\"Manual\", \"Automated\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on smart home automation services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 7
      },
      "description": "Run custom JavaScript code.",
      "predecessors": []
    },
    "space_tourism_booking": {
      "name": "space_tourism_booking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Space Tourism Booking\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about space tourism options\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Suborbital Flight\", \"Orbital Flight\", \"Lunar Mission\"]\n      }\n    },\n    {\n      stepName: \"Booking Confirmation\",\n      kpi: \"Confirmation Success Rate\",\n      details: \"Customer confirms the space tourism booking\",\n      subSteps: [\"Booking Created\", \"Booking Confirmed\"],\n      errorSteps: [\"Booking Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TravelPackage: [\"Basic\", \"Premium\", \"VIP\"]\n      }\n    },\n    {\n      stepName: \"Pre-Flight Preparation\",\n      kpi: \"Preparation Success Rate\",\n      details: \"Customer undergoes pre-flight training and medical checks\",\n      subSteps: [\"Training Scheduled\", \"Medical Check Completed\"],\n      errorSteps: [\"Preparation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PreparationType: [\"Physical Training\", \"Simulations\", \"Health Check\"]\n      }\n    },\n    {\n      stepName: \"Flight Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Customer participates in the space tourism flight\",\n      subSteps: [\"Flight Initiated\", \"Flight Completed\"],\n      errorSteps: [\"Flight Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 6 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FlightType: [\"Suborbital\", \"Orbital\", \"Lunar\"]\n      }\n    },\n    {\n      stepName: \"Post-Flight Debrief\",\n      kpi: \"Debrief Success Rate\",\n      details: \"Customer undergoes a post-flight debrief\",\n      subSteps: [\"Debrief Scheduled\", \"Debrief Completed\"],\n      errorSteps: [\"Debrief Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DebriefMethod: [\"In-Person\", \"Virtual\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on their space tourism experience\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 3
      },
      "conditions": {
        "states": {
          "drone_delivery_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "drone_delivery_services"
      ]
    },
    "university_admissions": {
      "name": "university_admissions",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - University Admissions\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Student submits a university application\", \n      subSteps: [\"Application Started\", \"Application Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CourseType: [\"Undergraduate\", \"Postgraduate\"],\n        SubmissionMethod: [\"UCAS\", \"Direct Application\"]\n      },\n    },\n    { \n      stepName: \"Document Submission\", \n      kpi: \"Document Submission Success Rate\", \n      details: \"Student submits supporting documents (e.g., transcripts)\", \n      subSteps: [\"Documents Uploaded\", \"Verification Ongoing\"], \n      errorSteps: [\"Document Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DocumentType: [\"Transcript\", \"Recommendation Letter\"],\n        SubmissionMethod: [\"Online\", \"Post\"]\n      },\n    },\n    { \n      stepName: \"Offer Decision\", \n      kpi: \"Decision Success Rate\", \n      details: \"University decides to offer a place or reject the application\", \n      subSteps: [\"Application Reviewed\", \"Decision Made\"],\n      errorSteps: [\"Application Rejected\"], \n      errorProbability: 0.15,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OfferType: [\"Conditional\", \"Unconditional\"],\n        RejectionReason: [\"Grades\", \"Space Availability\"]\n      },\n    },\n    { \n      stepName: \"Offer Acceptance\", \n      kpi: \"Acceptance Success Rate\", \n      details: \"Student accepts or rejects the offer\", \n      subSteps: [\"Offer Accepted\", \"Offer Declined\"],  \n      errorSteps: [\"Acceptance Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AcceptanceMethod: [\"Online\", \"UCAS Portal\"],\n        CourseStart: [\"September\", \"January\"]\n      },\n    },\n    { \n      stepName: \"Enrollment\", \n      kpi: \"Enrollment Success Rate\", \n      details: \"Student enrolls in the course\", \n      subSteps: [\"Enrollment Initiated\", \"Enrollment Confirmed\"],  \n      errorSteps: [\"Enrollment Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EnrollmentMethod: [\"Online\", \"In-Person\"],\n        CourseType: [\"Full-Time\", \"Part-Time\"]\n      },\n    },\n    { \n      stepName: \"Orientation & Induction\", \n      kpi: \"Orientation Attendance Rate\", \n      details: \"Student attends orientation and induction events\", \n      subSteps: [\"Induction Scheduled\", \"Orientation Completed\"],  \n      errorSteps: [\"No Show\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EventType: [\"Welcome Event\", \"Induction\"],\n        AttendanceMethod: [\"In-Person\", \"Virtual\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 2
      },
      "conditions": {
        "states": {
          "automobile_order_production": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "automobile_order_production"
      ]
    },
    "chemical_manufacturing": {
      "name": "chemical_manufacturing",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Chemical Manufacturing\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Raw Material Procurement\",\n      kpi: \"Procurement Success Rate\",\n      details: \"Procuring raw materials for chemical manufacturing\",\n      subSteps: [\"Order Placed\", \"Material Delivered\"],\n      errorSteps: [\"Procurement Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaterialType: [\"Solvents\", \"Catalysts\", \"Intermediates\"]\n      }\n    },\n    {\n      stepName: \"Production\",\n      kpi: \"Production Success Rate\",\n      details: \"Producing chemicals\",\n      subSteps: [\"Batch Preparation\", \"Reaction\", \"Separation\"],\n      errorSteps: [\"Production Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReactionType: [\"Exothermic\", \"Endothermic\"]\n      }\n    },\n    {\n      stepName: \"Quality Control\",\n      kpi: \"Quality Control Success Rate\",\n      details: \"Ensuring the quality of produced chemicals\",\n      subSteps: [\"Sampling\", \"Analysis\", \"Approval\"],\n      errorSteps: [\"Quality Control Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AnalysisMethod: [\"Titration\", \"Spectroscopy\", \"Chromatography\"]\n      }\n    },\n    {\n      stepName: \"Packaging\",\n      kpi: \"Packaging Success Rate\",\n      details: \"Packaging finished chemical products\",\n      subSteps: [\"Packaging Started\", \"Packaging Completed\"],\n      errorSteps: [\"Packaging Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackagingType: [\"Bottles\", \"Drums\", \"Tanks\"]\n      }\n    },\n    {\n      stepName: \"Distribution\",\n      kpi: \"Distribution Success Rate\",\n      details: \"Distributing chemical products to customers\",\n      subSteps: [\"Distribution Planning\", \"Execution\"],\n      errorSteps: [\"Distribution Failed\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DistributionMethod: [\"Truck\", \"Rail\", \"Ship\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on chemical products\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 9
      },
      "conditions": {
        "states": {
          "oil_and_gas_extraction": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "oil_and_gas_extraction"
      ]
    },
    "mobile_app_development": {
      "name": "mobile_app_development",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mobile App Development\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Requirement Gathering\",\n      kpi: \"Requirement Success Rate\",\n      details: \"Gathering and documenting mobile app requirements\",\n      subSteps: [\"Requirement Initiation\", \"Requirement Documentation\"],\n      errorSteps: [\"Requirement Failure\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RequirementType: [\"Functional\", \"Non-Functional\"]\n      }\n    },\n    {\n      stepName: \"Design\",\n      kpi: \"Design Success Rate\",\n      details: \"Designing the mobile app architecture and UI/UX\",\n      subSteps: [\"Design Initiation\", \"Design Completion\"],\n      errorSteps: [\"Design Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DesignType: [\"Wireframe\", \"Prototype\"]\n      }\n    },\n    {\n      stepName: \"Development\",\n      kpi: \"Development Success Rate\",\n      details: \"Coding and implementing the mobile app\",\n      subSteps: [\"Development Initiation\", \"Development Completion\"],\n      errorSteps: [\"Development Failure\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DevelopmentPlatform: [\"iOS\", \"Android\", \"Cross-Platform\"]\n      }\n    },\n    {\n      stepName: \"Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the mobile app for defects\",\n      subSteps: [\"Test Planning\", \"Test Execution\", \"Test Closure\"],\n      errorSteps: [\"Test Failure\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestType: [\"Unit Testing\", \"Integration Testing\", \"System Testing\", \"User Acceptance Testing\"]\n      }\n    },\n    {\n      stepName: \"Deployment\",\n      kpi: \"Deployment Success Rate\",\n      details: \"Deploying the mobile app to app stores\",\n      subSteps: [\"Deployment Planning\", \"Deployment Execution\"],\n      errorSteps: [\"Deployment Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeploymentMethod: [\"Manual\", \"Automated\"],\n        AppStore: [\"Apple App Store\", \"Google Play Store\"]\n      }\n    },\n    {\n      stepName: \"Maintenance\",\n      kpi: \"Maintenance Success Rate\",\n      details: \"Maintaining and updating the mobile app\",\n      subSteps: [\"Maintenance Initiation\", \"Maintenance Completion\"],\n      errorSteps: [\"Maintenance Failure\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaintenanceType: [\"Bug Fixes\", \"Feature Updates\", \"Performance Improvements\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 5
      },
      "conditions": {
        "states": {
          "it_helpdesk_support": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "it_helpdesk_support"
      ]
    },
    "oil_and_gas_extraction": {
      "name": "oil_and_gas_extraction",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Oil and Gas Extraction\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Site Survey\",\n      kpi: \"Survey Success Rate\",\n      details: \"Conducting site surveys for potential extraction\",\n      subSteps: [\"Survey Initiated\", \"Survey Completed\"],\n      errorSteps: [\"Survey Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SurveyMethod: [\"Seismic\", \"Magnetic\", \"Gravity\"]\n      }\n    },\n    {\n      stepName: \"Drilling\",\n      kpi: \"Drilling Success Rate\",\n      details: \"Drilling wells for extraction\",\n      subSteps: [\"Drilling Started\", \"Drilling Completed\"],\n      errorSteps: [\"Drilling Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DrillingType: [\"Vertical\", \"Horizontal\", \"Directional\"]\n      }\n    },\n    {\n      stepName: \"Extraction\",\n      kpi: \"Extraction Success Rate\",\n      details: \"Extracting oil and gas from wells\",\n      subSteps: [\"Extraction Initiated\", \"Extraction Ongoing\"],\n      errorSteps: [\"Extraction Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExtractionMethod: [\"Primary\", \"Secondary\", \"Enhanced\"]\n      }\n    },\n    {\n      stepName: \"Processing\",\n      kpi: \"Processing Success Rate\",\n      details: \"Processing extracted oil and gas\",\n      subSteps: [\"Processing Started\", \"Processing Completed\"],\n      errorSteps: [\"Processing Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProcessingType: [\"Cracking\", \"Distillation\", \"Separation\"]\n      }\n    },\n    {\n      stepName: \"Transportation\",\n      kpi: \"Transportation Success Rate\",\n      details: \"Transporting processed oil and gas\",\n      subSteps: [\"Transportation Arranged\", \"Transportation Completed\"],\n      errorSteps: [\"Transportation Failed\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TransportMethod: [\"Pipeline\", \"Tanker\", \"Truck\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on oil and gas extraction services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 8
      },
      "conditions": {
        "states": {
          "pet_services_appointment": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "pet_services_appointment"
      ]
    },
    "real_estate_management": {
      "name": "real_estate_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Real Estate Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Property Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for properties\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PropertyType: [\"Residential\", \"Commercial\", \"Industrial\", \"Land\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Property Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a property\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PropertyStatus: [\"For Sale\", \"For Rent\", \"Under Construction\"]\n      }\n    },\n    {\n      stepName: \"Contact Agent\",\n      kpi: \"Contact Success Rate\",\n      details: \"Customer contacts a real estate agent\",\n      subSteps: [\"Contact Initiated\", \"Contact Confirmed\"],\n      errorSteps: [\"Contact Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ContactMethod: [\"Email\", \"Phone\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Property Viewing\",\n      kpi: \"Viewing Success Rate\",\n      details: \"Customer views the property\",\n      subSteps: [\"Viewing Scheduled\", \"Viewing Completed\"],\n      errorSteps: [\"Viewing Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ViewingType: [\"Virtual Tour\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Negotiation\",\n      kpi: \"Negotiation Success Rate\",\n      details: \"Customer negotiates the property deal\",\n      subSteps: [\"Negotiation Started\", \"Deal Closed\"],\n      errorSteps: [\"Negotiation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        NegotiationOutcome: [\"Accepted\", \"Rejected\", \"Counter Offer\"]\n      }\n    },\n    {\n      stepName: \"Contract Signing\",\n      kpi: \"Signing Success Rate\",\n      details: \"Customer signs the property contract\",\n      subSteps: [\"Contract Prepared\", \"Contract Signed\"],\n      errorSteps: [\"Signing Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SigningMethod: [\"Electronic\", \"In-Person\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 2
      },
      "conditions": {
        "states": {
          "online_tutoring": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "online_tutoring"
      ]
    },
    "restaurant_reservation": {
      "name": "restaurant_reservation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Restaurant Reservation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Search for Restaurants\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for restaurants\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CuisineType: [\"Italian\", \"Chinese\", \"Indian\", \"French\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Select Restaurant\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a restaurant\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RestaurantType: [\"Fine Dining\", \"Casual Dining\", \"Fast Food\"]\n      }\n    },\n    {\n      stepName: \"Choose Time and Date\",\n      kpi: \"Date and Time Selection Success Rate\",\n      details: \"Customer chooses a time and date for the reservation\",\n      subSteps: [\"Date and Time Selected\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TimeSlot: [\"Morning\", \"Afternoon\", \"Evening\"],\n        DateRange: [\"Weekdays\", \"Weekends\"]\n      }\n    },\n    {\n      stepName: \"Provide Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer provides personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\"]\n      }\n    },\n    {\n      stepName: \"Confirm Reservation\",\n      kpi: \"Confirmation Success Rate\",\n      details: \"Customer confirms the reservation\",\n      subSteps: [\"Confirmation Sent\", \"Confirmation Received\"],\n      errorSteps: [\"Confirmation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfirmationChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    },\n    {\n      stepName: \"Visit Restaurant\",\n      kpi: \"Visit Success Rate\",\n      details: \"Customer visits the restaurant\",\n      subSteps: [\"Arrival\", \"Seated\"],\n      errorSteps: [\"No Show\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        VisitType: [\"Dine-In\", \"Takeaway\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 6
      },
      "conditions": {
        "states": {
          "hmcts_probate_journey": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "hmcts_probate_journey"
      ]
    },
    "utilities_energy_setup": {
      "name": "utilities_energy_setup",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Utilities Energy Setup\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Enquiry\", \n      kpi: \"Enquiry Success Rate\", \n      details: \"Customer makes an enquiry about energy services\", \n      subSteps: [\"Enquiry Submitted\", \"Enquiry Reviewed\"], \n      errorSteps: [\"Enquiry Rejected\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EnquiryMethod: [\"Phone\", \"Online\", \"In-Person\"],\n        ServiceType: [\"Electricity\", \"Gas\", \"Dual Fuel\"]\n      },\n    },\n    { \n      stepName: \"Quote Provided\", \n      kpi: \"Quote Success Rate\", \n      details: \"Customer receives a quote for energy services\", \n      subSteps: [\"Quote Generated\", \"Quote Sent\"], \n      errorSteps: [\"Quote Rejected\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TariffType: [\"Fixed\", \"Variable\", \"Green Energy\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Account Setup\", \n      kpi: \"Account Setup Success Rate\", \n      details: \"Customer sets up an energy account\", \n      subSteps: [\"Account Created\", \"Billing Details Provided\"],  \n      errorSteps: [\"Account Setup Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\"],\n        BillingCycle: [\"Monthly\", \"Quarterly\"]\n      },\n    },\n    { \n      stepName: \"Meter Installation\", \n      kpi: \"Installation Success Rate\", \n      details: \"Installation of energy meter at customer premises\", \n      subSteps: [\"Installation Scheduled\", \"Meter Installed\"],  \n      errorSteps: [\"Installation Failed\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        MeterType: [\"Smart Meter\", \"Standard Meter\"],\n        InstallationMethod: [\"Engineer Visit\", \"Self-Installation\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Energy service is activated for the customer\", \n      subSteps: [\"Activation Requested\", \"Service Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Phone\"],\n        ActivationType: [\"Electricity\", \"Gas\", \"Both\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the energy service setup\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Phone\", \"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 3
      },
      "conditions": {
        "states": {
          "drug_development_and_approval": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "drug_development_and_approval"
      ]
    },
    "aerospace_manufacturing": {
      "name": "aerospace_manufacturing",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Aerospace Manufacturing\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Design and Development\",\n      kpi: \"Design Success Rate\",\n      details: \"Developing and finalizing aircraft designs\",\n      subSteps: [\"Concept Design\", \"Detailed Design\", \"Prototype Development\"],\n      errorSteps: [\"Design Rejected\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DesignType: [\"Commercial Aircraft\", \"Military Aircraft\", \"Spacecraft\"]\n      }\n    },\n    {\n      stepName: \"Material Procurement\",\n      kpi: \"Procurement Success Rate\",\n      details: \"Procuring raw materials for manufacturing\",\n      subSteps: [\"Order Placed\", \"Material Delivered\"],\n      errorSteps: [\"Procurement Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaterialType: [\"Aluminium\", \"Titanium\", \"Composites\"]\n      }\n    },\n    {\n      stepName: \"Assembly\",\n      kpi: \"Assembly Success Rate\",\n      details: \"Assembling aircraft components\",\n      subSteps: [\"Component Fabrication\", \"Sub-Assembly\", \"Final Assembly\"],\n      errorSteps: [\"Assembly Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssemblyType: [\"Manual\", \"Automated\"]\n      }\n    },\n    {\n      stepName: \"Quality Assurance\",\n      kpi: \"Quality Assurance Success Rate\",\n      details: \"Ensuring the quality of assembled aircraft\",\n      subSteps: [\"Inspection\", \"Testing\", \"Certification\"],\n      errorSteps: [\"Quality Assurance Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InspectionMethod: [\"Nondestructive Testing\", \"Functional Testing\"]\n      }\n    },\n    {\n      stepName: \"Delivery\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Delivering the finished aircraft to customers\",\n      subSteps: [\"Logistics Planning\", \"Delivery Execution\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryMethod: [\"Air\", \"Sea\", \"Land\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on the aerospace manufacturing process\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 10
      },
      "conditions": {
        "states": {
          "chemical_manufacturing": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "chemical_manufacturing"
      ]
    },
    "citizen_public_services": {
      "name": "citizen_public_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Citizen Public Services\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Application\", \n      kpi: \"Application Success Rate\", \n      details: \"Citizen applies for a government service\", \n      subSteps: [\"Form Completed\", \"Application Submitted\"], \n      errorSteps: [\"Form Incomplete\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ServiceType: [\"Benefits\", \"Council Tax\", \"Passport\"],\n        SubmissionMethod: [\"Online\", \"In-Person\"]\n      },\n    },\n    { \n      stepName: \"Application Review\", \n      kpi: \"Review Success Rate\", \n      details: \"Application is reviewed by the government office\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"], \n      errorSteps: [\"Review Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReviewMethod: [\"Automated\", \"Manual\"],\n        OfficeLocation: [\"London\", \"Manchester\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Citizen pays for a service (e.g., council tax, passport fees)\", \n      subSteps: [\"Payment Submitted\", \"Payment Confirmed\"],\n      errorSteps: [\"Payment Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Direct Debit\"],\n        Currency: [\"GBP\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Document Issuance\", \n      kpi: \"Document Issuance Rate\", \n      details: \"Government issues documents to the citizen\", \n      subSteps: [\"Document Generated\", \"Document Sent\"],  \n      errorSteps: [\"Issuance Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DocumentType: [\"Passport\", \"Permit\", \"Certificate\"],\n        IssuanceMethod: [\"Mail\", \"In-Person Collection\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Citizen activates a government service (e.g., benefits)\", \n      subSteps: [\"Service Approved\", \"Service Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ServiceType: [\"Health\", \"Housing\", \"Benefits\"],\n        ActivationMethod: [\"Online\", \"Phone\"]\n      },\n    },\n    { \n      stepName: \"Service Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Citizen provides feedback on the government service\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackMethod: [\"Survey\", \"Phone\"],\n        SatisfactionLevel: [\"Satisfied\", \"Neutral\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 2
      },
      "conditions": {
        "states": {
          "mortgage_application_process": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "mortgage_application_process"
      ]
    },
    "cryptocurrency_exchange": {
      "name": "cryptocurrency_exchange",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Cryptocurrency Exchange\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Account Registration\",\n      kpi: \"Registration Success Rate\",\n      details: \"Customer registers for an account\",\n      subSteps: [\"Registration Initiated\", \"Registration Completed\"],\n      errorSteps: [\"Registration Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RegistrationMethod: [\"Email\", \"Phone\"],\n        VerificationMethod: [\"Email Verification\", \"SMS Verification\"]\n      }\n    },\n    {\n      stepName: \"Account Verification\",\n      kpi: \"Verification Success Rate\",\n      details: \"Customer verifies their account\",\n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],\n      errorSteps: [\"Verification Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        VerificationType: [\"ID Verification\", \"Address Verification\"]\n      }\n    },\n    {\n      stepName: \"Deposit Funds\",\n      kpi: \"Deposit Success Rate\",\n      details: \"Customer deposits funds into their account\",\n      subSteps: [\"Deposit Initiated\", \"Deposit Completed\"],\n      errorSteps: [\"Deposit Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DepositMethod: [\"Bank Transfer\", \"Credit Card\", \"Cryptocurrency\"]\n      }\n    },\n    {\n      stepName: \"Buy/Sell Cryptocurrency\",\n      kpi: \"Transaction Success Rate\",\n      details: \"Customer buys or sells cryptocurrency\",\n      subSteps: [\"Transaction Initiated\", \"Transaction Completed\"],\n      errorSteps: [\"Transaction Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TransactionType: [\"Buy\", \"Sell\"],\n        CryptocurrencyType: [\"Bitcoin\", \"Ethereum\", \"Litecoin\"]\n      }\n    },\n    {\n      stepName: \"Withdraw Funds\",\n      kpi: \"Withdrawal Success Rate\",\n      details: \"Customer withdraws funds from their account\",\n      subSteps: [\"Withdrawal Initiated\", \"Withdrawal Completed\"],\n      errorSteps: [\"Withdrawal Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        WithdrawalMethod: [\"Bank Transfer\", \"Credit Card\", \"Cryptocurrency\"]\n      }\n    },\n    {\n      stepName: \"Account Closure\",\n      kpi: \"Closure Success Rate\",\n      details: \"Customer closes their account\",\n      subSteps: [\"Closure Initiated\", \"Closure Completed\"],\n      errorSteps: [\"Closure Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ClosureReason: [\"Personal Preference\", \"Service Issues\", \"Security Concerns\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 9
      },
      "conditions": {
        "states": {
          "fintech_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "fintech_services"
      ]
    },
    "drone_delivery_services": {
      "name": "drone_delivery_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Drone Delivery Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about drone delivery services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Express Delivery\", \"Scheduled Delivery\", \"Bulk Delivery\"]\n      }\n    },\n    {\n      stepName: \"Order Placement\",\n      kpi: \"Placement Success Rate\",\n      details: \"Customer places an order for drone delivery\",\n      subSteps: [\"Order Created\", \"Order Confirmed\"],\n      errorSteps: [\"Placement Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryType: [\"Same Day\", \"Next Day\", \"Two-Day\"]\n      }\n    },\n    {\n      stepName: \"Package Preparation\",\n      kpi: \"Preparation Success Rate\",\n      details: \"Preparing the package for drone delivery\",\n      subSteps: [\"Package Received\", \"Package Prepared\"],\n      errorSteps: [\"Preparation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackageType: [\"Small\", \"Medium\", \"Large\"]\n      }\n    },\n    {\n      stepName: \"Drone Dispatch\",\n      kpi: \"Dispatch Success Rate\",\n      details: \"Dispatching the drone with the package\",\n      subSteps: [\"Drone Loaded\", \"Drone Dispatched\"],\n      errorSteps: [\"Dispatch Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DroneType: [\"Quadcopter\", \"Fixed-Wing\", \"Hybrid\"]\n      }\n    },\n    {\n      stepName: \"Delivery Execution\",\n      kpi: \"Delivery Success Rate\",\n      details: \"Executing the drone delivery\",\n      subSteps: [\"Delivery In-Progress\", \"Package Delivered\"],\n      errorSteps: [\"Delivery Failed\"],\n      errorProbability: 0.08,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeliveryEnvironment: [\"Urban\", \"Suburban\", \"Rural\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on drone delivery services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 2
      },
      "conditions": {
        "states": {
          "virtual_reality_experience": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "virtual_reality_experience"
      ]
    },
    "media_and_entertainment": {
      "name": "media_and_entertainment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Media & Entertainment Subscription Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Subscription Plan Selection\", \n      kpi: \"Plan Selection Success Rate\", \n      details: \"Customer selects a subscription plan for streaming services\", \n      subSteps: [\"Plan Browsed\", \"Plan Selected\"], \n      errorSteps: [\"Plan Selection Abandoned\"], \n      errorProbability: 0.07,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlanType: [\"Basic\", \"Standard\", \"Premium\"],\n        SubscriptionChannel: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Account Registration\", \n      kpi: \"Registration Success Rate\", \n      details: \"Customer creates a new account for the streaming service\", \n      subSteps: [\"Account Created\", \"Email Verified\"], \n      errorSteps: [\"Registration Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        RegistrationMethod: [\"Email\", \"Social Media\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\"]\n      },\n    },\n    { \n      stepName: \"Subscription Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer activates their subscription\", \n      subSteps: [\"Activation Completed\", \"Content Access Granted\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DeviceUsed: [\"Smart TV\", \"Mobile\", \"Desktop\"],\n        ActivationMethod: [\"Self-Activation\", \"Customer Service\"]\n      },\n    },\n    { \n      stepName: \"Content Browsing\", \n      kpi: \"Browsing Success Rate\", \n      details: \"Customer browses content within the streaming service\", \n      subSteps: [\"Content Browsed\", \"Show/Film Selected\"],  \n      errorSteps: [\"Content Not Available\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ContentType: [\"TV Series\", \"Film\", \"Documentary\"],\n        Genre: [\"Drama\", \"Comedy\", \"Thriller\"]\n      },\n    },\n    { \n      stepName: \"Playback & Streaming\", \n      kpi: \"Playback Success Rate\", \n      details: \"Customer streams selected content\", \n      subSteps: [\"Playback Started\", \"Playback Completed\"],  \n      errorSteps: [\"Playback Interrupted\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlaybackDevice: [\"Smart TV\", \"Mobile\", \"Tablet\"],\n        PlaybackQuality: [\"HD\", \"4K\"]\n      },\n    },\n    { \n      stepName: \"Subscription Renewal\", \n      kpi: \"Renewal Success Rate\", \n      details: \"Customer renews their subscription at the end of the billing cycle\", \n      subSteps: [\"Renewal Initiated\", \"Renewal Completed\"],  \n      errorSteps: [\"Renewal Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Direct Debit\"],\n        SubscriptionTerm: [\"Monthly\", \"Yearly\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 3
      },
      "conditions": {
        "states": {
          "real_estate_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "real_estate_journey"
      ]
    },
    "online_shopping_journey": {
      "name": "online_shopping_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Shopping Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for products online\", \n      subSteps: [\"Search Started\", \"Product Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SearchDevice: [\"Mobile\", \"Desktop\", \"Tablet\"],\n        SearchChannel: [\"Website\", \"App\"]\n      },\n    },\n    { \n      stepName: \"Cart Addition\", \n      kpi: \"Cart Addition Success Rate\", \n      details: \"Customer adds products to their shopping cart\", \n      subSteps: [\"Product Added to Cart\", \"Cart Updated\"], \n      errorSteps: [\"Cart Abandoned\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ProductType: [\"Clothing\", \"Electronics\", \"Home Goods\"],\n        CartAction: [\"Add\", \"Remove\"]\n      },\n    },\n    { \n      stepName: \"Checkout\", \n      kpi: \"Checkout Success Rate\", \n      details: \"Customer proceeds to checkout and enters payment information\", \n      subSteps: [\"Checkout Initiated\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Gift Card\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Order Confirmation\", \n      kpi: \"Order Confirmation Rate\", \n      details: \"Order is confirmed and a receipt is sent to the customer\", \n      subSteps: [\"Order Confirmed\", \"Email Sent\"],  \n      errorSteps: [\"Order Canceled\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OrderChannel: [\"Website\", \"App\"],\n        ShippingMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Order Shipment\", \n      kpi: \"Shipment Success Rate\", \n      details: \"Order is shipped to the customer\", \n      subSteps: [\"Shipped\", \"Out for Delivery\"],  \n      errorSteps: [\"Shipment Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ShippingProvider: [\"DHL\", \"Royal Mail\", \"UPS\"],\n        ShippingSpeed: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after receiving the order\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackMethod: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Neutral\", \"Unsatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 3
      },
      "conditions": {
        "states": {
          "citizen_public_services": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "citizen_public_services"
      ]
    },
    "spa_appointment_booking": {
      "name": "spa_appointment_booking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Spa Appointment Booking\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for spa services\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceType: [\"Massage\", \"Facial\", \"Manicure\", \"Pedicure\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects spa services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceCategory: [\"Relaxation\", \"Therapeutic\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Appointment Confirmation\",\n      kpi: \"Confirmation Success Rate\",\n      details: \"Customer receives appointment confirmation\",\n      subSteps: [\"Confirmation Sent\", \"Confirmation Received\"],\n      errorSteps: [\"Confirmation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfirmationChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    },\n    {\n      stepName: \"Service Completion\",\n      kpi: \"Service Success Rate\",\n      details: \"Customer receives the spa service\",\n      subSteps: [\"Service Started\", \"Service Completed\"],\n      errorSteps: [\"Service Not Completed\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Neutral\", \"Dissatisfied\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 7
      },
      "conditions": {
        "states": {
          "hospitality_guest_experience": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "hospitality_guest_experience"
      ]
    },
    "telehealth_consultation": {
      "name": "telehealth_consultation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Telehealth Consultation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about telehealth services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"General Consultation\", \"Specialist Consultation\", \"Follow-Up\"]\n      }\n    },\n    {\n      stepName: \"Appointment Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Scheduling a telehealth appointment\",\n      subSteps: [\"Appointment Requested\", \"Appointment Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AppointmentType: [\"Video Call\", \"Phone Call\", \"Chat\"]\n      }\n    },\n    {\n      stepName: \"Consultation Preparation\",\n      kpi: \"Preparation Success Rate\",\n      details: \"Preparing for the telehealth consultation\",\n      subSteps: [\"Patient Info Collected\", \"Technology Check\"],\n      errorSteps: [\"Preparation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PreparationType: [\"Forms Completed\", \"Device Check\"]\n      }\n    },\n    {\n      stepName: \"Consultation Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Conducting the telehealth consultation\",\n      subSteps: [\"Consultation Started\", \"Consultation Completed\"],\n      errorSteps: [\"Consultation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConsultationType: [\"General\", \"Specialist\", \"Follow-Up\"]\n      }\n    },\n    {\n      stepName: \"Post-Consultation Actions\",\n      kpi: \"Action Success Rate\",\n      details: \"Following up on the telehealth consultation\",\n      subSteps: [\"Prescription Sent\", \"Lab Tests Ordered\"],\n      errorSteps: [\"Action Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FollowUpType: [\"Prescription\", \"Lab Tests\", \"Referrals\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on telehealth services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 8
      },
      "conditions": {
        "states": {
          "smart_home_automation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "smart_home_automation"
      ]
    },
    "agriculture_supply_chain": {
      "name": "agriculture_supply_chain",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Agriculture Supply Chain\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Farm Inputs Supply\",\n      kpi: \"Supply Success Rate\",\n      details: \"Supplying necessary farm inputs\",\n      subSteps: [\"Supply Order Initiated\", \"Supply Delivered\"],\n      errorSteps: [\"Supply Failure\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SupplyType: [\"Seeds\", \"Fertilizers\", \"Pesticides\", \"Machinery\"]\n      }\n    },\n    {\n      stepName: \"Farm Production\",\n      kpi: \"Production Success Rate\",\n      details: \"Cultivating and harvesting crops\",\n      subSteps: [\"Cultivation Initiated\", \"Harvest Completed\"],\n      errorSteps: [\"Production Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CropType: [\"Cereals\", \"Vegetables\", \"Fruits\", \"Legumes\"]\n      }\n    },\n    {\n      stepName: \"Processing & Packaging\",\n      kpi: \"Processing Success Rate\",\n      details: \"Processing and packaging harvested crops\",\n      subSteps: [\"Processing Started\", \"Packaging Completed\"],\n      errorSteps: [\"Processing Failure\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProcessingType: [\"Cleaning\", \"Sorting\", \"Grinding\", \"Packaging\"]\n      }\n    },\n    {\n      stepName: \"Storage\",\n      kpi: \"Storage Success Rate\",\n      details: \"Storing processed agricultural products\",\n      subSteps: [\"Storage Arranged\", \"Storage Completed\"],\n      errorSteps: [\"Storage Failure\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        StorageType: [\"Cold Storage\", \"Dry Storage\", \"Warehouse Storage\"]\n      }\n    },\n    {\n      stepName: \"Distribution\",\n      kpi: \"Distribution Success Rate\",\n      details: \"Distributing agricultural products to markets\",\n      subSteps: [\"Distribution Planning\", \"Distribution Executed\"],\n      errorSteps: [\"Distribution Failure\"],\n      errorProbability: 0.09,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DistributionMode: [\"Truck\", \"Ship\", \"Air Cargo\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on agricultural products\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 9
      },
      "conditions": {
        "states": {
          "water_treatment_solutions": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "water_treatment_solutions"
      ]
    },
    "cable_service_activation": {
      "name": "cable_service_activation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Cable Service Activation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about cable services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Basic Cable\", \"Premium Cable\", \"Bundles\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a cable service package\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackageType: [\"Standard\", \"Premium\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Cable service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Store\", \"Technician Visit\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the cable service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Channel Surfing\", \"On-Demand\", \"DVR\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the cable service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 7
      },
      "conditions": {
        "states": {
          "game_development": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "game_development"
      ]
    },
    "fitness_class_enrollment": {
      "name": "fitness_class_enrollment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Fitness Class Enrollment\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Class Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for a fitness class\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ClassType: [\"Yoga\", \"Pilates\", \"HIIT\", \"Dance\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Class Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a fitness class\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ClassDuration: [\"30 mins\", \"45 mins\", \"60 mins\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\"]\n      }\n    },\n    {\n      stepName: \"Payment\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes payment\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"PayPal\"]\n      }\n    },\n    {\n      stepName: \"Confirmation\",\n      kpi: \"Confirmation Success Rate\",\n      details: \"Customer receives class confirmation\",\n      subSteps: [\"Confirmation Sent\", \"Confirmation Received\"],\n      errorSteps: [\"Confirmation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfirmationChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    },\n    {\n      stepName: \"Class Attendance\",\n      kpi: \"Attendance Success Rate\",\n      details: \"Customer attends the fitness class\",\n      subSteps: [\"Class Started\", \"Class Completed\"],\n      errorSteps: [\"Did Not Attend\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AttendanceType: [\"In-Person\", \"Virtual\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 7
      },
      "conditions": {
        "states": {
          "car_rental_booking": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "car_rental_booking"
      ]
    },
    "genetic_testing_services": {
      "name": "genetic_testing_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Genetic Testing Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about genetic testing services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Ancestry\", \"Health\", \"Traits\"]\n      }\n    },\n    {\n      stepName: \"Sample Collection\",\n      kpi: \"Collection Success Rate\",\n      details: \"Collecting genetic samples from customers\",\n      subSteps: [\"Sample Kit Sent\", \"Sample Collected\"],\n      errorSteps: [\"Collection Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SampleType: [\"Saliva\", \"Blood\", \"Cheek Swab\"]\n      }\n    },\n    {\n      stepName: \"Sample Analysis\",\n      kpi: \"Analysis Success Rate\",\n      details: \"Analyzing the collected genetic samples\",\n      subSteps: [\"Analysis Started\", \"Analysis Completed\"],\n      errorSteps: [\"Analysis Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AnalysisType: [\"Genotyping\", \"Sequencing\"]\n      }\n    },\n    {\n      stepName: \"Results Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Reporting the analysis results to customers\",\n      subSteps: [\"Results Prepared\", \"Results Delivered\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Digital Report\", \"Printed Report\"]\n      }\n    },\n    {\n      stepName: \"Consultation\",\n      kpi: \"Consultation Success Rate\",\n      details: \"Providing consultation based on genetic testing results\",\n      subSteps: [\"Consultation Scheduled\", \"Consultation Completed\"],\n      errorSteps: [\"Consultation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConsultationType: [\"Phone\", \"Video Call\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on genetic testing services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 9
      },
      "conditions": {
        "states": {
          "autonomous_vehicle_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "autonomous_vehicle_management"
      ]
    },
    "interior_design_services": {
      "name": "interior_design_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Interior Design Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Consultation Request\",\n      kpi: \"Request Success Rate\",\n      details: \"Customer requests an interior design consultation\",\n      subSteps: [\"Request Initiated\", \"Request Confirmed\"],\n      errorSteps: [\"Request Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RequestChannel: [\"Website\", \"Phone\", \"Walk-in\"]\n      }\n    },\n    {\n      stepName: \"Initial Consultation\",\n      kpi: \"Consultation Success Rate\",\n      details: \"Customer has an initial consultation with a designer\",\n      subSteps: [\"Consultation Scheduled\", \"Consultation Completed\"],\n      errorSteps: [\"Consultation Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConsultationMethod: [\"In-Person\", \"Virtual\"]\n      }\n    },\n    {\n      stepName: \"Design Proposal\",\n      kpi: \"Proposal Success Rate\",\n      details: \"Designer prepares and presents a design proposal\",\n      subSteps: [\"Proposal Created\", \"Proposal Presented\"],\n      errorSteps: [\"Proposal Rejected\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProposalFormat: [\"2D Drawing\", \"3D Model\"]\n      }\n    },\n    {\n      stepName: \"Design Approval\",\n      kpi: \"Approval Success Rate\",\n      details: \"Customer reviews and approves the design proposal\",\n      subSteps: [\"Approval Requested\", \"Approval Received\"],\n      errorSteps: [\"Approval Denied\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ApprovalMethod: [\"Online\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Project Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Design project is executed and implemented\",\n      subSteps: [\"Project Started\", \"Project Completed\"],\n      errorSteps: [\"Execution Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExecutionType: [\"Full Design\", \"Partial Design\"]\n      }\n    },\n    {\n      stepName: \"Final Walkthrough\",\n      kpi: \"Walkthrough Success Rate\",\n      details: \"Final walkthrough with customer and designer\",\n      subSteps: [\"Walkthrough Scheduled\", \"Walkthrough Completed\"],\n      errorSteps: [\"Walkthrough Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        WalkthroughType: [\"In-Person\", \"Virtual\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 2
      },
      "conditions": {
        "states": {
          "education_enrollment": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "education_enrollment"
      ]
    },
    "online_course_enrollment": {
      "name": "online_course_enrollment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Course Enrollment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Course Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Student searches for available online courses\", \n      subSteps: [\"Search Initiated\", \"Courses Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CourseType: [\"Degree Program\", \"Certification\", \"Short Course\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Course Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Student selects a course to enroll in\", \n      subSteps: [\"Course Selected\", \"Enrollment Started\"], \n      errorSteps: [\"Course Unavailable\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EnrollmentChannel: [\"Website\", \"App\"],\n        CourseLevel: [\"Undergraduate\", \"Postgraduate\", \"Professional\"]\n      },\n    },\n    { \n      stepName: \"Payment\", \n      kpi: \"Payment Success Rate\", \n      details: \"Student pays for the selected course\", \n      subSteps: [\"Payment Processed\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        PaymentCurrency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Course Access\", \n      kpi: \"Access Success Rate\", \n      details: \"Student gains access to the course materials\", \n      subSteps: [\"Access Granted\", \"Course Started\"],  \n      errorSteps: [\"Access Denied\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AccessMethod: [\"Browser\", \"Mobile App\"],\n        StudyMode: [\"Full-Time\", \"Part-Time\"]\n      },\n    },\n    { \n      stepName: \"Course Completion\", \n      kpi: \"Completion Rate\", \n      details: \"Student completes the online course\", \n      subSteps: [\"Final Exam Completed\", \"Course Completion Confirmed\"],  \n      errorSteps: [\"Failed to Complete\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CompletionMethod: [\"Exam\", \"Project\"],\n        Certification: [\"Yes\", \"No\"]\n      },\n    },\n    { \n      stepName: \"Feedback Submission\", \n      kpi: \"Feedback Submission Rate\", \n      details: \"Student provides feedback on the course\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 4
      },
      "conditions": {
        "states": {
          "media_and_entertainment": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "media_and_entertainment"
      ]
    },
    "pet_services_appointment": {
      "name": "pet_services_appointment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Pet Services Appointment\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for pet services\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceType: [\"Grooming\", \"Vet Consultation\", \"Training\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects pet services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PetType: [\"Dog\", \"Cat\", \"Bird\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Pet Details\"]\n      }\n    },\n    {\n      stepName: \"Service Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Customer schedules the pet service appointment\",\n      subSteps: [\"Schedule Initiated\", \"Schedule Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Availability: [\"Weekdays\", \"Weekends\", \"Evenings\"]\n      }\n    },\n    {\n      stepName: \"Service Delivery\",\n      kpi: \"Service Completion Rate\",\n      details: \"Service professional completes the pet service\",\n      subSteps: [\"Service Started\", \"Service Completed\"],\n      errorSteps: [\"Service Not Completed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceOutcome: [\"Successful\", \"Revisit Required\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the pet service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 7
      },
      "conditions": {
        "states": {
          "online_food_delivery": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "online_food_delivery"
      ]
    },
    "solar_panel_installation": {
      "name": "solar_panel_installation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Solar Panel Installation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about solar panel installation services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Site Assessment\",\n      kpi: \"Assessment Success Rate\",\n      details: \"Conducting a site assessment for solar panel installation\",\n      subSteps: [\"Assessment Scheduled\", \"Assessment Completed\"],\n      errorSteps: [\"Assessment Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssessmentType: [\"On-Site\", \"Remote\"]\n      }\n    },\n    {\n      stepName: \"Proposal Submission\",\n      kpi: \"Proposal Success Rate\",\n      details: \"Submitting a proposal for solar panel installation\",\n      subSteps: [\"Proposal Created\", \"Proposal Submitted\"],\n      errorSteps: [\"Proposal Rejected\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProposalType: [\"Standard\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Installation\",\n      kpi: \"Installation Success Rate\",\n      details: \"Installing solar panels at the customer's site\",\n      subSteps: [\"Installation Scheduled\", \"Installation Completed\"],\n      errorSteps: [\"Installation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InstallationMethod: [\"Professional\", \"Self-Install\"]\n      }\n    },\n    {\n      stepName: \"System Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the installed solar panel system\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestingType: [\"Performance\", \"Safety\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers about the solar panel installation service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 9
      },
      "conditions": {
        "states": {
          "renewable_energy_solutions": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "renewable_energy_solutions"
      ]
    },
    "threed_printing_services": {
      "name": "threed_printing_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - 3D Printing Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about 3D printing services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Prototyping\", \"Manufacturing\", \"Custom Products\"]\n      }\n    },\n    {\n      stepName: \"Design Submission\",\n      kpi: \"Submission Success Rate\",\n      details: \"Customer submits design for 3D printing\",\n      subSteps: [\"Design Uploaded\", \"Design Reviewed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FileFormat: [\"STL\", \"OBJ\", \"3MF\"]\n      }\n    },\n    {\n      stepName: \"Print Setup\",\n      kpi: \"Setup Success Rate\",\n      details: \"Setting up the 3D printer for the print job\",\n      subSteps: [\"Printer Calibration\", \"Material Loading\"],\n      errorSteps: [\"Setup Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PrinterType: [\"FDM\", \"SLA\", \"SLS\"]\n      }\n    },\n    {\n      stepName: \"Printing\",\n      kpi: \"Printing Success Rate\",\n      details: \"Executing the 3D print job\",\n      subSteps: [\"Print Started\", \"Print Completed\"],\n      errorSteps: [\"Printing Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaterialType: [\"PLA\", \"ABS\", \"Resin\"]\n      }\n    },\n    {\n      stepName: \"Post-Processing\",\n      kpi: \"Post-Processing Success Rate\",\n      details: \"Finishing the printed product\",\n      subSteps: [\"Support Removal\", \"Sanding\", \"Painting\"],\n      errorSteps: [\"Post-Processing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PostProcessingType: [\"Manual\", \"Automated\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on 3D printing services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 6
      },
      "conditions": {
        "states": {
          "ai_personal_assistant_setup": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "ai_personal_assistant_setup"
      ]
    },
    "claims_processing_journey": {
      "name": "claims_processing_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Insurance Claims Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Claim Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an insurance claim\", \n      subSteps: [\"Claim Started\", \"Claim Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ClaimType: [\"Home\", \"Car\", \"Health\"],\n        SubmissionMethod: [\"Online\", \"Phone\", \"Agent\"]\n      },\n    },\n    { \n      stepName: \"Claim Acknowledgment\", \n      kpi: \"Acknowledgment Rate\", \n      details: \"Customer receives acknowledgment of their claim\", \n      subSteps: [\"Acknowledgment Sent\", \"Acknowledgment Received\"], \n      errorSteps: [\"No Acknowledgment\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CommunicationMethod: [\"Email\", \"SMS\", \"Phone\"],\n        ResponseTime: [\"Immediate\", \"Delayed\"]\n      },\n    },\n    { \n      stepName: \"Claim Review\", \n      kpi: \"Review Completion Rate\", \n      details: \"Insurance company reviews the claim\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"],  \n      errorSteps: [\"Review Rejected\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 48 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReviewType: [\"Manual\", \"Automated\"],\n        ReviewerRole: [\"Adjuster\", \"Manager\"]\n      },\n    },\n    { \n      stepName: \"Claim Decision\", \n      kpi: \"Decision Rate\", \n      details: \"Insurance company makes a decision on the claim\", \n      subSteps: [\"Decision Made\", \"Customer Notified\"],  \n      errorSteps: [\"Decision Delayed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 72 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DecisionType: [\"Approval\", \"Denial\"],\n        DecisionMethod: [\"Email\", \"Phone\"]\n      },\n    },\n    { \n      stepName: \"Claim Payment\", \n      kpi: \"Payment Completion Rate\", \n      details: \"Customer receives payment for the approved claim\", \n      subSteps: [\"Payment Processed\", \"Payment Completed\"],  \n      errorSteps: [\"Payment Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Bank Transfer\", \"Cheque\"],\n        PaymentCurrency: [\"GBP\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Claim Closure\", \n      kpi: \"Claim Closure Rate\", \n      details: \"Claim is officially closed\", \n      subSteps: [\"Closure Processed\", \"Claim Closed\"],  \n      errorSteps: [\"Closure Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 12 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ClosureReason: [\"Resolved\", \"Withdrawn\"],\n        CommunicationMethod: [\"Email\", \"Letter\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 3
      },
      "conditions": {
        "states": {
          "hotel_booking_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "hotel_booking_journey"
      ]
    },
    "electric_vehicle_charging": {
      "name": "electric_vehicle_charging",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Electric Vehicle Charging Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Charging Station Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about available charging stations\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Public Station\", \"Home Charging\", \"Workplace Charging\"]\n      }\n    },\n    {\n      stepName: \"Station Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a charging station\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        StationType: [\"Level 1\", \"Level 2\", \"DC Fast Charging\"]\n      }\n    },\n    {\n      stepName: \"Charging Process\",\n      kpi: \"Charging Success Rate\",\n      details: \"Customer initiates and completes the charging process\",\n      subSteps: [\"Charging Started\", \"Charging Completed\"],\n      errorSteps: [\"Charging Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PaymentMethod: [\"Credit Card\", \"Mobile Payment\", \"Subscription\"]\n      }\n    },\n    {\n      stepName: \"Payment and Billing\",\n      kpi: \"Payment Success Rate\",\n      details: \"Customer completes the payment for the charging session\",\n      subSteps: [\"Payment Initiated\", \"Payment Completed\"],\n      errorSteps: [\"Payment Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        BillingType: [\"Per kWh\", \"Time-Based\", \"Flat Rate\"]\n      }\n    },\n    {\n      stepName: \"Charging Station Monitoring\",\n      kpi: \"Monitoring Success Rate\",\n      details: \"Monitoring the status of the charging station\",\n      subSteps: [\"Monitoring Started\", \"Monitoring Ongoing\"],\n      errorSteps: [\"Monitoring Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringTools: [\"Mobile App\", \"Website\", \"In-Car System\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the charging service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 10
      },
      "conditions": {
        "states": {
          "solar_panel_installation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "solar_panel_installation"
      ]
    },
    "flight_booking_and_travel": {
      "name": "flight_booking_and_travel",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Flight Booking & Travel\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Flight Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available flights\", \n      subSteps: [\"Search Initiated\", \"Flights Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TravelType: [\"One-Way\", \"Round-Trip\", \"Multi-City\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Flight Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer books a flight\", \n      subSteps: [\"Booking Completed\", \"Payment Made\"], \n      errorSteps: [\"Booking Canceled\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\"],\n        ClassType: [\"Economy\", \"Business\", \"First Class\"]\n      },\n    },\n    { \n      stepName: \"Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Customer checks in for their flight\", \n      subSteps: [\"Check-In Initiated\", \"Check-In Completed\"],  \n      errorSteps: [\"Check-In Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CheckInMethod: [\"Online\", \"In-Person\"],\n        BoardingPassMethod: [\"Mobile\", \"Printed\"]\n      },\n    },\n    { \n      stepName: \"Baggage Drop\", \n      kpi: \"Baggage Drop Success Rate\", \n      details: \"Customer drops off baggage at the airport\", \n      subSteps: [\"Baggage Tagged\", \"Baggage Dropped\"],  \n      errorSteps: [\"Baggage Not Tagged\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BaggageType: [\"Carry-On\", \"Checked\"],\n        DropOffMethod: [\"Self-Service\", \"Staff-Assisted\"]\n      },\n    },\n    { \n      stepName: \"Boarding\", \n      kpi: \"Boarding Success Rate\", \n      details: \"Customer boards the flight\", \n      subSteps: [\"Boarding Initiated\", \"Boarding Completed\"],  \n      errorSteps: [\"Boarding Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BoardingZone: [\"Zone 1\", \"Zone 2\", \"Zone 3\"],\n        SeatType: [\"Window\", \"Aisle\", \"Middle\"]\n      },\n    },\n    { \n      stepName: \"Flight Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their flight experience\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 4
      },
      "conditions": {
        "states": {
          "patient_appointment_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "patient_appointment_journey"
      ]
    },
    "home_maintenance_services": {
      "name": "home_maintenance_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Home Maintenance Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Search\",\n      kpi: \"Search Success Rate\",\n      details: \"Customer searches for home maintenance services\",\n      subSteps: [\"Search Initiated\", \"Results Displayed\"],\n      errorSteps: [\"Search Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceType: [\"Plumbing\", \"Electrical\", \"Cleaning\", \"HVAC\"],\n        SearchChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects home maintenance services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceCategory: [\"Routine Maintenance\", \"Emergency Repair\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Confirmed\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Customer schedules the maintenance service\",\n      subSteps: [\"Schedule Initiated\", \"Schedule Confirmed\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Availability: [\"Weekdays\", \"Weekends\", \"Evenings\"]\n      }\n    },\n    {\n      stepName: \"Service Delivery\",\n      kpi: \"Service Completion Rate\",\n      details: \"Service professional completes the maintenance service\",\n      subSteps: [\"Service Started\", \"Service Completed\"],\n      errorSteps: [\"Service Not Completed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceOutcome: [\"Successful\", \"Revisit Required\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the maintenance service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 7
      },
      "conditions": {
        "states": {
          "event_ticketing": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "event_ticketing"
      ]
    },
    "mobile_service_activation": {
      "name": "mobile_service_activation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mobile Service Activation\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"SIM Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Customer purchases a SIM card\", \n      subSteps: [\"SIM Browsed\", \"SIM Purchased\"], \n      errorSteps: [\"Purchase Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PurchaseChannel: [\"In-Store\", \"Online\", \"Retail Partner\"],\n        SIMType: [\"Prepaid\", \"Postpaid\"]\n      },\n    },\n    { \n      stepName: \"SIM Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer activates their SIM card\", \n      subSteps: [\"Activation Requested\", \"Activation Completed\"], \n      errorSteps: [\"Activation Failed\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Phone\", \"In-Store\"],\n        NetworkType: [\"4G\", \"5G\"]\n      },\n    },\n    { \n      stepName: \"Plan Selection\", \n      kpi: \"Plan Selection Success Rate\", \n      details: \"Customer selects a mobile plan\", \n      subSteps: [\"Plan Browsed\", \"Plan Selected\"],  \n      errorSteps: [\"Plan Selection Abandoned\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlanType: [\"Unlimited Data\", \"Pay As You Go\"],\n        PlanDuration: [\"Monthly\", \"Yearly\"]\n      },\n    },\n    { \n      stepName: \"Payment Setup\", \n      kpi: \"Payment Setup Completion Rate\", \n      details: \"Customer sets up payment for their plan\", \n      subSteps: [\"Payment Method Selected\", \"Payment Setup Completed\"],  \n      errorSteps: [\"Payment Setup Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\"],\n        BillingCycle: [\"Monthly\", \"Annually\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Service Activation Success Rate\", \n      details: \"Mobile service is activated for the customer\", \n      subSteps: [\"Service Activation Requested\", \"Service Activated\"],  \n      errorSteps: [\"Service Activation Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ServiceType: [\"Voice & Data\", \"Data Only\"],\n        ActivationChannel: [\"Online\", \"In-Store\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the service activation process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"SMS\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 3
      },
      "conditions": {
        "states": {
          "banking_new_account_opening": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "banking_new_account_opening"
      ]
    },
    "satellite_tv_installation": {
      "name": "satellite_tv_installation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Satellite TV Installation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about satellite TV services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Basic Package\", \"Premium Package\", \"Bundles\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a satellite TV service package\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackageType: [\"Standard\", \"Premium\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Satellite TV service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Store\", \"Technician Visit\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the satellite TV service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Channel Surfing\", \"On-Demand\", \"DVR\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the satellite TV service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 8
      },
      "conditions": {
        "states": {
          "cable_service_activation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "cable_service_activation"
      ]
    },
    "telemedicine_consultation": {
      "name": "telemedicine_consultation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Telemedicine Consultation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Appointment Booking\",\n      kpi: \"Booking Success Rate\",\n      details: \"Customer books a telemedicine appointment\",\n      subSteps: [\"Booking Initiated\", \"Booking Confirmed\"],\n      errorSteps: [\"Booking Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConsultationType: [\"General\", \"Specialist\"],\n        BookingChannel: [\"Website\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Patient Registration\",\n      kpi: \"Registration Success Rate\",\n      details: \"Patient registers for the telemedicine consultation\",\n      subSteps: [\"Registration Initiated\", \"Registration Completed\"],\n      errorSteps: [\"Registration Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RegistrationMethod: [\"Online\", \"Phone\"]\n      }\n    },\n    {\n      stepName: \"Telemedicine Setup\",\n      kpi: \"Setup Success Rate\",\n      details: \"Patient sets up telemedicine session\",\n      subSteps: [\"Setup Initiated\", \"Setup Completed\"],\n      errorSteps: [\"Setup Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeviceType: [\"PC\", \"Tablet\", \"Smartphone\"],\n        ConnectionType: [\"Wi-Fi\", \"4G\", \"Ethernet\"]\n      }\n    },\n    {\n      stepName: \"Consultation\",\n      kpi: \"Consultation Success Rate\",\n      details: \"Patient has telemedicine consultation with doctor\",\n      subSteps: [\"Consultation Started\", \"Consultation Completed\"],\n      errorSteps: [\"Consultation Interrupted\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConsultationOutcome: [\"Treatment Recommended\", \"Follow-Up Required\"],\n        DoctorType: [\"General Practitioner\", \"Specialist\"]\n      }\n    },\n    {\n      stepName: \"Prescription Issued\",\n      kpi: \"Prescription Success Rate\",\n      details: \"Doctor issues prescription\",\n      subSteps: [\"Prescription Written\", \"Prescription Sent\"],\n      errorSteps: [\"Prescription Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MedicationType: [\"Antibiotic\", \"Painkiller\", \"Chronic Illness Medication\"]\n      }\n    },\n    {\n      stepName: \"Follow-Up\",\n      kpi: \"Follow-Up Success Rate\",\n      details: \"Patient schedules a follow-up appointment\",\n      subSteps: [\"Follow-Up Scheduled\", \"Follow-Up Confirmed\"],\n      errorSteps: [\"Follow-Up Failed\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FollowUpType: [\"Phone Call\", \"Video Call\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 7
      },
      "conditions": {
        "states": {
          "uk_met_police_-_arrest_to_resolution": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "uk_met_police_-_arrest_to_resolution"
      ]
    },
    "water_treatment_solutions": {
      "name": "water_treatment_solutions",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Water Treatment Solutions\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about water treatment solutions\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Site Assessment\",\n      kpi: \"Assessment Success Rate\",\n      details: \"Conducting a site assessment for water treatment solutions\",\n      subSteps: [\"Assessment Scheduled\", \"Assessment Completed\"],\n      errorSteps: [\"Assessment Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssessmentType: [\"On-Site\", \"Remote\"]\n      }\n    },\n    {\n      stepName: \"Proposal Submission\",\n      kpi: \"Proposal Success Rate\",\n      details: \"Submitting a proposal for water treatment solutions\",\n      subSteps: [\"Proposal Created\", \"Proposal Submitted\"],\n      errorSteps: [\"Proposal Rejected\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProposalType: [\"Standard\", \"Custom\"]\n      }\n    },\n    {\n      stepName: \"Implementation\",\n      kpi: \"Implementation Success Rate\",\n      details: \"Implementing the water treatment solution\",\n      subSteps: [\"Implementation Scheduled\", \"Implementation Completed\"],\n      errorSteps: [\"Implementation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ImplementationMethod: [\"In-House\", \"Contracted\"]\n      }\n    },\n    {\n      stepName: \"System Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the implemented water treatment system\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestingType: [\"Performance\", \"Safety\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on the water treatment solution\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 8
      },
      "conditions": {
        "states": {
          "spa_appointment_booking": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "spa_appointment_booking"
      ]
    },
    "broadband_customer_support": {
      "name": "broadband_customer_support",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Broadband Customer Support\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about broadband services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Plan Details\", \"Technical Support\", \"Billing\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a broadband plan or service\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PlanType: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Broadband service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Store\", \"Technician Visit\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the broadband service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Browsing\", \"Streaming\", \"Gaming\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the broadband service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 7
      },
      "conditions": {
        "states": {
          "telecommunication_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "telecommunication_services"
      ]
    },
    "healthcare_patient_journey": {
      "name": "healthcare_patient_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Healthcare Patient Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Appointment Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Patient books an appointment\", \n      subSteps: [\"Appointment Created\", \"Confirmation Sent\"], \n      errorSteps: [\"Booking Failed\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BookingMethod: [\"Phone\", \"Online\", \"In-Person\"],\n        AppointmentType: [\"GP Visit\", \"Specialist\", \"Diagnostic Test\"]\n      },\n    },\n    { \n      stepName: \"Consultation\", \n      kpi: \"Consultation Completion Rate\", \n      details: \"Patient attends consultation\", \n      subSteps: [\"Check-In\", \"Consultation Started\"],\n      errorSteps: [\"No-Show\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ConsultationMethod: [\"In-Person\", \"Telemedicine\"],\n        PhysicianType: [\"GP\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Diagnostic Testing\", \n      kpi: \"Testing Success Rate\", \n      details: \"Patient undergoes diagnostic tests\", \n      subSteps: [\"Test Scheduled\", \"Test Completed\"],  \n      errorSteps: [\"Test Cancelled\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TestType: [\"Blood Test\", \"X-Ray\", \"MRI\"],\n        Facility: [\"Hospital\", \"Clinic\"]\n      },\n    },\n    { \n      stepName: \"Treatment Plan Creation\", \n      kpi: \"Treatment Plan Completion Rate\", \n      details: \"Treatment plan is created based on diagnosis\", \n      subSteps: [\"Diagnosis Complete\", \"Plan Created\"],  \n      errorSteps: [\"Treatment Plan Delayed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TreatmentType: [\"Medication\", \"Surgery\", \"Therapy\"],\n        PlanApprovalMethod: [\"Doctor\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Follow-Up Appointment\", \n      kpi: \"Follow-Up Appointment Rate\", \n      details: \"Follow-up appointment is scheduled\", \n      subSteps: [\"Follow-Up Scheduled\", \"Appointment Confirmed\"],  \n      errorSteps: [\"Appointment Not Scheduled\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FollowUpType: [\"Routine Check\", \"Diagnostic Follow-Up\"],\n        BookingChannel: [\"Phone\", \"Online\"]\n      },\n    },\n    { \n      stepName: \"Billing & Insurance\", \n      kpi: \"Billing Success Rate\", \n      details: \"Patient billing and insurance claims are processed\", \n      subSteps: [\"Bill Generated\", \"Claim Submitted\"],  \n      errorSteps: [\"Billing Error\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Insurance\", \"Self-Pay\"],\n        Currency: [\"GBP\", \"USD\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "home_security_installation": {
      "name": "home_security_installation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Home Security Installation\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about home security installation\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"CCTV\", \"Alarm System\", \"Smart Locks\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects home security services\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServicePackage: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Installation\",\n      kpi: \"Installation Success Rate\",\n      details: \"Home security devices are installed\",\n      subSteps: [\"Installation Scheduled\", \"Installation Completed\"],\n      errorSteps: [\"Installation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InstallationMethod: [\"Professional\", \"Self-Install\"]\n      }\n    },\n    {\n      stepName: \"Service Configuration\",\n      kpi: \"Configuration Success Rate\",\n      details: \"Home security devices are configured and tested\",\n      subSteps: [\"Configuration Initiated\", \"Configuration Completed\"],\n      errorSteps: [\"Configuration Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeviceType: [\"CCTV\", \"Alarm System\", \"Smart Locks\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the home security installation service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 10
      },
      "conditions": {
        "states": {
          "smart_home_setup": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "smart_home_setup"
      ]
    },
    "renewable_energy_solutions": {
      "name": "renewable_energy_solutions",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Renewable Energy Solutions\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Project Proposal\",\n      kpi: \"Proposal Success Rate\",\n      details: \"Developing and submitting a project proposal for renewable energy solutions\",\n      subSteps: [\"Proposal Initiated\", \"Proposal Submitted\"],\n      errorSteps: [\"Proposal Rejected\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProposalType: [\"Solar\", \"Wind\", \"Hydro\", \"Biomass\"],\n        SubmissionMethod: [\"Online\", \"In-Person\"]\n      }\n    },\n    {\n      stepName: \"Feasibility Study\",\n      kpi: \"Study Success Rate\",\n      details: \"Conducting a feasibility study for the proposed renewable energy project\",\n      subSteps: [\"Study Initiated\", \"Study Completed\"],\n      errorSteps: [\"Study Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        StudyType: [\"Technical\", \"Financial\", \"Environmental\"]\n      }\n    },\n    {\n      stepName: \"Funding\",\n      kpi: \"Funding Success Rate\",\n      details: \"Securing funding for the renewable energy project\",\n      subSteps: [\"Funding Application Submitted\", \"Funding Approved\"],\n      errorSteps: [\"Funding Denied\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FundingSource: [\"Government Grants\", \"Private Investment\", \"Crowdfunding\"]\n      }\n    },\n    {\n      stepName: \"Project Implementation\",\n      kpi: \"Implementation Success Rate\",\n      details: \"Implementing the renewable energy project\",\n      subSteps: [\"Implementation Initiated\", \"Implementation Completed\"],\n      errorSteps: [\"Implementation Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ImplementationMethod: [\"In-House\", \"Contracted\"]\n      }\n    },\n    {\n      stepName: \"Monitoring & Evaluation\",\n      kpi: \"Evaluation Success Rate\",\n      details: \"Monitoring and evaluating the performance of the renewable energy project\",\n      subSteps: [\"Monitoring Started\", \"Evaluation Completed\"],\n      errorSteps: [\"Evaluation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringTools: [\"SCADA\", \"IoT Sensors\", \"Drones\"],\n        EvaluationType: [\"Technical\", \"Financial\", \"Environmental\"]\n      }\n    },\n    {\n      stepName: \"Project Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Reporting on the outcomes and impact of the renewable energy project\",\n      subSteps: [\"Report Generated\", \"Report Submitted\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Technical Report\", \"Financial Report\", \"Environmental Report\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 8
      },
      "conditions": {
        "states": {
          "telemedicine_consultation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "telemedicine_consultation"
      ]
    },
    "telecommunication_services": {
      "name": "telecommunication_services",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Telecommunication Services\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about telecommunication services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Mobile Plans\", \"Internet Plans\", \"Bundle Deals\"]\n      }\n    },\n    {\n      stepName: \"Service Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects telecommunication services\",\n      subSteps: [\"Selection Initiated\", \"Selection Completed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServicePackage: [\"Basic\", \"Standard\", \"Premium\"]\n      }\n    },\n    {\n      stepName: \"Personal Information\",\n      kpi: \"Information Submission Success Rate\",\n      details: \"Customer submits personal information\",\n      subSteps: [\"Information Provided\", \"Information Verified\"],\n      errorSteps: [\"Submission Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InformationType: [\"Name\", \"Email\", \"Phone Number\", \"Address\"]\n      }\n    },\n    {\n      stepName: \"Service Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Telecommunication service is activated\",\n      subSteps: [\"Activation Requested\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Online\", \"In-Store\", \"Customer Support\"]\n      }\n    },\n    {\n      stepName: \"Service Usage\",\n      kpi: \"Usage Success Rate\",\n      details: \"Customer uses the telecommunication service\",\n      subSteps: [\"Usage Initiated\", \"Usage Ongoing\"],\n      errorSteps: [\"Service Disruption\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        UsageType: [\"Voice Call\", \"Data\", \"SMS\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on the telecommunication service\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 6
      },
      "conditions": {
        "states": {
          "mobile_app_development": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "mobile_app_development"
      ]
    },
    "theme_park_visitor_journey": {
      "name": "theme_park_visitor_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Theme Park Visitor Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Ticket Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor purchases theme park tickets online or at the gate\", \n      subSteps: [\"Ticket Selected\", \"Payment Processed\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TicketType: [\"Single-Day\", \"Multi-Day\", \"Season Pass\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Gift Card\"]\n      },\n    },\n    { \n      stepName: \"Park Entry\", \n      kpi: \"Entry Success Rate\", \n      details: \"Visitor enters the park using a valid ticket\", \n      subSteps: [\"Ticket Scanned\", \"Entry Granted\"], \n      errorSteps: [\"Ticket Not Valid\"], \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EntryMethod: [\"Main Gate\", \"Fast Pass Entry\"],\n        TicketType: [\"Regular\", \"VIP\"]\n      },\n    },\n    { \n      stepName: \"Ride Selection\", \n      kpi: \"Ride Selection Success Rate\", \n      details: \"Visitor selects a ride to experience\", \n      subSteps: [\"Ride Selected\", \"Queue Joined\"],  \n      errorSteps: [\"Ride Closed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        RideType: [\"Roller Coaster\", \"Water Ride\", \"Family Ride\"],\n        WaitTime: [\"Less than 30 min\", \"30-60 min\", \"More than 60 min\"]\n      },\n    },\n    { \n      stepName: \"Food & Beverage Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor purchases food and beverages at the park\", \n      subSteps: [\"Order Placed\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FoodType: [\"Fast Food\", \"Snack\", \"Beverage\"],\n        PaymentMethod: [\"Credit Card\", \"Mobile Payment\", \"Cash\"]\n      },\n    },\n    { \n      stepName: \"Souvenir Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor buys souvenirs from park stores\", \n      subSteps: [\"Item Selected\", \"Payment Processed\"],  \n      errorSteps: [\"Item Not Available\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SouvenirType: [\"Plush Toy\", \"T-Shirt\", \"Keychain\"],\n        PaymentMethod: [\"Credit Card\", \"Gift Card\", \"Mobile Payment\"]\n      },\n    },\n    { \n      stepName: \"Exit & Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Visitor exits the park and provides feedback on their experience\", \n      subSteps: [\"Exit Completed\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ExitMethod: [\"Main Gate\", \"VIP Exit\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 4
      },
      "conditions": {
        "states": {
          "claims_processing_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "claims_processing_journey"
      ]
    },
    "virtual_reality_experience": {
      "name": "virtual_reality_experience",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Virtual Reality Experience\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Experience Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about available VR experiences\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Gaming\", \"Educational\", \"Entertainment\", \"Fitness\"]\n      }\n    },\n    {\n      stepName: \"VR Setup\",\n      kpi: \"Setup Success Rate\",\n      details: \"Setting up VR equipment for the experience\",\n      subSteps: [\"Setup Initiated\", \"Setup Completed\"],\n      errorSteps: [\"Setup Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        EquipmentType: [\"Headset\", \"Controllers\", \"Sensors\"]\n      }\n    },\n    {\n      stepName: \"Experience Selection\",\n      kpi: \"Selection Success Rate\",\n      details: \"Customer selects a specific VR experience\",\n      subSteps: [\"Selection Initiated\", \"Selection Confirmed\"],\n      errorSteps: [\"Selection Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExperienceType: [\"Single Player\", \"Multiplayer\", \"Co-Op\"]\n      }\n    },\n    {\n      stepName: \"Experience Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Customer engages in the selected VR experience\",\n      subSteps: [\"Execution Initiated\", \"Experience Ongoing\"],\n      errorSteps: [\"Execution Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExecutionType: [\"Immersive\", \"Interactive\", \"Passive\"]\n      }\n    },\n    {\n      stepName: \"Experience Completion\",\n      kpi: \"Completion Success Rate\",\n      details: \"Customer completes the VR experience\",\n      subSteps: [\"Completion Started\", \"Completion Confirmed\"],\n      errorSteps: [\"Completion Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CompletionType: [\"Positive\", \"Neutral\", \"Negative\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on their VR experience\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 1
      },
      "description": "Run custom JavaScript code.",
      "predecessors": []
    },
    "ai_personal_assistant_setup": {
      "name": "ai_personal_assistant_setup",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - AI Personal Assistant Setup\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about AI personal assistant options\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Home Assistant\", \"Work Assistant\", \"Hybrid\"]\n      }\n    },\n    {\n      stepName: \"Assistant Configuration\",\n      kpi: \"Configuration Success Rate\",\n      details: \"Configuring the AI personal assistant settings\",\n      subSteps: [\"Configuration Initiated\", \"Configuration Completed\"],\n      errorSteps: [\"Configuration Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ConfigurationType: [\"Basic Setup\", \"Advanced Customization\"]\n      }\n    },\n    {\n      stepName: \"Integration with Devices\",\n      kpi: \"Integration Success Rate\",\n      details: \"Integrating the AI assistant with various devices\",\n      subSteps: [\"Integration Started\", \"Integration Completed\"],\n      errorSteps: [\"Integration Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeviceType: [\"Smartphone\", \"Smart Home Devices\", \"Wearable Devices\"]\n      }\n    },\n    {\n      stepName: \"Training and Personalization\",\n      kpi: \"Training Success Rate\",\n      details: \"Training the AI assistant to understand user preferences\",\n      subSteps: [\"Training Initiated\", \"Training Completed\"],\n      errorSteps: [\"Training Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PersonalizationType: [\"Voice Recognition\", \"Routine Learning\"]\n      }\n    },\n    {\n      stepName: \"Assistant Activation\",\n      kpi: \"Activation Success Rate\",\n      details: \"Activating the AI personal assistant\",\n      subSteps: [\"Activation Initiated\", \"Activation Completed\"],\n      errorSteps: [\"Activation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ActivationMethod: [\"Voice Command\", \"App Setup\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from users on the AI personal assistant\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 5
      },
      "conditions": {
        "states": {
          "cryptocurrency_mining": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "cryptocurrency_mining"
      ]
    },
    "automobile_order_production": {
      "name": "automobile_order_production",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Automobile Order Production\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Order\", \n      kpi: \"Order Evaluation Success Rate\", \n      details: \"Customer places an order and it's evaluated for acceptance\", \n      subSteps: [\"Order Placed\", \"Order Confirmed\"],\n      errorSteps: [\"Order Denied\"], \n      errorProbability: 0.02, \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OrderOrigin: [\"Website\", \"Retailer\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\"],\n        Region: [\"North America\", \"Europe\"]\n      },\n    },\n    { \n      stepName: \"Production Planning\", \n      kpi: \"Car Production Success\", \n      details: \"Production of the car begins\", \n      subSteps: [\"Capacity Checked\", \"Capacity Available\", \"Production Scheduled\"],\n      errorSteps: [\"No Capacity Available\", \"Production Delay\"],\n      errorProbability: 0.05, \n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 3 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Production\", \n      kpi: \"Car Production Success\", \n      details: \"Car production in progress\", \n      subSteps: [\"Production Started\", \"In Production\", \"End of Production\"],\n      errorSteps: [\"Delay In Production\"],\n      errorProbability: 0.05, \n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 3 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Shipping\", \n      kpi: \"Shipping Success\", \n      details: \"Car shipping from plant to dealership\", \n      subSteps: [\"Ready for Shipping\", \"In Shipping\", \"Delivered\"], \n      errorSteps: [\"Delay in Shipping\"], \n      errorProbability: 0.03, \n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 5 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Handover\", \n      kpi: \"Handover Success\", \n      details: \"Car handed over to the customer\", \n      subSteps: [\"Handover Scheduled\", \"Handed Over\"],  \n      errorProbability: 0.0, \n      injectionMethod: \"Logs\", \n      stepTimeIncrement: 1 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Finance Workflow\", \n      kpi: \"Finance Workflow Completion\", \n      details: \"Final payment and record update\", \n      subSteps: [\"Invoice Process Initiation\", \"Generate Invoice\", \"Review Invoice Data\", \"Verify Order Details\", \"Approve Invoice\", \"Send Invoice\", \"Receive Final Payment\", \"Update Accounting Records\"],  \n      errorProbability: 0.0, \n      includeTotal: true,\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "banking_-_wealth_management": {
      "name": "banking_-_wealth_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Banking Wealth Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Client Onboarding\",\n      kpi: \"Onboarding Success Rate\",\n      details: \"Client onboarding and profile creation\",\n      subSteps: [\"Onboarding Initiated\", \"Profile Created\"],\n      errorSteps: [\"Onboarding Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        OnboardingChannel: [\"In-Person\", \"Online\", \"Mobile App\"]\n      }\n    },\n    {\n      stepName: \"Financial Planning\",\n      kpi: \"Planning Success Rate\",\n      details: \"Creating a personalized financial plan\",\n      subSteps: [\"Plan Initiation\", \"Plan Approval\"],\n      errorSteps: [\"Planning Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PlanType: [\"Retirement\", \"Investment\", \"Tax Planning\"]\n      }\n    },\n    {\n      stepName: \"Investment Management\",\n      kpi: \"Investment Success Rate\",\n      details: \"Managing client investments\",\n      subSteps: [\"Investment Strategy Developed\", \"Investment Executed\"],\n      errorSteps: [\"Investment Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AssetClass: [\"Equities\", \"Bonds\", \"Real Estate\", \"Mutual Funds\"]\n      }\n    },\n    {\n      stepName: \"Performance Monitoring\",\n      kpi: \"Monitoring Success Rate\",\n      details: \"Monitoring investment performance\",\n      subSteps: [\"Performance Review Scheduled\", \"Performance Review Completed\"],\n      errorSteps: [\"Monitoring Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringFrequency: [\"Monthly\", \"Quarterly\", \"Annually\"]\n      }\n    },\n    {\n      stepName: \"Client Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Providing clients with regular reports\",\n      subSteps: [\"Report Generated\", \"Report Delivered\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 0.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Performance Report\", \"Tax Report\", \"Account Statement\"]\n      }\n    },\n    {\n      stepName: \"Client Feedback\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting client feedback on wealth management services\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"Phone\", \"In-Person\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -4,
        "y": 8
      },
      "conditions": {
        "states": {
          "broadband_customer_support": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "broadband_customer_support"
      ]
    },
    "banking_new_account_opening": {
      "name": "banking_new_account_opening",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Banking New Account Opening\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Account Selection\", \n      kpi: \"Account Selection Success Rate\", \n      details: \"Customer selects the type of account to open\", \n      subSteps: [\"Product Browsed\", \"Account Type Selected\"], \n      errorSteps: [\"Selection Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AccountType: [\"Savings\", \"Current\", \"ISA\"],\n        SelectionChannel: [\"Branch\", \"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an application for a new account\", \n      subSteps: [\"Form Filled\", \"Application Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Verification Success Rate\", \n      details: \"Customer undergoes identity verification\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],  \n      errorSteps: [\"Verification Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        IDType: [\"Passport\", \"Driver's License\"],\n        VerificationMethod: [\"Online\", \"In-Person\"]\n      },\n    },\n    { \n      stepName: \"Account Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Bank approves or rejects the account application\", \n      subSteps: [\"Application Reviewed\", \"Approval Decision\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApprovalMethod: [\"Automated\", \"Manual\"],\n        AccountLimit: [\"10,000\", \"50,000\", \"100,000+\"]\n      },\n    },\n    { \n      stepName: \"Account Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer's new account is activated\", \n      subSteps: [\"Activation Requested\", \"Account Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Branch\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Customer Onboarding\", \n      kpi: \"Onboarding Completion Rate\", \n      details: \"Customer completes the onboarding process for their new account\", \n      subSteps: [\"Welcome Email Sent\", \"Onboarding Completed\"],  \n      errorSteps: [\"Onboarding Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OnboardingChannel: [\"Mobile App\", \"Branch\"],\n        SupportRequested: [\"Yes\", \"No\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 2
      },
      "conditions": {
        "states": {
          "insurance_and_risk_management": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "insurance_and_risk_management"
      ]
    },
    "patient_appointment_journey": {
      "name": "patient_appointment_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Patient Appointment Journey\", \n  numberOfCustomers: 150, \n  steps: [\n    { \n      stepName: \"Appointment Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Patient books a medical appointment\", \n      subSteps: [\"Booking Initiated\", \"Appointment Confirmed\"], \n      errorSteps: [\"Booking Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BookingMethod: [\"Online\", \"Phone\", \"In-Person\"],\n        AppointmentType: [\"GP\", \"Specialist\", \"Dentist\"]\n      },\n    },\n    { \n      stepName: \"Appointment Reminder\", \n      kpi: \"Reminder Sent Rate\", \n      details: \"Patient receives an appointment reminder\", \n      subSteps: [\"Reminder Sent\", \"Reminder Confirmed\"], \n      errorSteps: [\"Reminder Not Received\"], \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReminderMethod: [\"SMS\", \"Email\", \"Phone Call\"],\n        ReminderChannel: [\"Automated\", \"Manual\"]\n      },\n    },\n    { \n      stepName: \"Appointment Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Patient checks in for their appointment\", \n      subSteps: [\"Check-In Started\", \"Check-In Completed\"],  \n      errorSteps: [\"Check-In Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CheckInMethod: [\"Kiosk\", \"Receptionist\", \"Mobile\"],\n        ArrivalTime: [\"On-Time\", \"Late\"]\n      },\n    },\n    { \n      stepName: \"Consultation\", \n      kpi: \"Consultation Success Rate\", \n      details: \"Patient attends their consultation with the healthcare provider\", \n      subSteps: [\"Consultation Started\", \"Consultation Completed\"],  \n      errorSteps: [\"Consultation Delayed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ConsultationType: [\"In-Person\", \"Telehealth\"],\n        ProviderType: [\"GP\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Treatment & Prescription\", \n      kpi: \"Treatment Completion Rate\", \n      details: \"Patient receives treatment or prescription after consultation\", \n      subSteps: [\"Treatment Provided\", \"Prescription Issued\"],  \n      errorSteps: [\"Prescription Not Available\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PrescriptionType: [\"E-Prescription\", \"Paper Prescription\"],\n        TreatmentLocation: [\"Clinic\", \"Pharmacy\"]\n      },\n    },\n    { \n      stepName: \"Follow-Up Appointment\", \n      kpi: \"Follow-Up Booking Rate\", \n      details: \"Patient schedules a follow-up appointment\", \n      subSteps: [\"Follow-Up Suggested\", \"Follow-Up Scheduled\"],  \n      errorSteps: [\"Follow-Up Missed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FollowUpMethod: [\"In-Person\", \"Telehealth\"],\n        BookingChannel: [\"Online\", \"Phone\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 3
      },
      "conditions": {
        "states": {
          "university_admissions": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "university_admissions"
      ]
    },
    "tourism_guided_tour_booking": {
      "name": "tourism_guided_tour_booking",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Tourism Guided Tour Booking\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Tour Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available guided tours\", \n      subSteps: [\"Tour Browsed\", \"Tour Selected\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TourType: [\"Cultural\", \"Adventure\", \"Historical\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Booking Confirmation\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer books a guided tour\", \n      subSteps: [\"Booking Confirmed\", \"Payment Made\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        TourDuration: [\"Half-Day\", \"Full-Day\", \"Multi-Day\"]\n      },\n    },\n    { \n      stepName: \"Tour Guide Assignment\", \n      kpi: \"Assignment Success Rate\", \n      details: \"Tour guide is assigned to the tour\", \n      subSteps: [\"Guide Assigned\", \"Confirmation Sent\"],  \n      errorSteps: [\"Assignment Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        GuideExperience: [\"Novice\", \"Experienced\", \"Expert\"],\n        Language: [\"English\", \"Spanish\", \"French\"]\n      },\n    },\n    { \n      stepName: \"Tour Day\", \n      kpi: \"Tour Success Rate\", \n      details: \"Customer attends the guided tour\", \n      subSteps: [\"Tour Started\", \"Tour Completed\"],  \n      errorSteps: [\"Tour Canceled\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        Weather: [\"Sunny\", \"Rainy\", \"Cloudy\"],\n        GroupSize: [\"Small\", \"Medium\", \"Large\"]\n      },\n    },\n    { \n      stepName: \"Post-Tour Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their guided tour\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Mobile App\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 5
      },
      "conditions": {
        "states": {
          "retail_in-store_purchase_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "retail_in-store_purchase_journey"
      ]
    },
    "broadband_service_activation": {
      "name": "broadband_service_activation",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Broadband Service Activation\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Customer selects a broadband or mobile service plan\", \n      subSteps: [\"Plan Selected\", \"Proceed to Checkout\"], \n      errorSteps: [\"Selection Abandoned\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlanType: [\"Broadband\", \"Mobile\", \"TV Bundle\"],\n        DeviceType: [\"Mobile\", \"Desktop\"]\n      },\n    },\n    { \n      stepName: \"Contract Signing\", \n      kpi: \"Contract Signing Success Rate\", \n      details: \"Customer signs the service contract\", \n      subSteps: [\"Contract Viewed\", \"Contract Signed\"], \n      errorSteps: [\"Contract Not Signed\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SigningMethod: [\"Online\", \"In-Person\"],\n        ContractLength: [\"12 Months\", \"24 Months\", \"No Contract\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Identity Verification Success Rate\", \n      details: \"Customer's identity is verified for service activation\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],\n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        VerificationMethod: [\"Online\", \"In-Person\"],\n        IDType: [\"Passport\", \"Drivers License\"]\n      },\n    },\n    { \n      stepName: \"Equipment Shipment\", \n      kpi: \"Shipment Success Rate\", \n      details: \"Equipment is shipped to the customer\", \n      subSteps: [\"Order Shipped\", \"Delivered\"],  \n      errorSteps: [\"Shipment Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ShippingProvider: [\"Royal Mail\", \"DHL\", \"UPS\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Service is activated for the customer\", \n      subSteps: [\"Activation Started\", \"Activation Completed\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ActivationMethod: [\"Self-Install\", \"Technician Install\"],\n        ServiceType: [\"Broadband\", \"Mobile\", \"TV\"]\n      },\n    },\n    { \n      stepName: \"Onboarding & Support\", \n      kpi: \"Onboarding Success Rate\", \n      details: \"Customer completes the onboarding process\", \n      subSteps: [\"Onboarding Completed\", \"Support Contacted\"],  \n      errorSteps: [\"Onboarding Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SupportMethod: [\"Phone\", \"Email\", \"Chat\"],\n        OnboardingChannel: [\"Mobile\", \"Desktop\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 2
      },
      "conditions": {
        "states": {
          "healthcare_patient_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "healthcare_patient_journey"
      ]
    },
    "hospitality_guest_experience": {
      "name": "hospitality_guest_experience",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Hospitality Guest Experience\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Booking\",\n      kpi: \"Booking Success Rate\",\n      details: \"Customer makes a hotel booking\",\n      subSteps: [\"Booking Initiated\", \"Booking Confirmed\"],\n      errorSteps: [\"Booking Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RoomType: [\"Single\", \"Double\", \"Suite\"],\n        BookingChannel: [\"Online\", \"Phone\", \"Walk-in\"]\n      }\n    },\n    {\n      stepName: \"Check-In\",\n      kpi: \"Check-In Success Rate\",\n      details: \"Customer checks into the hotel\",\n      subSteps: [\"Check-In Initiated\", \"Check-In Completed\"],\n      errorSteps: [\"Check-In Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CheckInMethod: [\"Online\", \"Front Desk\"]\n      }\n    },\n    {\n      stepName: \"Stay\",\n      kpi: \"Guest Satisfaction Rate\",\n      details: \"Guest enjoys their stay\",\n      subSteps: [\"Stay in Progress\"],\n      errorSteps: [\"Complaint Logged\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ServiceRequested: [\"Room Service\", \"Housekeeping\", \"Concierge\"]\n      }\n    },\n    {\n      stepName: \"Amenities Usage\",\n      kpi: \"Amenities Usage Rate\",\n      details: \"Guest uses hotel amenities\",\n      subSteps: [\"Amenities Accessed\"],\n      errorSteps: [\"Amenities Not Available\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AmenityType: [\"Pool\", \"Gym\", \"Spa\"]\n      }\n    },\n    {\n      stepName: \"Check-Out\",\n      kpi: \"Check-Out Success Rate\",\n      details: \"Customer checks out of the hotel\",\n      subSteps: [\"Check-Out Initiated\", \"Check-Out Completed\"],\n      errorSteps: [\"Check-Out Failed\"],\n      errorProbability: 0.02,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CheckOutMethod: [\"Online\", \"Front Desk\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Customer provides feedback on their stay\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"SMS\", \"App\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 6
      },
      "conditions": {
        "states": {
          "financial_services_fraud_detection": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "financial_services_fraud_detection"
      ]
    },
    "mortgage_application_process": {
      "name": "mortgage_application_process",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section (Mortgage Journey)\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mortgage Application Process\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Application Submission Success Rate\", \n      details: \"Customer submits a mortgage application\", \n      subSteps: [\"Application Received\", \"Application Submitted\", \"Initial Review Started\"],\n      errorSteps: [\"Application Rejected\"], \n      errorProbability: 0.02,  // 2% chance of rejection\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000,  // 1 hour between steps\n      subStepTimeIncrement: 15 * 60 * 1000,  // 15 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\", \"By Agent\"],\n        EmploymentStatus: [\"Employed\", \"Self-Employed\", \"Retired\"],\n        IncomeVerificationMethod: [\"Pay Stubs\", \"Bank Statements\", \"Tax Returns\"],\n        ApplicationSource: [\"Mobile\", \"Desktop\", \"Branch Office\"]\n      },\n    },\n    { \n      stepName: \"Credit Check & Approval\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Credit check and initial approval\", \n      subSteps: [\"Credit Check Initiated\", \"Credit Score Verified\", \"Pre-Approval Decision\"],\n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.10,  // 10% chance of failure at this stage\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000,  // 2 hours between steps\n      subStepTimeIncrement: 30 * 60 * 1000,  // 30 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n       AdditionalFields: { \n        CreditReferenceAgency: [\"Experian\", \"Equifax\", \"TransUnions\"],\n        MortgageTerm: [\"15 Years\", \"30 Years\"],\n        CreditScoreRange: [\"300-500\", \"500-650\", \"650-750\", \"750-850\"]\n      },\n    },\n    { \n      stepName: \"Underwriting\", \n      kpi: \"Underwriting Approval Rate\", \n      details: \"Loan application is underwritten\", \n      subSteps: [\"Underwriting Started\", \"Document Review\", \"Risk Assessment\", \"Underwriting Completed\"],\n      errorSteps: [\"Application Declined by Underwriting\", \"Additional Documentation Required\"],\n      errorProbability: 0.05,  // 5% chance of underwriting failure\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 4 * 60 * 60 * 1000,  // 4 hours between steps\n      subStepTimeIncrement: 45 * 60 * 1000,  // 45 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n       AdditionalFields: { \n        RiskCategory: [\"Low Risk\", \"Moderate Risk\", \"High Risk\"],\n        DocumentTypeRequested: [\"Income Verification\", \"Asset Verification\", \"Property Valuation\"],\n        UnderwriterType: [\"Automated\", \"Manual\"],\n        UnderwriterDecision: [\"Approved\", \"Declined\", \"Conditional Approval\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"],\n        LoanToValueRatio: [\"<80%\", \"80-90%\", \">90%\"]      \n       },\n    },\n    { \n      stepName: \"Appraisal\", \n      kpi: \"Appraisal Completion Rate\", \n      details: \"Property appraisal process\", \n      subSteps: [\"Appraisal Ordered\", \"Appraisal Scheduled\", \"Appraisal Completed\"],\n      errorSteps: [\"Appraisal Delayed\", \"Property Value Too Low\"], \n      errorProbability: 0.08,  // 8% chance of issues during appraisal\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 8 * 60 * 60 * 1000,  // 8 hours between steps\n      subStepTimeIncrement: 60 * 60 * 1000,  // 1 hour between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AppraisalProvider: [\"Internal\", \"Third-Party\"],\n        AppraisedValue: [\"<Market Value\", \"At Market Value\", \"Above Market Value\"],\n        AppraisalMethod: [\"In-Person\", \"Automated Valuation Model (AVM)\"],\n        PropertyCondition: [\"Good\", \"Fair\", \"Poor\"],\n        PropertyLocationRisk: [\"Low\", \"Medium\", \"High\"]\n      },\n    },\n    { \n      stepName: \"Final Approval\", \n      kpi: \"Final Loan Approval Rate\", \n      details: \"Final loan approval process\", \n      subSteps: [\"Final Review\", \"Conditions Cleared\", \"Final Approval Granted\"],  \n      errorSteps: [\"Conditions Not Met\", \"Approval Delayed\"],  \n      errorProbability: 0.03,  // 3% chance of delay\n      injectionMethod: \"Logs\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000,  // 2 hours between steps\n      subStepTimeIncrement: 30 * 60 * 1000,  // 30 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ApprovalStatus: [\"Fully Approved\", \"Conditional Approval\", \"Declined\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"],\n        ClosingDateConfirmed: [\"Yes\", \"No\"],\n        FundingSource: [\"Bank\", \"Credit Union\", \"Private Lender\"],\n        InterestRateLockStatus: [\"Locked\", \"Floating\"]\n      }\n    },\n    { \n      stepName: \"Closing\", \n      kpi: \"Loan Closing Completion Rate\", \n      details: \"Loan closing process\", \n      subSteps: [\"Closing Documents Sent\", \"Documents Signed\", \"Loan Funded\", \"Keys Handed Over\"],\n      errorSteps: [\"Closing Delayed\"],  \n      errorProbability: 0.02,  // 2% chance of closing delay\n      includeTotal: true,\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 6 * 60 * 60 * 1000,  // 6 hours between steps\n      subStepTimeIncrement: 60 * 60 * 1000,  // 1 hour between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AddionalFields: {\n        ClosingAttorneyPresent: [\"Yes\", \"No\"],\n        ClosingMethod: [\"In-Person\", \"Remote/Virtual\", \"Hybrid\"],\n        LoanAmount: [\"$100,000-$200,000\", \"$200,000-$400,000\", \"$400,000-$600,000\"],\n        DocumentSignatureStatus: [\"Signed\", \"Pending\"],\n        FundsDisbursed: [\"Yes\", \"No\"],\n        TitleInsurancePurchased: [\"Yes\", \"No\"],\n        KeysHandedOver: [\"Yes\", \"No\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions and Core Workflow\n// -----------------------------\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "passport_application_journey": {
      "name": "passport_application_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Passport Application Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Citizen submits a passport application\", \n      subSteps: [\"Application Form Submitted\", \"Payment Made\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApplicationMethod: [\"Online\", \"Postal\", \"In-Person\"],\n        PassportType: [\"Standard\", \"Urgent\", \"Child\"]\n      },\n    },\n    { \n      stepName: \"Document Verification\", \n      kpi: \"Verification Success Rate\", \n      details: \"Documents are verified for the passport application\", \n      subSteps: [\"Documents Submitted\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        IDType: [\"Passport\", \"Driver's License\", \"Utility Bill\"],\n        VerificationMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Application Review\", \n      kpi: \"Review Completion Rate\", \n      details: \"Government reviews the passport application\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 48 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReviewType: [\"Manual\", \"Automated\"],\n        ReviewPriority: [\"Standard\", \"Expedited\"]\n      },\n    },\n    { \n      stepName: \"Passport Printing\", \n      kpi: \"Printing Success Rate\", \n      details: \"Passport is printed after approval\", \n      subSteps: [\"Printing Requested\", \"Passport Printed\"],  \n      errorSteps: [\"Printing Delayed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PrintingMethod: [\"In-House\", \"Outsourced\"],\n        PrintingLocation: [\"London\", \"Edinburgh\"]\n      },\n    },\n    { \n      stepName: \"Delivery & Dispatch\", \n      kpi: \"Dispatch Success Rate\", \n      details: \"Passport is dispatched to the applicant\", \n      subSteps: [\"Dispatch Scheduled\", \"Passport Delivered\"],  \n      errorSteps: [\"Delivery Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DeliveryMethod: [\"Courier\", \"Royal Mail\"],\n        DeliveryWindow: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Feedback Submission\", \n      kpi: \"Feedback Rate\", \n      details: \"Citizen provides feedback on the passport application process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -1,
        "y": 4
      },
      "conditions": {
        "states": {
          "online_shopping_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "online_shopping_journey"
      ]
    },
    "pharmaceutical_manufacturing": {
      "name": "pharmaceutical_manufacturing",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Pharmaceutical Manufacturing\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Raw Material Procurement\",\n      kpi: \"Procurement Success Rate\",\n      details: \"Sourcing and receiving raw materials\",\n      subSteps: [\"Order Placed\", \"Materials Received\"],\n      errorSteps: [\"Procurement Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Supplier: [\"Supplier A\", \"Supplier B\", \"Supplier C\"]\n      }\n    },\n    {\n      stepName: \"Material Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Quality control testing of raw materials\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestType: [\"Chemical Analysis\", \"Microbial Analysis\", \"Physical Analysis\"]\n      }\n    },\n    {\n      stepName: \"Drug Formulation\",\n      kpi: \"Formulation Success Rate\",\n      details: \"Formulating the drug product\",\n      subSteps: [\"Formulation Initiated\", \"Formulation Completed\"],\n      errorSteps: [\"Formulation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DosageForm: [\"Tablet\", \"Capsule\", \"Liquid\"]\n      }\n    },\n    {\n      stepName: \"Manufacturing\",\n      kpi: \"Manufacturing Success Rate\",\n      details: \"Manufacturing the drug product\",\n      subSteps: [\"Manufacturing Started\", \"Manufacturing Completed\"],\n      errorSteps: [\"Manufacturing Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ManufacturingLine: [\"Line 1\", \"Line 2\", \"Line 3\"]\n      }\n    },\n    {\n      stepName: \"Packaging\",\n      kpi: \"Packaging Success Rate\",\n      details: \"Packaging the final drug product\",\n      subSteps: [\"Packaging Started\", \"Packaging Completed\"],\n      errorSteps: [\"Packaging Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PackagingType: [\"Blister Pack\", \"Bottle\", \"Sachet\"]\n      }\n    },\n    {\n      stepName: \"Quality Control\",\n      kpi: \"Quality Control Success Rate\",\n      details: \"Final quality control checks\",\n      subSteps: [\"QC Started\", \"QC Completed\"],\n      errorSteps: [\"QC Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        QCMethod: [\"Visual Inspection\", \"Automated Testing\", \"Manual Testing\"]\n      }\n    },\n    {\n      stepName: \"Distribution\",\n      kpi: \"Distribution Success Rate\",\n      details: \"Distributing the drug product\",\n      subSteps: [\"Distribution Initiated\", \"Distribution Completed\"],\n      errorSteps: [\"Distribution Failed\"],\n      errorProbability: 0.02,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DistributionChannel: [\"Wholesale\", \"Retail\", \"Direct to Pharmacy\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 11
      },
      "conditions": {
        "states": {
          "home_security_installation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "home_security_installation"
      ]
    },
    "autonomous_vehicle_management": {
      "name": "autonomous_vehicle_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Autonomous Vehicle Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about autonomous vehicle management services\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Private Vehicle\", \"Fleet Management\", \"Public Transportation\"]\n      }\n    },\n    {\n      stepName: \"Vehicle Setup\",\n      kpi: \"Setup Success Rate\",\n      details: \"Setting up the autonomous vehicle system\",\n      subSteps: [\"Hardware Installation\", \"Software Configuration\"],\n      errorSteps: [\"Setup Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        SetupType: [\"New Vehicle\", \"Retrofit\"]\n      }\n    },\n    {\n      stepName: \"Route Planning\",\n      kpi: \"Planning Success Rate\",\n      details: \"Planning routes for autonomous vehicles\",\n      subSteps: [\"Route Analysis\", \"Route Confirmation\"],\n      errorSteps: [\"Planning Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RouteType: [\"Urban\", \"Suburban\", \"Rural\"]\n      }\n    },\n    {\n      stepName: \"Autonomous Driving\",\n      kpi: \"Driving Success Rate\",\n      details: \"Executing autonomous driving\",\n      subSteps: [\"Driving Initiated\", \"Driving Ongoing\"],\n      errorSteps: [\"Driving Failure\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DrivingMode: [\"Manual Override\", \"Fully Autonomous\"]\n      }\n    },\n    {\n      stepName: \"System Monitoring\",\n      kpi: \"Monitoring Success Rate\",\n      details: \"Monitoring the autonomous vehicle system\",\n      subSteps: [\"Monitoring Started\", \"Monitoring Ongoing\"],\n      errorSteps: [\"Monitoring Failure\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringMethod: [\"Real-Time\", \"Periodic\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on autonomous vehicle management\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 8
      },
      "conditions": {
        "states": {
          "veterinary_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "veterinary_services"
      ]
    },
    "drug_development_and_approval": {
      "name": "drug_development_and_approval",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Drug Development & Approval\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Research & Discovery\", \n      kpi: \"Research Success Rate\", \n      details: \"Research team identifies potential drug candidates\", \n      subSteps: [\"Research Initiated\", \"Drug Candidate Identified\"], \n      errorSteps: [\"No Viable Candidates\"], \n      errorProbability: 0.15,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 72 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ResearchMethod: [\"In-Lab\", \"In-Silico\", \"Clinical Data Mining\"],\n        DrugType: [\"Small Molecule\", \"Biologics\", \"Gene Therapy\"]\n      },\n    },\n    { \n      stepName: \"Preclinical Testing\", \n      kpi: \"Preclinical Success Rate\", \n      details: \"Drug candidate undergoes preclinical testing\", \n      subSteps: [\"Animal Testing\", \"Safety Assessment\"], \n      errorSteps: [\"Preclinical Failure\"], \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 120 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TestingMethod: [\"In-Vivo\", \"In-Vitro\"],\n        Outcome: [\"Success\", \"Failure\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 1\", \n      kpi: \"Phase 1 Success Rate\", \n      details: \"Phase 1 clinical trials are conducted to test safety\", \n      subSteps: [\"Trial Initiated\", \"Trial Completed\"],  \n      errorSteps: [\"Adverse Events\"],  \n      errorProbability: 0.12,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 240 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TrialLocation: [\"UK\", \"USA\", \"EU\"],\n        PatientGroup: [\"Healthy Volunteers\", \"Specific Condition\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 2\", \n      kpi: \"Phase 2 Success Rate\", \n      details: \"Phase 2 clinical trials are conducted to test efficacy\", \n      subSteps: [\"Patient Dosing\", \"Efficacy Measured\"],  \n      errorSteps: [\"Lack of Efficacy\"],  \n      errorProbability: 0.15,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 480 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TrialType: [\"Double-Blind\", \"Open Label\"],\n        PatientGroupSize: [\"100-500\", \"500-1000\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 3\", \n      kpi: \"Phase 3 Success Rate\", \n      details: \"Phase 3 trials confirm efficacy and monitor side effects\", \n      subSteps: [\"Dosing Completed\", \"Trial Concluded\"],  \n      errorSteps: [\"Adverse Effects\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 720 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TrialSize: [\"1000-5000\", \"5000+\"],\n        TrialRegion: [\"UK\", \"EU\", \"Asia\"]\n      },\n    },\n    { \n      stepName: \"Regulatory Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Regulatory submission to bodies such as the MHRA and EMA\", \n      subSteps: [\"Dossier Prepared\", \"Submission Filed\"],  \n      errorSteps: [\"Submission Rejected\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 180 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        RegulatoryAgency: [\"MHRA\", \"EMA\", \"FDA\"],\n        SubmissionType: [\"Standard\", \"Expedited\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 2
      },
      "conditions": {
        "states": {
          "utilities_and_energy": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "utilities_and_energy"
      ]
    },
    "insurance_and_risk_management": {
      "name": "insurance_and_risk_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Insurance Claim Processing\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Claim Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an insurance claim\", \n      subSteps: [\"Claim Form Filled\", \"Submitted\"], \n      errorSteps: [\"Form Incomplete\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ClaimType: [\"Auto\", \"Home\", \"Health\"],\n        SubmissionMethod: [\"Online\", \"Agent\"]\n      },\n    },\n    { \n      stepName: \"Claim Review\", \n      kpi: \"Claim Review Success\", \n      details: \"Claim is reviewed by the insurance company\", \n      subSteps: [\"Documents Verified\", \"Claim Assessed\"],\n      errorSteps: [\"Claim Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AdjusterType: [\"In-House\", \"Third-Party\"],\n        ClaimValue: [\"<5,000\", \"5,000-50,000\", \">50,000\"]\n      },\n    },\n    { \n      stepName: \"Claim Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Insurance company approves or denies the claim\", \n      subSteps: [\"Approval Review\", \"Decision Made\"],  \n      errorSteps: [\"Approval Denied\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApprovalStatus: [\"Approved\", \"Rejected\"],\n        PayoutMethod: [\"Direct Deposit\", \"Cheque\"]\n      },\n    },\n    { \n      stepName: \"Claim Payment\", \n      kpi: \"Payout Success Rate\", \n      details: \"Approved claim payout is processed\", \n      subSteps: [\"Payment Approved\", \"Funds Disbursed\"],  \n      errorSteps: [\"Payment Delayed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 6 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Deposit\", \"Cheque\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Customer Follow-Up\", \n      kpi: \"Follow-Up Success Rate\", \n      details: \"Customer receives follow-up after claim completion\", \n      subSteps: [\"Follow-Up Initiated\", \"Follow-Up Completed\"],  \n      errorSteps: [\"No Follow-Up\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FollowUpMethod: [\"Phone\", \"Email\"],\n        SatisfactionLevel: [\"Satisfied\", \"Neutral\", \"Unsatisfied\"]\n      },\n    },\n    { \n      stepName: \"Feedback & Survey\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after the claim is completed\", \n      subSteps: [\"Feedback Requested\", \"Survey Completed\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Phone\"],\n        FeedbackType: [\"Positive\", \"Neutral\", \"Negative\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 1
      },
      "conditions": {
        "states": {}
      },
      "description": "Build a custom task running js Code",
      "predecessors": []
    },
    "e-sports_tournament_management": {
      "name": "e-sports_tournament_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - E-Sports Tournament Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Tournament Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Teams inquire about tournament participation\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Team Participation\", \"Sponsorship\", \"Volunteering\"]\n      }\n    },\n    {\n      stepName: \"Registration\",\n      kpi: \"Registration Success Rate\",\n      details: \"Teams register for the tournament\",\n      subSteps: [\"Registration Form Submitted\", \"Registration Confirmed\"],\n      errorSteps: [\"Registration Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RegistrationType: [\"Early Bird\", \"Regular\", \"Late\"]\n      }\n    },\n    {\n      stepName: \"Match Scheduling\",\n      kpi: \"Scheduling Success Rate\",\n      details: \"Scheduling matches for the tournament\",\n      subSteps: [\"Schedule Created\", \"Schedule Finalized\"],\n      errorSteps: [\"Scheduling Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MatchType: [\"Group Stage\", \"Knockout\", \"Finals\"]\n      }\n    },\n    {\n      stepName: \"Tournament Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Executing the e-sports tournament\",\n      subSteps: [\"Tournament Started\", \"Matches Played\"],\n      errorSteps: [\"Execution Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 6 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ExecutionType: [\"Online\", \"Offline\", \"Hybrid\"]\n      }\n    },\n    {\n      stepName: \"Results Reporting\",\n      kpi: \"Reporting Success Rate\",\n      details: \"Reporting match results and tournament standings\",\n      subSteps: [\"Results Compiled\", \"Results Published\"],\n      errorSteps: [\"Reporting Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportingMethod: [\"Website\", \"Social Media\", \"Email\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from participants and attendees\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"Survey\", \"App Notification\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 4,
        "y": 9
      },
      "conditions": {
        "states": {
          "telehealth_consultation": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "telehealth_consultation"
      ]
    },
    "met_police_incident_management": {
      "name": "met_police_incident_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - UK MET Police - Incident Management\",\n  numberOfCustomers: 100, // Simulating 50 unique reporters for the incidents\n  steps: [\n    {\n      stepName: \"Incident Reporting\",\n      kpi: \"Incident Reporting Success Rate\",\n      details: \"Reporting an incident to MET Police\",\n      subSteps: [\"Report Created\", \"Report Submitted\", \"Report Acknowledged\"],\n      errorSteps: [\"Report Submission Failed\"],\n      errorProbability: 0.01,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      subStepTimeIncrement: 10 * 60 * 1000, // 10 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Theft\", \"Assault\", \"Vandalism\", \"Cyber Crime\"],\n        ReporterLocation: [\"North London\", \"South London\", \"East London\", \"West London\"],\n        PriorityLevel: [\"High\", \"Medium\", \"Low\"],\n      },\n    },\n    {\n      stepName: \"Investigation Initiation\",\n      kpi: \"Investigation Initiation Rate\",\n      details: \"MET Police begins investigating the incident\",\n      subSteps: [\"Investigation Assigned\", \"Team Mobilized\", \"Initial Assessment\"],\n      errorSteps: [\"Team Not Available\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 2 * 60 * 60 * 1000, // 2 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Investigation\",\n      kpi: \"Investigation Success Rate\",\n      details: \"Conducting a thorough investigation\",\n      subSteps: [\"Evidence Collected\", \"Interviews Conducted\", \"Preliminary Findings Reported\"],\n      errorSteps: [\"Evidence Misplaced\", \"Witness Unavailable\"],\n      errorProbability: 0.02,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 8 * 60 * 60 * 1000, // 8 hours\n      subStepTimeIncrement: 1 * 60 * 60 * 1000, // 1 hour\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Resolution\",\n      kpi: \"Resolution Success Rate\",\n      details: \"Final resolution and case closure\",\n      subSteps: [\"Resolution Proposed\", \"Case Closed\"],\n      errorSteps: [\"Resolution Delayed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      stepTimeIncrement: 4 * 60 * 60 * 1000, // 4 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Follow-Up\",\n      kpi: \"Follow-Up Completion Rate\",\n      details: \"Follow-up actions such as informing the reporter or legal processing\",\n      subSteps: [\"Reporter Informed\", \"Legal Process Initiated\"],\n      errorSteps: [\"Follow-Up Missed\"],\n      errorProbability: 0.01,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 3 * 60 * 60 * 1000, // 3 hours\n      subStepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      ...generateMTTD_MTTR_MTTI(),\n    },\n  ],\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 6
      },
      "conditions": {
        "states": {
          "tourism_guided_tour_booking": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "tourism_guided_tour_booking"
      ]
    },
    "retail_supply_chain_fulfilment": {
      "name": "retail_supply_chain_fulfilment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Retail Supply Chain Fulfilment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Order Placement\", \n      kpi: \"Order Placement Success Rate\", \n      details: \"Customer places an order for products\", \n      subSteps: [\"Order Submitted\", \"Order Confirmed\"], \n      errorSteps: [\"Order Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ProductType: [\"Clothing\", \"Electronics\", \"Home Goods\"],\n        OrderChannel: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Inventory Check\", \n      kpi: \"Inventory Availability Rate\", \n      details: \"Inventory is checked for product availability\", \n      subSteps: [\"Inventory Verified\", \"Products Reserved\"], \n      errorSteps: [\"Product Out of Stock\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        WarehouseLocation: [\"London\", \"Manchester\", \"Birmingham\"],\n        InventoryMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Picking & Packing\", \n      kpi: \"Packing Success Rate\", \n      details: \"Products are picked and packed for shipment\", \n      subSteps: [\"Items Picked\", \"Items Packed\"],  \n      errorSteps: [\"Packing Delay\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PackagingType: [\"Standard\", \"Gift Wrap\"],\n        PickerType: [\"Manual\", \"Robotic\"]\n      },\n    },\n    { \n      stepName: \"Shipping & Dispatch\", \n      kpi: \"Dispatch Success Rate\", \n      details: \"Products are dispatched for delivery\", \n      subSteps: [\"Dispatch Scheduled\", \"Items Shipped\"],  \n      errorSteps: [\"Dispatch Delayed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ShippingProvider: [\"DHL\", \"UPS\", \"Royal Mail\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Last-Mile Delivery\", \n      kpi: \"On-Time Delivery Rate\", \n      details: \"Products are delivered to the customer's address\", \n      subSteps: [\"Out for Delivery\", \"Delivered\"],  \n      errorSteps: [\"Delivery Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CourierType: [\"Company Driver\", \"Third-Party\"],\n        DeliverySlot: [\"Morning\", \"Afternoon\", \"Evening\"]\n      },\n    },\n    { \n      stepName: \"Returns Processing\", \n      kpi: \"Returns Completion Rate\", \n      details: \"Customer returns an item and it is processed\", \n      subSteps: [\"Return Requested\", \"Item Received\"],  \n      errorSteps: [\"Return Rejected\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReturnMethod: [\"In-Store\", \"Courier Pickup\"],\n        RefundMethod: [\"Credit Card\", \"Gift Card\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 3
      },
      "conditions": {
        "states": {
          "broadband_service_activation": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "broadband_service_activation"
      ]
    },
    "software_development_lifecycle": {
      "name": "software_development_lifecycle",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Software Development Lifecycle\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Requirement Gathering\",\n      kpi: \"Requirement Success Rate\",\n      details: \"Gathering and documenting software requirements\",\n      subSteps: [\"Requirement Initiation\", \"Requirement Documentation\"],\n      errorSteps: [\"Requirement Failure\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        RequirementType: [\"Functional\", \"Non-Functional\"]\n      }\n    },\n    {\n      stepName: \"Design\",\n      kpi: \"Design Success Rate\",\n      details: \"Designing the software architecture and components\",\n      subSteps: [\"Design Initiation\", \"Design Completion\"],\n      errorSteps: [\"Design Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DesignType: [\"High-Level Design\", \"Detailed Design\"]\n      }\n    },\n    {\n      stepName: \"Development\",\n      kpi: \"Development Success Rate\",\n      details: \"Coding and implementing the software\",\n      subSteps: [\"Development Initiation\", \"Development Completion\"],\n      errorSteps: [\"Development Failure\"],\n      errorProbability: 0.07,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DevelopmentMethod: [\"Agile\", \"Waterfall\"]\n      }\n    },\n    {\n      stepName: \"Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the software for defects\",\n      subSteps: [\"Test Planning\", \"Test Execution\", \"Test Closure\"],\n      errorSteps: [\"Test Failure\"],\n      errorProbability: 0.08,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestType: [\"Unit Testing\", \"Integration Testing\", \"System Testing\", \"User Acceptance Testing\"]\n      }\n    },\n    {\n      stepName: \"Deployment\",\n      kpi: \"Deployment Success Rate\",\n      details: \"Deploying the software to production\",\n      subSteps: [\"Deployment Planning\", \"Deployment Execution\"],\n      errorSteps: [\"Deployment Failure\"],\n      errorProbability: 0.06,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        DeploymentMethod: [\"Manual\", \"Automated\"]\n      }\n    },\n    {\n      stepName: \"Maintenance\",\n      kpi: \"Maintenance Success Rate\",\n      details: \"Maintaining and updating the software\",\n      subSteps: [\"Maintenance Initiation\", \"Maintenance Completion\"],\n      errorSteps: [\"Maintenance Failure\"],\n      errorProbability: 0.04,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MaintenanceType: [\"Corrective\", \"Adaptive\", \"Perfective\", \"Preventive\"]\n      }\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 5
      },
      "conditions": {
        "states": {
          "construction_project_management": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "construction_project_management"
      ]
    },
    "construction_project_management": {
      "name": "construction_project_management",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Construction Project Management\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Project Initiation\",\n      kpi: \"Initiation Success Rate\",\n      details: \"Project is initiated and scope defined\",\n      subSteps: [\"Scope Defined\", \"Budget Estimated\"],\n      errorSteps: [\"Initiation Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ProjectType: [\"Residential\", \"Commercial\", \"Infrastructure\"],\n        InitiationChannel: [\"Internal\", \"Client\"]\n      }\n    },\n    {\n      stepName: \"Planning\",\n      kpi: \"Planning Success Rate\",\n      details: \"Project planning and scheduling\",\n      subSteps: [\"Plan Created\", \"Schedule Developed\"],\n      errorSteps: [\"Planning Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        PlanType: [\"Detailed\", \"Preliminary\"],\n        SchedulingTool: [\"MS Project\", \"Primavera\"]\n      }\n    },\n    {\n      stepName: \"Resource Allocation\",\n      kpi: \"Allocation Success Rate\",\n      details: \"Resources are allocated to the project\",\n      subSteps: [\"Resources Assigned\", \"Materials Procured\"],\n      errorSteps: [\"Allocation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ResourceType: [\"Human\", \"Equipment\", \"Materials\"]\n      }\n    },\n    {\n      stepName: \"Execution\",\n      kpi: \"Execution Success Rate\",\n      details: \"Project execution and monitoring\",\n      subSteps: [\"Tasks Completed\", \"Milestones Achieved\"],\n      errorSteps: [\"Execution Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TaskType: [\"Construction\", \"Inspection\", \"Approval\"]\n      }\n    },\n    {\n      stepName: \"Monitoring & Control\",\n      kpi: \"Control Success Rate\",\n      details: \"Project monitoring and control activities\",\n      subSteps: [\"Progress Tracked\", \"Issues Managed\"],\n      errorSteps: [\"Control Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"RestAPI\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        MonitoringTool: [\"MS Project\", \"Primavera\"],\n        ControlType: [\"Schedule\", \"Budget\", \"Quality\"]\n      }\n    },\n    {\n      stepName: \"Project Closure\",\n      kpi: \"Closure Success Rate\",\n      details: \"Project is closed and handed over\",\n      subSteps: [\"Final Inspection\", \"Project Handover\"],\n      errorSteps: [\"Closure Failed\"],\n      errorProbability: 0.03,\n      injectionMethod: \"Logs\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ClosureMethod: [\"Internal Review\", \"Client Handover\"]\n      }\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -5,
        "y": 4
      },
      "conditions": {
        "states": {
          "property_sales": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "property_sales"
      ]
    },
    "finance_investment_account_setup": {
      "name": "finance_investment_account_setup",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Investment Account Setup\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Account Registration\", \n      kpi: \"Registration Success Rate\", \n      details: \"Customer registers for an investment account\", \n      subSteps: [\"Account Created\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AccountType: [\"Stocks\", \"Bonds\", \"Mutual Funds\"],\n        RegistrationMethod: [\"Online\", \"Advisor\"]\n      },\n    },\n    { \n      stepName: \"Deposit Funds\", \n      kpi: \"Deposit Success Rate\", \n      details: \"Customer deposits funds into their investment account\", \n      subSteps: [\"Deposit Initiated\", \"Deposit Completed\"], \n      errorSteps: [\"Deposit Failed\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DepositMethod: [\"Bank Transfer\", \"Credit Card\", \"Direct Debit\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Investment Plan Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Customer selects an investment plan\", \n      subSteps: [\"Plan Viewed\", \"Plan Selected\"],  \n      errorSteps: [\"Plan Selection Abandoned\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PlanType: [\"Aggressive\", \"Conservative\", \"Balanced\"],\n        InvestmentDuration: [\"1 Year\", \"5 Years\", \"10 Years\"]\n      },\n    },\n    { \n      stepName: \"Portfolio Setup\", \n      kpi: \"Portfolio Setup Success Rate\", \n      details: \"Customer sets up their investment portfolio\", \n      subSteps: [\"Portfolio Configured\", \"Portfolio Approved\"],  \n      errorSteps: [\"Portfolio Rejected\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PortfolioType: [\"Custom\", \"Managed\"],\n        RiskTolerance: [\"High\", \"Medium\", \"Low\"]\n      },\n    },\n    { \n      stepName: \"Investment Start\", \n      kpi: \"Investment Start Success Rate\", \n      details: \"Customer's investments are activated\", \n      subSteps: [\"Investment Confirmed\", \"Investment Active\"],  \n      errorSteps: [\"Investment Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        InvestmentType: [\"Stocks\", \"Bonds\", \"Mutual Funds\"],\n        StartMethod: [\"Automatic\", \"Manual\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the investment setup process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Advisor\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 4
      },
      "conditions": {
        "states": {
          "utilities_energy_setup": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "utilities_energy_setup"
      ]
    },
    "retail_in-store_purchase_journey": {
      "name": "retail_in-store_purchase_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - In-Store Purchase Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Browsing\", \n      kpi: \"Browsing Success Rate\", \n      details: \"Customer browses products in-store\", \n      subSteps: [\"Products Viewed\", \"Product Selected\"], \n      errorSteps: [\"Browsing Abandoned\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ProductCategory: [\"Clothing\", \"Electronics\", \"Groceries\"],\n        StoreType: [\"Department Store\", \"Supermarket\", \"Boutique\"]\n      },\n    },\n    { \n      stepName: \"Add to Basket\", \n      kpi: \"Basket Success Rate\", \n      details: \"Customer adds items to their basket in-store\", \n      subSteps: [\"Item Selected\", \"Added to Basket\"], \n      errorSteps: [\"Item Not Available\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        BasketType: [\"Physical Basket\", \"Trolley\"],\n        ProductType: [\"Promotional\", \"Regular Stock\"]\n      },\n    },\n    { \n      stepName: \"Checkout\", \n      kpi: \"Checkout Success Rate\", \n      details: \"Customer proceeds to the checkout for payment\", \n      subSteps: [\"Checkout Started\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Cash\", \"Contactless\"],\n        CheckoutType: [\"Self-Checkout\", \"Cashier\"]\n      },\n    },\n    { \n      stepName: \"Receipt Issued\", \n      kpi: \"Receipt Issuance Rate\", \n      details: \"Customer receives a receipt for their purchase\", \n      subSteps: [\"Receipt Printed\", \"Receipt Issued\"],  \n      errorSteps: [\"Receipt Not Issued\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReceiptType: [\"Printed\", \"Email\"],\n        ReceiptMethod: [\"In-Store\", \"App\"]\n      },\n    },\n    { \n      stepName: \"Loyalty Points Redemption\", \n      kpi: \"Points Redemption Success Rate\", \n      details: \"Customer redeems loyalty points on their purchase\", \n      subSteps: [\"Points Applied\", \"Discount Provided\"],  \n      errorSteps: [\"Points Not Applied\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        LoyaltyProgram: [\"In-House\", \"Third-Party\"],\n        PointsRedeemed: [\"50 Points\", \"100 Points\", \"200 Points\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their in-store shopping experience\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackMethod: [\"In-Store\", \"Email\", \"App Notification\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -3,
        "y": 4
      },
      "conditions": {
        "states": {
          "retail_supply_chain_fulfilment": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "retail_supply_chain_fulfilment"
      ]
    },
    "pharmacy_prescription_fulfillment": {
      "name": "pharmacy_prescription_fulfillment",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Pharmacy Prescription Fulfillment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Prescription Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Patient submits a prescription to the pharmacy\", \n      subSteps: [\"Prescription Submitted\", \"Prescription Verified\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\", \"Mail\"],\n        PrescriptionType: [\"New\", \"Refill\"]\n      },\n    },\n    { \n      stepName: \"Prescription Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Prescription is approved by a pharmacist\", \n      subSteps: [\"Approval Requested\", \"Approval Granted\"], \n      errorSteps: [\"Approval Denied\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ApprovalType: [\"Standard\", \"Urgent\"],\n        PharmacistMethod: [\"In-House\", \"Third-Party\"]\n      },\n    },\n    { \n      stepName: \"Medication Preparation\", \n      kpi: \"Preparation Success Rate\", \n      details: \"Medication is prepared and packaged\", \n      subSteps: [\"Medication Prepared\", \"Packaging Completed\"],  \n      errorSteps: [\"Medication Not Available\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        MedicationType: [\"Generic\", \"Branded\"],\n        PackagingType: [\"Blister Pack\", \"Bottle\"]\n      },\n    },\n    { \n      stepName: \"Pickup or Delivery\", \n      kpi: \"Delivery Success Rate\", \n      details: \"Patient picks up or receives the medication\", \n      subSteps: [\"Pickup Confirmed\", \"Delivery Confirmed\"],  \n      errorSteps: [\"Pickup Missed\", \"Delivery Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PickupMethod: [\"In-Store\", \"Drive-Thru\"],\n        DeliveryMethod: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Patient pays for the medication\", \n      subSteps: [\"Payment Submitted\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        PaymentMethod: [\"Insurance\", \"Credit Card\", \"Cash\"],\n        PaymentType: [\"Co-Pay\", \"Full Payment\"]\n      },\n    },\n    { \n      stepName: \"Patient Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Patient provides feedback on the pharmacy service\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App\", \"In-Store\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 5
      },
      "conditions": {
        "states": {
          "online_course_enrollment": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "online_course_enrollment"
      ]
    },
    "financial_services_fraud_detection": {
      "name": "financial_services_fraud_detection",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Financial Services Fraud Detection\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Login Attempt Monitoring\", \n      kpi: \"Login Success Rate\", \n      details: \"Monitor customer logins for potential fraud indicators\", \n      subSteps: [\"Login Attempt\", \"Successful Login\"], \n      errorSteps: [\"Suspicious Login Detected\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        LoginType: [\"Single-Factor Authentication\", \"Multi-Factor Authentication\"],\n        DeviceType: [\"Mobile\", \"Desktop\", \"Tablet\"],\n        Location: [\"Domestic\", \"International\"]\n      },\n    },\n    { \n      stepName: \"Transaction Initiation Monitoring\", \n      kpi: \"Transaction Initiation Success Rate\", \n      details: \"Monitor transactions for potential fraud patterns\", \n      subSteps: [\"Transaction Initiated\", \"Transaction Approved\"], \n      errorSteps: [\"Transaction Blocked for Fraud\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TransactionType: [\"Online Purchase\", \"Fund Transfer\", \"Bill Payment\"],\n        TransactionAmount: [\"Low\", \"Medium\", \"High\"],\n        PaymentMethod: [\"Credit Card\", \"Debit Card\", \"Bank Transfer\"]\n      },\n    },\n    { \n      stepName: \"Fraud Alert Generation\", \n      kpi: \"Fraud Alert Success Rate\", \n      details: \"Generate fraud alerts based on suspicious activity\", \n      subSteps: [\"Suspicious Activity Detected\", \"Fraud Alert Created\"],  \n      errorSteps: [\"Fraud Alert Not Generated\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        AlertType: [\"High Risk\", \"Medium Risk\", \"Low Risk\"],\n        FraudType: [\"Account Takeover\", \"Transaction Fraud\"],\n        AlertSource: [\"AI Algorithm\", \"Manual Detection\"]\n      },\n    },\n    { \n      stepName: \"Fraud Case Escalation\", \n      kpi: \"Escalation Success Rate\", \n      details: \"Escalate high-risk fraud cases for immediate investigation\", \n      subSteps: [\"Case Created\", \"Case Escalated\"],  \n      errorSteps: [\"Escalation Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EscalationMethod: [\"Internal Fraud Team\", \"Third-Party Fraud Monitoring\"],\n        CasePriority: [\"High\", \"Medium\", \"Low\"]\n      },\n    },\n    { \n      stepName: \"Fraud Investigation\", \n      kpi: \"Investigation Completion Rate\", \n      details: \"Investigate flagged fraud cases\", \n      subSteps: [\"Investigation Initiated\", \"Investigation Completed\"],  \n      errorSteps: [\"Investigation Inconclusive\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        InvestigationType: [\"AI-Based\", \"Manual Review\"],\n        Outcome: [\"Fraud Confirmed\", \"Fraud Denied\"],\n        CaseResolutionTime: [\"Within 24 Hours\", \"More than 24 Hours\"]\n      },\n    },\n    { \n      stepName: \"Customer Notification\", \n      kpi: \"Customer Notification Success Rate\", \n      details: \"Notify the customer of fraud case outcome\", \n      subSteps: [\"Notification Sent\", \"Notification Acknowledged\"],  \n      errorSteps: [\"Notification Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        NotificationMethod: [\"Email\", \"SMS\", \"Phone Call\"],\n        AcknowledgementType: [\"Read\", \"Ignored\"],\n        CompensationOffered: [\"Yes\", \"No\"]\n      },\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 0,
        "y": 5
      },
      "conditions": {
        "states": {
          "flight_booking_and_travel": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "flight_booking_and_travel"
      ]
    },
    "renewable_energy_storage_solutions": {
      "name": "renewable_energy_storage_solutions",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Renewable Energy Storage Solutions\",\n  numberOfCustomers: 100,\n  steps: [\n    {\n      stepName: \"Service Inquiry\",\n      kpi: \"Inquiry Success Rate\",\n      details: \"Customer inquires about renewable energy storage solutions\",\n      subSteps: [\"Inquiry Initiated\", \"Inquiry Completed\"],\n      errorSteps: [\"Inquiry Failed\"],\n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InquiryType: [\"Residential\", \"Commercial\", \"Industrial\"]\n      }\n    },\n    {\n      stepName: \"Energy Storage Design\",\n      kpi: \"Design Success Rate\",\n      details: \"Designing the energy storage system\",\n      subSteps: [\"Design Consultation\", \"Design Finalization\"],\n      errorSteps: [\"Design Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\",\n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        StorageType: [\"Battery\", \"Thermal\", \"Mechanical\"]\n      }\n    },\n    {\n      stepName: \"Installation\",\n      kpi: \"Installation Success Rate\",\n      details: \"Installing the energy storage system\",\n      subSteps: [\"Installation Scheduled\", \"Installation Completed\"],\n      errorSteps: [\"Installation Failed\"],\n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\",\n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        InstallationType: [\"Professional\", \"DIY\"]\n      }\n    },\n    {\n      stepName: \"System Integration\",\n      kpi: \"Integration Success Rate\",\n      details: \"Integrating the energy storage system with existing infrastructure\",\n      subSteps: [\"Integration Initiated\", \"Integration Completed\"],\n      errorSteps: [\"Integration Failed\"],\n      errorProbability: 0.07,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        IntegrationType: [\"Grid-Tied\", \"Off-Grid\", \"Hybrid\"]\n      }\n    },\n    {\n      stepName: \"System Testing\",\n      kpi: \"Testing Success Rate\",\n      details: \"Testing the installed energy storage system\",\n      subSteps: [\"Testing Initiated\", \"Testing Completed\"],\n      errorSteps: [\"Testing Failed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        TestingMethod: [\"Performance\", \"Safety\"]\n      }\n    },\n    {\n      stepName: \"Feedback Collection\",\n      kpi: \"Feedback Response Rate\",\n      details: \"Collecting feedback from customers on renewable energy storage solutions\",\n      subSteps: [\"Feedback Requested\", \"Feedback Received\"],\n      errorSteps: [\"No Feedback Given\"],\n      errorProbability: 0.03,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        FeedbackChannel: [\"Email\", \"App Notification\", \"Survey\"]\n      }\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 3,
        "y": 10
      },
      "conditions": {
        "states": {
          "genetic_testing_services": "OK"
        }
      },
      "description": "Run custom JavaScript code.",
      "predecessors": [
        "genetic_testing_services"
      ]
    },
    "public_sector_operational_readiness": {
      "name": "public_sector_operational_readiness",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Public Sector Operational Readiness\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Mission Planning\", \n      kpi: \"Mission Planning Success Rate\", \n      details: \"Monitor the mission planning phase for readiness and potential delays\", \n      subSteps: [\"Plan Initiated\", \"Plan Finalized\"], \n      errorSteps: [\"Planning Delayed\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        MissionType: [\"Reconnaissance\", \"Logistics\", \"Defense\"],\n        PlanningMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Resource Deployment\", \n      kpi: \"Resource Deployment Success Rate\", \n      details: \"Track the deployment of resources in preparation for the mission\", \n      subSteps: [\"Resources Allocated\", \"Resources Deployed\"], \n      errorSteps: [\"Deployment Delayed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        DeploymentMethod: [\"Air\", \"Land\", \"Sea\"],\n        ResourceType: [\"Personnel\", \"Vehicles\", \"Equipment\"]\n      },\n    },\n    { \n      stepName: \"Communication Systems Check\", \n      kpi: \"Communication Systems Success Rate\", \n      details: \"Ensure communication systems are ready and functional\", \n      subSteps: [\"Systems Tested\", \"Systems Ready\"],  \n      errorSteps: [\"Communication Failure\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1.5 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CommunicationMethod: [\"Satellite\", \"Radio\", \"Encrypted\"],\n        TestingMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Mission Execution\", \n      kpi: \"Execution Success Rate\", \n      details: \"Monitor the execution of the mission for operational readiness\", \n      subSteps: [\"Mission Started\", \"Mission in Progress\"],  \n      errorSteps: [\"Mission Halted\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OperationType: [\"Reconnaissance\", \"Defense\", \"Combat\"],\n        MissionRegion: [\"Domestic\", \"International\"]\n      },\n    },\n    { \n      stepName: \"Supply Chain Monitoring\", \n      kpi: \"Supply Chain Efficiency Rate\", \n      details: \"Track the readiness of the supply chain during the mission\", \n      subSteps: [\"Supplies Ordered\", \"Supplies Delivered\"],  \n      errorSteps: [\"Supply Delay\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SupplierType: [\"Local\", \"International\"],\n        TransportMethod: [\"Air\", \"Sea\", \"Land\"]\n      },\n    },\n    { \n      stepName: \"Mission Debriefing\", \n      kpi: \"Debrief Completion Rate\", \n      details: \"Conduct a debrief session to review mission performance and readiness\", \n      subSteps: [\"Debrief Initiated\", \"Debrief Completed\"],  \n      errorSteps: [\"Debrief Incomplete\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackChannel: [\"In-Person\", \"Email\", \"Report\"],\n        OutcomeRating: [\"Successful\", \"Partially Successful\", \"Unsuccessful\"]\n      },\n    }\n  ]\n};\n\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 1,
        "y": 5
      },
      "conditions": {
        "states": {
          "theme_park_visitor_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "theme_park_visitor_journey"
      ]
    },
    "uk_met_police_-_arrest_to_resolution": {
      "name": "uk_met_police_-_arrest_to_resolution",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - UK MET Police - Arrest to Resolution\",\n  numberOfCustomers: 100, // Simulating 50 unique cases/incidents\n  steps: [\n    {\n      stepName: \"Incident Reporting\",\n      kpi: \"Incident Reporting Success Rate\",\n      details: \"A member of the public reports an incident.\",\n      subSteps: [\"Report Created\", \"Report Submitted\", \"Report Acknowledged\"],\n      errorSteps: [\"Report Submission Failed\"],\n      errorProbability: 0.01,\n      injectionMethod: \"RestAPI\",\n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      subStepTimeIncrement: 10 * 60 * 1000, // 10 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ReportType: [\"Theft\", \"Assault\", \"Vandalism\", \"Cyber Crime\", \"Public Disturbance\"],\n        ReporterLocation: [\"North London\", \"South London\", \"East London\", \"West London\"],\n        PriorityLevel: [\"High\", \"Medium\", \"Low\"],\n      },\n    },\n    {\n      stepName: \"Arrest\",\n      kpi: \"Arrest Success Rate\",\n      details: \"Police respond to the incident and make an arrest.\",\n      subSteps: [\"Police Dispatched\", \"Suspect Located\", \"Suspect Arrested\"],\n      errorSteps: [\"Suspect Escaped\", \"Arrest Delayed\"],\n      errorProbability: 0.02,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 1 * 60 * 60 * 1000, // 1 hour\n      subStepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ArrestType: [\"On-Scene Arrest\", \"Planned Arrest\", \"Warrant Arrest\"],\n        OfficerUnitsInvolved: [1, 2, 3, 4],\n        SuspectResistance: [\"None\", \"Low\", \"High\"],\n      },\n    },\n    {\n      stepName: \"Custody\",\n      kpi: \"Custody Process Completion Rate\",\n      details: \"Suspect is taken into custody for processing.\",\n      subSteps: [\"Custody Record Created\", \"Suspect Searched\", \"Detention Authorized\"],\n      errorSteps: [\"Custody Record Error\", \"Detention Rejected\"],\n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 2 * 60 * 60 * 1000, // 2 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        CustodyLocation: [\"North London Station\", \"South London Station\"],\n        ReasonForCustody: [\"Investigation Pending\", \"Charge Preparation\"],\n      },\n    },\n    {\n      stepName: \"Investigation\",\n      kpi: \"Investigation Success Rate\",\n      details: \"Case investigation involving evidence gathering.\",\n      subSteps: [\"Evidence Collected\", \"Suspect Interviewed\", \"Case File Prepared\"],\n      errorSteps: [\"Evidence Misplaced\", \"Suspect Refused Interview\"],\n      errorProbability: 0.02,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 8 * 60 * 60 * 1000, // 8 hours\n      subStepTimeIncrement: 1 * 60 * 60 * 1000, // 1 hour\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        EvidenceType: [\"CCTV\", \"Witness Statements\", \"Physical Evidence\"],\n        InvestigatorTeam: [\"Team A\", \"Team B\", \"Team C\"],\n      },\n    },\n    {\n      stepName: \"Court Proceedings\",\n      kpi: \"Court Case Success Rate\",\n      details: \"Case is presented in court for judgment.\",\n      subSteps: [\"Court Date Set\", \"Evidence Presented\", \"Verdict Delivered\"],\n      errorSteps: [\"Court Adjourned\", \"Verdict Delayed\"],\n      errorProbability: 0.05,\n      injectionMethod: \"Logs\",\n      stepTimeIncrement: 3 * 60 * 60 * 1000, // 3 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        Verdict: [\"Guilty\", \"Not Guilty\"],\n        SentenceType: [\"Imprisonment\", \"Community Service\", \"Fine\"],\n      },\n    },\n    {\n      stepName: \"Resolution\",\n      kpi: \"Case Closure Rate\",\n      details: \"Final actions post-verdict, including suspect processing and record updates.\",\n      subSteps: [\"Sentence Initiated\", \"Records Updated\", \"Case Closed\"],\n      errorSteps: [\"Records Update Failed\"],\n      errorProbability: 0.01,\n      injectionMethod: \"OneAgent\",\n      stepTimeIncrement: 1 * 60 * 60 * 1000, // 1 hour\n      subStepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      ...generateMTTD_MTTR_MTTI(),\n    },\n  ],\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": -2,
        "y": 6
      },
      "conditions": {
        "states": {
          "pharmacy_prescription_fulfillment": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "pharmacy_prescription_fulfillment"
      ]
    },
    "transportation_public_transit_journey": {
      "name": "transportation_public_transit_journey",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Transportation Public Transit Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Ticket Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Customer buys a transit ticket\", \n      subSteps: [\"Ticket Selected\", \"Payment Processed\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TicketType: [\"Single\", \"Return\", \"Monthly Pass\"],\n        PaymentMethod: [\"Credit Card\", \"Mobile Payment\", \"Cash\"]\n      },\n    },\n    { \n      stepName: \"Boarding\", \n      kpi: \"Boarding Success Rate\", \n      details: \"Customer boards the bus or train\", \n      subSteps: [\"Ticket Scanned\", \"Entry Granted\"], \n      errorSteps: [\"Ticket Invalid\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TransportType: [\"Bus\", \"Train\", \"Tram\"],\n        BoardingStation: [\"Central\", \"Suburban\"]\n      },\n    },\n    { \n      stepName: \"Journey\", \n      kpi: \"Journey Success Rate\", \n      details: \"Customer completes their public transit journey\", \n      subSteps: [\"Journey Started\", \"Journey Completed\"],  \n      errorSteps: [\"Journey Delayed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        JourneyLength: [\"Short\", \"Medium\", \"Long\"],\n        ServiceType: [\"Regular\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Transfer\", \n      kpi: \"Transfer Success Rate\", \n      details: \"Customer transfers between transit lines or modes\", \n      subSteps: [\"Transfer Started\", \"Transfer Completed\"],  \n      errorSteps: [\"Transfer Missed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        TransferType: [\"Bus to Train\", \"Train to Bus\", \"Train to Train\"],\n        TransferStation: [\"Central\", \"Suburban\"]\n      },\n    },\n    { \n      stepName: \"Exit\", \n      kpi: \"Exit Success Rate\", \n      details: \"Customer exits the public transit system\", \n      subSteps: [\"Exit Processed\", \"Exit Completed\"],  \n      errorSteps: [\"Exit Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 10 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ExitStation: [\"Central\", \"Suburban\"],\n        JourneyFeedback: [\"Positive\", \"Neutral\", \"Negative\"]\n      },\n    },\n    { \n      stepName: \"Post-Journey Feedback\", \n      kpi: \"Feedback Submission Rate\", \n      details: \"Customer provides feedback on their transit journey\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FeedbackMethod: [\"Email\", \"Mobile App\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 4
      },
      "conditions": {
        "states": {
          "mobile_service_activation": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "mobile_service_activation"
      ]
    },
    "passenger_journey_and_flight_operations": {
      "name": "passenger_journey_and_flight_operations",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Passenger Journey and Flight Operations\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Check-in Process\", \n      kpi: \"Check-in Efficiency\", \n      details: \"Monitor the process from passenger check-in to boarding pass issuance\", \n      subSteps: [\"Passenger Check-in\", \"Luggage Drop-off\", \"Boarding Pass Issued\"],\n      errorSteps: [\"Check-in Delayed\"],\n      errorProbability: 0.02, // 2% chance of delay in check-in\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000, // 30 minutes between main steps\n      subStepTimeIncrement: 10 * 60 * 1000, // 10 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        FlightNumber: () => `BA${Math.floor(Math.random() * 1000 + 100)}`,\n        CheckInCounter: [\"Counter 1\", \"Counter 2\", \"Self-service Kiosk\"],\n        PassengerType: [\"Business Traveler\", \"Leisure Traveler\"],\n        DocumentType: [\"Passport\", \"National ID\"],\n        LuggageWeight: () => `${Math.floor(Math.random() * 30) + 10} kg`,\n      },\n    },\n    { \n      stepName: \"Security and Boarding\", \n      kpi: \"Passenger Flow Efficiency\", \n      details: \"Track passengers through security and boarding\", \n      subSteps: [\"Security Clearance\", \"Gate Waiting\", \"Boarding Completed\"],\n      errorSteps: [\"Security Delay\"],\n      errorProbability: 0.03, // 3% chance of delay\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 45 * 60 * 1000, // 45 minutes\n      subStepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SecurityLane: [\"Lane 1\", \"Lane 2\", \"Fast Track\"],\n        BoardingGroup: [\"Group 1\", \"Group 2\", \"Priority\"],\n        HandLuggageCount: () => `${Math.floor(Math.random() * 2) + 1} items`,\n      },\n    },\n    {\n      stepName: \"In-flight Operations\", \n      kpi: \"Flight Status and Passenger Comfort\", \n      details: \"Monitor in-flight conditions, passenger satisfaction, and services\", \n      subSteps: [\"Meal Service\", \"In-flight Entertainment\", \"Passenger Feedback\"],\n      errorSteps: [\"Service Delay\"],\n      errorProbability: 0.02, // 2% chance of in-flight service delay\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000, // 2 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        CabinClass: [\"Economy\", \"Business\", \"First Class\"],\n        MealType: [\"Vegetarian\", \"Non-Vegetarian\", \"Vegan\", \"Kosher\"],\n        InFlightEntertainmentRating: () => `${Math.floor(Math.random() * 5) + 1} stars`,\n        PassengerComplaints: [\"None\", \"Seat Comfort\", \"Noise\", \"Temperature\"],\n      },\n    },\n    {\n      stepName: \"Engine Health Monitoring\", \n      kpi: \"In-flight Engine Health\", \n      details: \"Monitor engine health during the flight for safety and performance\", \n      subSteps: [\"Engine Check\", \"Performance Metrics Update\"],\n      errorSteps: [\"Engine Warning\", \"Engine Failure\"],\n      errorProbability: 0.03, // 3% chance of engine warning or failure\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      subStepTimeIncrement: 5 * 60 * 1000, // 5 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        EngineTemperature: () => `${Math.floor(Math.random() * 200) + 400} C`,\n        FuelConsumptionRate: () => `${(Math.random() * 5 + 3).toFixed(2)} kg/min`,\n        VibrationLevel: () => `${Math.random().toFixed(2)} G`,\n      },\n    },\n    {\n      stepName: \"Landing and Arrival\", \n      kpi: \"Smooth Landing and Passenger Exit\", \n      details: \"Track the landing process and passenger deboarding\", \n      subSteps: [\"Landing Initiated\", \"Touchdown\", \"Deboarding\"],\n      errorSteps: [\"Landing Delay\"],\n      errorProbability: 0.01, // 1% chance of delay\n      injectionMethod: \"Logs\", \n      stepTimeIncrement: 1 * 60 * 60 * 1000, // 1 hour\n      subStepTimeIncrement: 15 * 60 * 1000, // 15 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ArrivalGate: [\"Gate A1\", \"Gate B2\", \"Gate C3\"],\n        DeboardingTime: () => `${Math.floor(Math.random() * 30) + 10} mins`,\n        WeatherCondition: [\"Clear\", \"Rain\", \"Windy\"],\n      },\n    },\n    {\n      stepName: \"Post-flight Analysis\", \n      kpi: \"Comprehensive Flight Review\", \n      details: \"Analyze post-flight data for service improvement\", \n      subSteps: [\"Data Aggregation\", \"Report Generation\", \"Insights Review\"],\n      errorSteps: [],\n      errorProbability: 0.0, // No errors for analysis\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 3 * 60 * 60 * 1000, // 3 hours\n      subStepTimeIncrement: 30 * 60 * 1000, // 30 minutes\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        ReportType: [\"Operational\", \"Customer Satisfaction\", \"Technical\"],\n        AnalystName: [\"John Smith\", \"Lisa Brown\", \"Michael Lee\"],\n        ImprovementSuggestions: [\"Improve meal options\", \"Enhance boarding efficiency\", \"Update entertainment system\"],\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "action": "dynatrace.automations:run-javascript",
      "position": {
        "x": 2,
        "y": 5
      },
      "conditions": {
        "states": {
          "transportation_public_transit_journey": "OK"
        }
      },
      "description": "Build a custom task running js Code",
      "predecessors": [
        "transportation_public_transit_journey"
      ]
    }
  },
  "description": "",
  "actor": "fa94290b-310d-429d-a688-9fe5484de482",
  "owner": "fa94290b-310d-429d-a688-9fe5484de482",
  "ownerType": "USER",
  "isPrivate": false,
  "trigger": {
    "schedule": {
      "isActive": true,
      "isFaulty": false,
      "trigger": {
        "type": "interval",
        "intervalMinutes": 360
      },
      "rule": null,
      "filterParameters": {
        "earliestStart": "2024-10-23",
        "earliestStartTime": "16:26"
      },
      "timezone": "Europe/London",
      "inputs": {},
      "nextExecution": "2025-03-11T15:26:00.000Z"
    }
  },
  "schemaVersion": 3,
  "result": null,
  "input": {},
  "hourlyExecutionLimit": 1000,
  "type": "STANDARD"
}
