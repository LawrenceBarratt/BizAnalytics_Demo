{
  "id": "cb3ffa96-aaf1-47d4-95a5-9acab3361fdf",
  "title": "TGIF Demo",
  "tasks": {
    "retail": {
      "name": "retail",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Retail Shopping\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Browses Products\", \n      kpi: \"Product Browsing Duration\", \n      details: \"Customer browses products on the e-commerce website\", \n      subSteps: [\"Homepage Visit\", \"Product Category View\", \"Product Details View\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: null, \n      error: \"Page Load Timeout\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Adds Items to Cart\", \n      kpi: \"Cart Addition Rate\", \n      details: \"Customer adds selected items to the shopping cart\", \n      subSteps: [\"Select Item\", \"Add to Cart\", \"Cart Update\"],\n      paymentType: null, \n      includeTotal: true, \n      includeOrderItems: true, \n      products: { productName: \"Selected Product\", productPrice: 30, quantity: 1 }, \n      error: \"Cart Update Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Proceeds to Checkout\", \n      kpi: \"Checkout Initiation Rate\", \n      details: \"Customer initiates the checkout process\", \n      subSteps: [\"Billing Info\", \"Shipping Info\", \"Order Review\"],\n      paymentType: null,\n      includeTotal: true,\n      includeOrderItems: true,\n      products: { productName: \"Selected Product\", productPrice: 30, quantity: 1 }, \n      error: \"Checkout Page Load Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Completes Purchase\", \n      kpi: \"Purchase Completion Rate\", \n      details: \"Completion of the purchase\", \n      subSteps: [\"Payment Processing\", \"Order Confirmation\"],\n      paymentType: \"credit card\", \n      includeTotal: true, \n      includeOrderItems: true,\n      products: { productName: \"Selected Product\", productPrice: 30, quantity: 1 }, \n      error: \"Payment Gateway Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Shopping Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"API\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 1
      },
      "predecessors": []
    },
    "banking": {
      "name": "banking",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Banking Services\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Logs In\", \n      kpi: \"Login Success Rate\", \n      details: \"Customer logs into the online banking platform\", \n      subSteps: [\"Enter Credentials\", \"Two-Factor Authentication\", \"Login Success\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: null, \n      error: \"Login Timeout\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Views Account Balance\", \n      kpi: \"Balance Check Rate\", \n      details: \"Customer views their account balance\", \n      subSteps: [\"View Balance Summary\", \"View Account Details\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: null, \n      error: \"Balance Display Error\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Initiates Fund Transfer\", \n      kpi: \"Fund Transfer Initiation Rate\", \n      details: \"Customer initiates a fund transfer to another account\", \n      subSteps: [\"Select Payee\", \"Enter Transfer Amount\", \"Transfer Confirmation\"],\n      paymentType: \"bank transfer\", \n      includeTotal: true, \n      includeOrderItems: false,\n      products: { productName: \"Fund Transfer\", productPrice: 0, quantity: 1 }, \n      error: \"Transfer Failure\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Views Transaction History\", \n      kpi: \"Transaction History View Rate\", \n      details: \"Customer views transaction history\", \n      subSteps: [\"View Recent Transactions\", \"Transaction Details\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: \"Transaction History Retrieval Error\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Banking Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"API\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 1,
        "y": 1
      },
      "predecessors": []
    },
    "broadband": {
      "name": "broadband",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Broadband\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n \n    { \n      stepName: \"Customer Selects Broadband Plan\", \n      kpi: \"Plan Selection Rate\", \n      details: \"Customer selects a broadband plan\", \n      subSteps: [\"Plan Selection\", \"Plan Added to Cart\", \"Navigation Error\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: true, \n      products: { productName: \"Unlimited Broadband Plan\", productPrice: 50, quantity: 1 }, \n      error: \"Inventory Check Failure\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Proceeds to Checkout\", \n      kpi: \"Checkout Initiation Rate\", \n      details: \"Customer initiates the checkout process\", \n      subSteps: [\"Billing Info\", \"Shipping Info\", \"Review Order\", \"Checkout Failure\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: true,\n      products: { productName: \"Installation Service\", productPrice: 100, quantity: 1 }, \n      error: \"Basket not loading\",\n      ...generateMTTD_MTTR_MTTI(), \n\n      injectionMethod: \"OneAgent\", \n    },\n    { \n      stepName: \"Customer Completes Purchase\", \n      kpi: \"Purchase Completion Rate\", \n      details: \"Completion of the broadband plan purchase\", \n      subSteps: [\"Payment Processing\", \"Order Confirmation\", \"Payment Failure\"],\n      paymentType: \"credit card\", \n      includeTotal: true, \n      includeOrderItems: true,\n      products: { productName: \"Unlimited Broadband Plan\", productPrice: 50, quantity: 1 }, \n      error: \"Payment Gateway Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Activation\", \n      kpi: \"Activation Time\", \n      details: \"Activation of the broadband service\", \n      subSteps: [\"Installation\", \"Activation Confirmation\", \"Activation Failure\"],\n      paymentType: null,\n      includeTotal: true,\n      includeOrderItems: false,\n      products: null, \n      error: \"Activation Error\", \n      injectionMethod: \"Mobile SDK\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Return Rate\", \"Link Expired\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: \"Incorrect Orderid\",\n      injectionMethod: \"API\",\n      ...generateMTTD_MTTR_MTTI(), \n       incidentNumber: null\n\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 0,
        "y": 1
      },
      "predecessors": []
    },
    "loan_application": {
      "name": "loan_application",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Loan Application\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Submits Loan Application\", \n      kpi: \"Loan Application Submission Rate\", \n      details: \"Customer submits an application for a loan\", \n      subSteps: [\"Fill Out Loan Application\", \"Submit Application\", \"Confirmation of Submission\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: { productName: \"Loan Application\", productPrice: 0, quantity: 1 }, \n      error: \"Application Submission Failure\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Credit Reference Check\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Calling credit reference agencies to check customer's credit score\", \n      subSteps: [\"Request Credit Score\", \"Receive Credit Report\", \"Analyze Credit Data\", \"Experian Check\", \"Equifax Check\", \"TransUnion Check\", \"Credit Check Failed\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: null, \n      error: \"Credit Reference Check Failure\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Loan Application Review\", \n      kpi: \"Loan Application Review Rate\", \n      details: \"Reviewing the loan application and credit check results\", \n      subSteps: [\"Review Application Data\", \"Review Credit Data\", \"Application Decision\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: { productName: \"Loan Review\", productPrice: 0, quantity: 1 }, \n      error: \"Loan Review Process Error\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Loan Approval and Disbursement\", \n      kpi: \"Loan Disbursement Rate\", \n      details: \"Final approval and disbursement of loan funds\", \n      subSteps: [\"Loan Approval\", \"Loan Agreement Signed\", \"Funds Disbursed\"],\n      paymentType: \"bank transfer\",\n      includeTotal: true,\n      includeOrderItems: false,\n      products: { productName: \"Loan Amount\", productPrice: 10000, quantity: 1 }, \n      error: \"Disbursement Delay\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings for the loan application process\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Loan Process Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"API\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 3,
        "y": 1
      },
      "predecessors": []
    },
    "car_manufacturing": {
      "name": "car_manufacturing",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Car Manufacturing Process\", \n  numberOfCustomers: 100, // Number of cars to generate\n  steps: [\n    { \n      stepName: \"Chassis Assembly\", \n      kpi: \"Chassis Assembly Completion Rate\", \n      details: \"Assembling the car chassis\", \n      subSteps: [\"Welding Frame\", \"Installing Suspension\", \"Mounting Chassis Components\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: { productName: \"Car Chassis\", productPrice: 10000, quantity: 1 }, \n      error: \"Chassis Assembly Delay\", \n      injectionMethod: \"IoT Device\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Engine Installation\", \n      kpi: \"Engine Installation Rate\", \n      details: \"Installing the engine into the chassis\", \n      subSteps: [\"Mount Engine\", \"Connect Fuel System\", \"Test Engine Performance\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: { productName: \"Car Engine\", productPrice: 8000, quantity: 1 }, \n      error: \"Engine Installation Failure\", \n      injectionMethod: \"IoT Device\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Transmission Installation\", \n      kpi: \"Transmission Installation Rate\", \n      details: \"Installing the transmission system\", \n      subSteps: [\"Mount Transmission\", \"Connect Drive Shaft\", \"Test Gear Shifting\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: { productName: \"Car Transmission\", productPrice: 5000, quantity: 1 }, \n      error: \"Transmission Installation Error\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Body Painting\", \n      kpi: \"Painting Completion Rate\", \n      details: \"Painting the car body\", \n      subSteps: [\"Apply Primer\", \"Apply Paint\", \"Final Coat and Polishing\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: { productName: \"Paint and Coating\", productPrice: 2000, quantity: 1 }, \n      error: \"Painting Process Failure\", \n      injectionMethod: \"Mobile SDK\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Final Assembly and Inspection\", \n      kpi: \"Final Assembly Success Rate\", \n      details: \"Assembling and inspecting the final car\", \n      subSteps: [\"Install Interior\", \"Mount Tires\", \"Final Inspection\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: \"Inspection Failure\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 1
      },
      "predecessors": []
    },
    "subscriptionservice": {
      "name": "subscriptionservice",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Subscription Service\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Selects Subscription Plan\", \n      kpi: \"Subscription Plan Selection Rate\", \n      details: \"Customer selects a subscription plan\", \n      subSteps: [\"Plan Selection\", \"Plan Added to Cart\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: true, \n      products: { productName: \"Premium Subscription Plan\", productPrice: 100, quantity: 1 }, \n      error: \"Plan Selection Timeout\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Proceeds to Checkout\", \n      kpi: \"Checkout Initiation Rate\", \n      details: \"Customer initiates the checkout process for the subscription\", \n      subSteps: [\"Billing Info\", \"Review Order\"],\n      paymentType: \"credit card\",\n      includeTotal: true,\n      includeOrderItems: true,\n      products: { productName: \"Premium Subscription Plan\", productPrice: 100, quantity: 1 }, \n      error: \"Checkout Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Completes Purchase\", \n      kpi: \"Purchase Completion Rate\", \n      details: \"Completion of the subscription purchase\", \n      subSteps: [\"Payment Processing\", \"Order Confirmation\"],\n      paymentType: \"credit card\", \n      includeTotal: true, \n      includeOrderItems: true,\n      products: { productName: \"Premium Subscription Plan\", productPrice: 100, quantity: 1 }, \n      error: \"Payment Gateway Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Subscription Activation\", \n      kpi: \"Activation Time\", \n      details: \"Activation of the subscription service\", \n      subSteps: [\"Activation Processing\", \"Activation Confirmation\"],\n      paymentType: null,\n      includeTotal: true,\n      includeOrderItems: false,\n      products: null, \n      error: \"Activation Error\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Subscription Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"Logs\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -1,
        "y": 1
      },
      "predecessors": []
    },
    "insurance_application": {
      "name": "insurance_application",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Insurance Application Process\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Submits Insurance Application\", \n      kpi: \"Application Submission Rate\", \n      details: \"Customer submits an insurance application\", \n      subSteps: [\"Fill Out Application Form\", \"Submit Application\", \"Receive Application Confirmation\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: { productName: \"Insurance Application\", productPrice: 0, quantity: 1 }, \n      error: \"Application Submission Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Risk Assessment\", \n      kpi: \"Risk Assessment Completion Rate\", \n      details: \"Assessing the risk associated with the customer's insurance application\", \n      subSteps: [\"Collect Customer Data\", \"Credit Reference Agency Check\", \"Evaluate Risk Factors\", \"Generate Risk Score\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: null, \n      error: \"Risk Assessment Failure\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Premium Calculation\", \n      kpi: \"Premium Calculation Success Rate\", \n      details: \"Calculating the premium based on risk assessment\", \n      subSteps: [\"Calculate Base Premium\", \"Adjust for Risk Factors\", \"Final Premium Generated\"],\n      paymentType: null,\n      includeTotal: true,\n      includeOrderItems: false,\n      products: { productName: \"Insurance Premium\", productPrice: 500, quantity: 1 }, \n      error: \"Premium Calculation Error\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Policy Approval\", \n      kpi: \"Policy Approval Rate\", \n      details: \"Approving the insurance policy and confirming it with the customer\", \n      subSteps: [\"Approve Policy\", \"Generate Policy Documents\", \"Send Policy Confirmation\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: { productName: \"Insurance Policy\", productPrice: 0, quantity: 1 }, \n      error: \"Policy Approval Delay\", \n      injectionMethod: \"Logs\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings for the insurance application process\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Insurance Application Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"API\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -4,
        "y": 1
      },
      "predecessors": []
    },
    "automobile_purchase_journey": {
      "name": "automobile_purchase_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  // MTTD between 1 and 6\n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; // MTTI is greater than MTTD\n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; // MTTR is greater than MTTI\n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"TGIF_Demo - Automobile Purchase Journey\", \n  numberOfCustomers: 100, // Number of customers to generate\n  steps: [\n    { \n      stepName: \"Customer Selects Car Model\", \n      kpi: \"Car Model Selection Rate\", \n      details: \"Customer selects a car model from the dealership's website\", \n      subSteps: [\"Browse Car Models\", \"Select Car Model\", \"View Car Details\"],\n      paymentType: null, \n      includeTotal: false, \n      includeOrderItems: false, \n      products: { productName: \"Selected Car Model\", productPrice: 30000, quantity: 1 }, \n      error: \"Model Selection Timeout\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Configures Car\", \n      kpi: \"Car Configuration Rate\", \n      details: \"Customer configures the selected car model (e.g., color, features)\", \n      subSteps: [\"Select Car Features\", \"Configure Accessories\"],\n      paymentType: null, \n      includeTotal: true, \n      includeOrderItems: true, \n      products: { productName: \"Car Configuration\", productPrice: 2000, quantity: 1 }, \n      error: \"Configuration Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(),\n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Proceeds to Checkout\", \n      kpi: \"Checkout Initiation Rate\", \n      details: \"Customer proceeds to checkout after configuring the car\", \n      subSteps: [\"Review Configuration\", \"Enter Payment Info\", \"Place Order\"],\n      paymentType: \"credit card\",\n      includeTotal: true,\n      includeOrderItems: true,\n      products: { productName: \"Selected Car Model\", productPrice: 30000, quantity: 1 }, \n      error: \"Checkout Error\", \n      injectionMethod: \"OneAgent\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Car Delivery and Handover\", \n      kpi: \"Delivery Success Rate\", \n      details: \"Customer receives the car and completes the handover process\", \n      subSteps: [\"Schedule Delivery\", \"Handover Confirmation\"],\n      paymentType: null,\n      includeTotal: true,\n      includeOrderItems: false,\n      products: null, \n      error: \"Delivery Delay\", \n      injectionMethod: \"API\", \n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Customer Satisfaction Index\", \n      details: \"Customer feedback and satisfaction ratings\", \n      subSteps: [\"Customer Satisfaction Score (CSAT)\", \"Car Delivery Experience Survey\"],\n      paymentType: null,\n      includeTotal: false,\n      includeOrderItems: false,\n      products: null, \n      error: null,\n      injectionMethod: \"Logs\",\n      ...generateMTTD_MTTR_MTTI(), \n      incidentNumber: null\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\", \"mail.com\", \"broadbandprovider.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const subStepDescription = config.steps[stepNumber - 1].subSteps[subStepIndex - 1];\n  const subStepError = Math.random() < 0.2 ? \"Generated SubStep Error\" : null;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: `${stepNumber}.${subStepIndex}`,\n    type: `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError,\n    injectionMethod: config.steps[stepNumber - 1].injectionMethod, // Add injectionMethod for substeps\n    incidentNumber: incidentNumber  // Incident number only if there is an error in the substep\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, subStep = null, totalRevenue = null) {\n  const step = config.steps[stepNumber - 1];\n  let feedbackScore = null;\n  let feedbackMessage = null;\n\n  if (step.stepName === \"Customer Feedback\") {\n    feedbackScore = Math.floor(Math.random() * 11);\n    feedbackMessage = feedbackScore >= 9 ? \"Fantastic!\" : feedbackScore >= 7 ? \"Good\" : \"Needs improvement\";\n  }\n\n  const error = isError || step.error || null;\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber, // Only generate an incident number if there's an error\n    paymentType: step.paymentType || null,\n    plannedDeliveryDate: null,\n    total: step.includeTotal ? totalRevenue : null, \n    customer: JSON.stringify({ firstName: firstName, lastName: lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n      products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: subStep ? `${stepNumber}.${subStep}` : stepNumber.toString(),\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    feedbackScore: feedbackScore,\n    feedbackMessage: feedbackMessage,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: subStep ? `${step.stepName} - ${step.subSteps[subStep - 1]}` : step.stepName,\n    injectionMethod: step.injectionMethod, // Include the injection method for each step\n    source: config.sector\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); // Generate the orderId once per customer\n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = 0;\n\n  for (let i = 0; i < config.steps.length; i++) {\n    const stepTimestamp = timestamps[i];\n    const isError = Math.random() < 0.3; // Simulating a 30% chance of error in main steps\n    const continueJourney = Math.random() < 0.8;\n    const revenue = generateTransactionAmount();\n    totalRevenue += revenue;\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, isError, null, totalRevenue);\n    steps.push(step);\n\n    if (isError) {\n      break;  // Stop further steps if an error occurs in the main step\n    }\n\n    if (continueJourney) {\n      for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length; subStepIndex++) {\n        const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000); // Substeps occur 1 minute apart\n        const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n        steps.push(subStep);\n        \n        if (subStep.error) {\n          break; // Stop further substeps if an error occurs in a substep\n        }\n      }\n    } else {\n      break; // Stop journey if not continuing\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, // Include incident number if there is an error\n      paymentType: event.paymentType,\n      total: event.total,\n      customer: event.customer, // Customer as JSON string\n      orderItemsProductIDs: event.orderItemsProductIDs, // Order items as JSON string\n      products: event.products, // Products as native JSON object or string if there's only one product\n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      feedbackScore: event.feedbackScore,\n      feedbackMessage: event.feedbackMessage,\n      apiCallName: event.apiCallName,\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, // Include MTTD if error exists\n      MTTR: event.MTTR, // Include MTTR if error exists\n      MTTI: event.MTTI, // Include MTTI if error exists\n      injectionMethod: event.injectionMethod // Include injection method\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 2,
        "y": 1
      },
      "predecessors": []
    }
  },
  "description": "",
  "actor": "fa94290b-310d-429d-a688-9fe5484de482",
  "owner": "fa94290b-310d-429d-a688-9fe5484de482",
  "ownerType": "USER",
  "isPrivate": true,
  "trigger": {
    "schedule": {
      "isActive": true,
      "isFaulty": false,
      "trigger": {
        "type": "interval",
        "intervalMinutes": 30
      },
      "rule": null,
      "filterParameters": {
        "earliestStart": "2024-09-11",
        "earliestStartTime": "22:32"
      },
      "timezone": "Europe/London",
      "inputs": {},
      "nextExecution": "2024-09-13T11:02:00.000Z"
    }
  },
  "schemaVersion": 3
}
