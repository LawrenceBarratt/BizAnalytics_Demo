{
  "id": "721b7ce1-15c4-44e6-b46c-5f6e037acfa9",
  "title": "Business Analytics Journeys",
  "tasks": {
    "loan_application": {
      "name": "loan_application",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Loan Application\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits a loan application\", \n      subSteps: [\"Form Completion\", \"Submitted\"], \n      errorSteps: [\"Application Incomplete\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        LoanType: [\"Personal\", \"Home\", \"Car\"],\n        ApplicationChannel: [\"Online\", \"In-Person\", \"Mobile\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Identity Verification Success Rate\", \n      details: \"Customer's identity is verified\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.07,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        VerificationMethod: [\"Online\", \"In-Person\"],\n        IDType: [\"Passport\", \"Driver’s License\", \"Utility Bill\"]\n      },\n    },\n    { \n      stepName: \"Credit Check\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Customer's credit history is verified\", \n      subSteps: [\"Credit Check Initiated\", \"Credit Score Verified\"],\n      errorSteps: [\"Credit Check Failed\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CreditAgency: [\"Experian\", \"Equifax\", \"TransUnion\"],\n        CreditScoreRange: [\"300-500\", \"500-700\", \"700-850\"]\n      },\n    },\n    { \n      stepName: \"Document Submission\", \n      kpi: \"Document Submission Success Rate\", \n      details: \"Customer submits required documents\", \n      subSteps: [\"Documents Uploaded\", \"Verification Underway\"], \n      errorSteps: [\"Document Rejected\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DocumentType: [\"Income Proof\", \"Address Proof\", \"Bank Statements\"],\n        SubmissionChannel: [\"Mobile Upload\", \"Online Portal\"]\n      },\n    },\n    { \n      stepName: \"Loan Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Loan is approved or rejected\", \n      subSteps: [\"Approval Under Review\", \"Decision Made\"],  \n      errorSteps: [\"Approval Denied\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApprovalDecision: [\"Approved\", \"Rejected\", \"Conditionally Approved\"],\n        LoanAmount: [\"<£10,000\", \"£10,000-£50,000\", \">£50,000\"]\n      },\n    },\n    { \n      stepName: \"Loan Disbursement\", \n      kpi: \"Disbursement Success Rate\", \n      details: \"Loan amount is disbursed to customer\", \n      subSteps: [\"Funds Transferred\", \"Confirmation Sent\"],  \n      errorSteps: [\"Transfer Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DisbursementMethod: [\"Bank Transfer\", \"Cheque\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "real_estate_journey": {
      "name": "real_estate_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Real Estate Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Property Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for properties\", \n      subSteps: [\"Search Initiated\", \"Property Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        SearchChannel: [\"Website\", \"Mobile App\", \"Agent\"],\n        PropertyType: [\"Apartment\", \"House\", \"Commercial\"]\n      },\n    },\n    { \n      stepName: \"Property Viewing\", \n      kpi: \"Viewing Success Rate\", \n      details: \"Customer schedules and attends property viewings\", \n      subSteps: [\"Viewing Scheduled\", \"Viewing Completed\"], \n      errorSteps: [\"Viewing No-Show\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ViewingMethod: [\"In-Person\", \"Virtual Tour\"],\n        ViewingDay: [\"Weekday\", \"Weekend\"]\n      },\n    },\n    { \n      stepName: \"Offer Submission\", \n      kpi: \"Offer Submission Success Rate\", \n      details: \"Customer submits an offer on a property\", \n      subSteps: [\"Offer Submitted\", \"Offer Accepted\"],\n      errorSteps: [\"Offer Rejected\"], \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        OfferMethod: [\"Agent\", \"Online Portal\"],\n        OfferType: [\"Cash\", \"Mortgage\"]\n      },\n    },\n    { \n      stepName: \"Mortgage Application\", \n      kpi: \"Mortgage Application Success Rate\", \n      details: \"Customer applies for a mortgage\", \n      subSteps: [\"Application Submitted\", \"Application Approved\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.12,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApplicationChannel: [\"Bank\", \"Online\", \"Broker\"],\n        MortgageType: [\"Fixed\", \"Variable\"]\n      },\n    },\n    { \n      stepName: \"Contract Exchange\", \n      kpi: \"Contract Exchange Success Rate\", \n      details: \"Contracts are exchanged between buyer and seller\", \n      subSteps: [\"Contracts Sent\", \"Contracts Exchanged\"],  \n      errorSteps: [\"Exchange Delayed\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ContractType: [\"Sale\", \"Lease\"],\n        LegalEntity: [\"Solicitor\", \"Conveyancer\"]\n      },\n    },\n    { \n      stepName: \"Completion & Handover\", \n      kpi: \"Completion Success Rate\", \n      details: \"Property sale is completed and keys are handed over\", \n      subSteps: [\"Completion Scheduled\", \"Keys Handover\"],  \n      errorSteps: [\"Handover Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        HandoverMethod: [\"In-Person\", \"Agent\"],\n        PropertyCondition: [\"As-Is\", \"Renovated\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 2
      },
      "predecessors": [
        "loan_application"
      ],
      "conditions": {
        "states": {
          "loan_application": "OK"
        }
      }
    },
    "utilities_and_energy": {
      "name": "utilities_and_energy",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Utilities & Energy\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Meter Reading\", \n      kpi: \"Meter Reading Success Rate\", \n      details: \"Meter is read for usage calculation\", \n      subSteps: [\"Meter Accessed\", \"Reading Recorded\"], \n      errorSteps: [\"Reading Failed\"], \n      errorProbability: 0.02,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        MeterType: [\"Electricity\", \"Gas\", \"Water\"],\n        ReadingMethod: [\"Manual\", \"Smart Meter\"]\n      },\n    },\n    { \n      stepName: \"Usage Calculation\", \n      kpi: \"Calculation Success Rate\", \n      details: \"Customer's utility usage is calculated\", \n      subSteps: [\"Usage Data Processed\", \"Calculation Completed\"], \n      errorSteps: [\"Calculation Error\"], \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        EnergySource: [\"Renewable\", \"Non-Renewable\"],\n        Region: [\"North\", \"South\"]\n      },\n    },\n    { \n      stepName: \"Bill Generation\", \n      kpi: \"Bill Generation Success\", \n      details: \"Bill is generated based on usage\", \n      subSteps: [\"Bill Created\", \"Bill Sent\"],\n      errorSteps: [\"Bill Generation Error\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\", \"PayPal\"],\n        BillingFrequency: [\"Monthly\", \"Quarterly\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Customer pays for their utility usage\", \n      subSteps: [\"Payment Received\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentChannel: [\"Mobile\", \"Online\", \"Phone\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Account Management\", \n      kpi: \"Account Update Success Rate\", \n      details: \"Customer updates account details or preferences\", \n      subSteps: [\"Preferences Updated\", \"Account Details Saved\"],  \n      errorSteps: [\"Update Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        UpdateMethod: [\"Self-Service\", \"Customer Service\"],\n        AccountType: [\"Residential\", \"Business\"]\n      },\n    },\n    { \n      stepName: \"Service Continuation\", \n      kpi: \"Service Continuation Success Rate\", \n      details: \"Service is either continued or disconnected\", \n      subSteps: [\"Service Active\", \"Service Continued\"],  \n      errorSteps: [\"Service Disconnected\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ServiceType: [\"Electricity\", \"Gas\", \"Water\"],\n        Region: [\"North\", \"South\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 3,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "e-commerce_and_retail": {
      "name": "e-commerce_and_retail",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - E-Commerce & Retail\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Selection\", \n      kpi: \"Product Selection Success Rate\", \n      details: \"Customer selects a product to add to cart\", \n      subSteps: [\"Browsing\", \"Added to Cart\"], \n      errorSteps: [\"Product Out of Stock\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        DeviceType: [\"Mobile\", \"Desktop\", \"Tablet\"],\n        Category: [\"Electronics\", \"Clothing\", \"Home Goods\"]\n      },\n    },\n    { \n      stepName: \"Cart Checkout\", \n      kpi: \"Cart Checkout Success Rate\", \n      details: \"Customer checks out the cart\", \n      subSteps: [\"Review Cart\", \"Proceed to Checkout\"], \n      errorSteps: [\"Cart Abandoned\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 20 * 60 * 1000,\n      AdditionalFields: { \n        PaymentOption: [\"One-Click\", \"Standard\"],\n        ShippingMethod: [\"Standard Shipping\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Customer completes the payment process\", \n      subSteps: [\"Payment Initiated\", \"Payment Processed\"],\n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        Currency: [\"GBP\", \"EUR\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Order Fulfillment\", \n      kpi: \"Order Fulfillment Success\", \n      details: \"Order is processed and fulfilled\", \n      subSteps: [\"Order Received\", \"Packed for Shipment\", \"Shipped\"],  \n      errorSteps: [\"Fulfillment Delay\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FulfillmentCenter: [\"London\", \"Manchester\", \"Birmingham\"],\n        DeliveryType: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Shipping & Delivery\", \n      kpi: \"On-Time Delivery Rate\", \n      details: \"Order is shipped and delivered to customer\", \n      subSteps: [\"Shipped\", \"Out for Delivery\", \"Delivered\"], \n      errorSteps: [\"Delivery Delayed\"], \n      errorProbability: 0.04,\n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CourierService: [\"DHL\", \"Royal Mail\", \"UPS\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Post-Purchase Feedback\", \n      kpi: \"Customer Feedback Rate\", \n      details: \"Customer provides feedback after order is delivered\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"SMS\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 1,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "hotel_booking_journey": {
      "name": "hotel_booking_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Hotel Booking Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Room Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available hotel rooms\", \n      subSteps: [\"Search Started\", \"Room Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        BookingPlatform: [\"Website\", \"Mobile App\", \"Third-Party\"],\n        RoomType: [\"Single\", \"Double\", \"Suite\"]\n      },\n    },\n    { \n      stepName: \"Booking Confirmation\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer confirms their hotel room booking\", \n      subSteps: [\"Booking Details Entered\", \"Booking Confirmed\"], \n      errorSteps: [\"Booking Failed\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Customer checks into the hotel\", \n      subSteps: [\"Booking Confirmed\", \"Check-In Completed\"],\n      errorSteps: [\"Check-In Failed\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CheckInMethod: [\"In-Person\", \"Online\"],\n        RoomType: [\"Single\", \"Double\", \"Suite\"]\n      },\n    },\n    { \n      stepName: \"Stay Experience\", \n      kpi: \"Stay Experience Rating\", \n      details: \"Customer stays at the hotel and rates their experience\", \n      subSteps: [\"Check-In\", \"Stay Completed\"],  \n      errorSteps: [\"Issue During Stay\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ServiceType: [\"Room Service\", \"Spa\", \"Concierge\"],\n        StayDuration: [\"1 Night\", \"2-3 Nights\", \"1 Week\"]\n      },\n    },\n    { \n      stepName: \"Check-Out\", \n      kpi: \"Check-Out Success Rate\", \n      details: \"Customer checks out of the hotel\", \n      subSteps: [\"Check-Out Initiated\", \"Check-Out Completed\"],  \n      errorSteps: [\"Check-Out Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        FeedbackProvided: [\"Yes\", \"No\"]\n      },\n    },\n    { \n      stepName: \"Post-Stay Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after their stay\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Unsatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 1,
        "y": 2
      },
      "predecessors": [
        "e-commerce_and_retail"
      ],
      "conditions": {
        "states": {
          "e-commerce_and_retail": "OK"
        }
      }
    },
    "university_admissions": {
      "name": "university_admissions",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - University Admissions\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Student submits a university application\", \n      subSteps: [\"Application Started\", \"Application Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000,\n      AdditionalFields: { \n        CourseType: [\"Undergraduate\", \"Postgraduate\"],\n        SubmissionMethod: [\"UCAS\", \"Direct Application\"]\n      },\n    },\n    { \n      stepName: \"Document Submission\", \n      kpi: \"Document Submission Success Rate\", \n      details: \"Student submits supporting documents (e.g., transcripts)\", \n      subSteps: [\"Documents Uploaded\", \"Verification Ongoing\"], \n      errorSteps: [\"Document Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DocumentType: [\"Transcript\", \"Recommendation Letter\"],\n        SubmissionMethod: [\"Online\", \"Post\"]\n      },\n    },\n    { \n      stepName: \"Offer Decision\", \n      kpi: \"Decision Success Rate\", \n      details: \"University decides to offer a place or reject the application\", \n      subSteps: [\"Application Reviewed\", \"Decision Made\"],\n      errorSteps: [\"Application Rejected\"], \n      errorProbability: 0.15,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        OfferType: [\"Conditional\", \"Unconditional\"],\n        RejectionReason: [\"Grades\", \"Space Availability\"]\n      },\n    },\n    { \n      stepName: \"Offer Acceptance\", \n      kpi: \"Acceptance Success Rate\", \n      details: \"Student accepts or rejects the offer\", \n      subSteps: [\"Offer Accepted\", \"Offer Declined\"],  \n      errorSteps: [\"Acceptance Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        AcceptanceMethod: [\"Online\", \"UCAS Portal\"],\n        CourseStart: [\"September\", \"January\"]\n      },\n    },\n    { \n      stepName: \"Enrollment\", \n      kpi: \"Enrollment Success Rate\", \n      details: \"Student enrolls in the course\", \n      subSteps: [\"Enrollment Initiated\", \"Enrollment Confirmed\"],  \n      errorSteps: [\"Enrollment Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        EnrollmentMethod: [\"Online\", \"In-Person\"],\n        CourseType: [\"Full-Time\", \"Part-Time\"]\n      },\n    },\n    { \n      stepName: \"Orientation & Induction\", \n      kpi: \"Orientation Attendance Rate\", \n      details: \"Student attends orientation and induction events\", \n      subSteps: [\"Induction Scheduled\", \"Orientation Completed\"],  \n      errorSteps: [\"No Show\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        EventType: [\"Welcome Event\", \"Induction\"],\n        AttendanceMethod: [\"In-Person\", \"Virtual\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 0,
        "y": 2
      },
      "predecessors": [
        "automobile_order_production"
      ],
      "conditions": {
        "states": {
          "automobile_order_production": "OK"
        }
      }
    },
    "utilities_energy_setup": {
      "name": "utilities_energy_setup",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Utilities Energy Setup\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Enquiry\", \n      kpi: \"Enquiry Success Rate\", \n      details: \"Customer makes an enquiry about energy services\", \n      subSteps: [\"Enquiry Submitted\", \"Enquiry Reviewed\"], \n      errorSteps: [\"Enquiry Rejected\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        EnquiryMethod: [\"Phone\", \"Online\", \"In-Person\"],\n        ServiceType: [\"Electricity\", \"Gas\", \"Dual Fuel\"]\n      },\n    },\n    { \n      stepName: \"Quote Provided\", \n      kpi: \"Quote Success Rate\", \n      details: \"Customer receives a quote for energy services\", \n      subSteps: [\"Quote Generated\", \"Quote Sent\"], \n      errorSteps: [\"Quote Rejected\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TariffType: [\"Fixed\", \"Variable\", \"Green Energy\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Account Setup\", \n      kpi: \"Account Setup Success Rate\", \n      details: \"Customer sets up an energy account\", \n      subSteps: [\"Account Created\", \"Billing Details Provided\"],  \n      errorSteps: [\"Account Setup Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\"],\n        BillingCycle: [\"Monthly\", \"Quarterly\"]\n      },\n    },\n    { \n      stepName: \"Meter Installation\", \n      kpi: \"Installation Success Rate\", \n      details: \"Installation of energy meter at customer premises\", \n      subSteps: [\"Installation Scheduled\", \"Meter Installed\"],  \n      errorSteps: [\"Installation Failed\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        MeterType: [\"Smart Meter\", \"Standard Meter\"],\n        InstallationMethod: [\"Engineer Visit\", \"Self-Installation\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Energy service is activated for the customer\", \n      subSteps: [\"Activation Requested\", \"Service Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Phone\"],\n        ActivationType: [\"Electricity\", \"Gas\", \"Both\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the energy service setup\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Phone\", \"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 3,
        "y": 3
      },
      "predecessors": [
        "drug_development_and_approval"
      ],
      "conditions": {
        "states": {
          "drug_development_and_approval": "OK"
        }
      }
    },
    "citizen_public_services": {
      "name": "citizen_public_services",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Citizen Public Services\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Application\", \n      kpi: \"Application Success Rate\", \n      details: \"Citizen applies for a government service\", \n      subSteps: [\"Form Completed\", \"Application Submitted\"], \n      errorSteps: [\"Form Incomplete\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        ServiceType: [\"Benefits\", \"Council Tax\", \"Passport\"],\n        SubmissionMethod: [\"Online\", \"In-Person\"]\n      },\n    },\n    { \n      stepName: \"Application Review\", \n      kpi: \"Review Success Rate\", \n      details: \"Application is reviewed by the government office\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"], \n      errorSteps: [\"Review Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ReviewMethod: [\"Automated\", \"Manual\"],\n        OfficeLocation: [\"London\", \"Manchester\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Citizen pays for a service (e.g., council tax, passport fees)\", \n      subSteps: [\"Payment Submitted\", \"Payment Confirmed\"],\n      errorSteps: [\"Payment Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Direct Debit\"],\n        Currency: [\"GBP\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Document Issuance\", \n      kpi: \"Document Issuance Rate\", \n      details: \"Government issues documents to the citizen\", \n      subSteps: [\"Document Generated\", \"Document Sent\"],  \n      errorSteps: [\"Issuance Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DocumentType: [\"Passport\", \"Permit\", \"Certificate\"],\n        IssuanceMethod: [\"Mail\", \"In-Person Collection\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Citizen activates a government service (e.g., benefits)\", \n      subSteps: [\"Service Approved\", \"Service Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ServiceType: [\"Health\", \"Housing\", \"Benefits\"],\n        ActivationMethod: [\"Online\", \"Phone\"]\n      },\n    },\n    { \n      stepName: \"Service Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Citizen provides feedback on the government service\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackMethod: [\"Survey\", \"Phone\"],\n        SatisfactionLevel: [\"Satisfied\", \"Neutral\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -1,
        "y": 2
      },
      "predecessors": [
        "mortgage_application_process"
      ],
      "conditions": {
        "states": {
          "mortgage_application_process": "OK"
        }
      }
    },
    "media_and_entertainment": {
      "name": "media_and_entertainment",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Media & Entertainment Subscription Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Subscription Plan Selection\", \n      kpi: \"Plan Selection Success Rate\", \n      details: \"Customer selects a subscription plan for streaming services\", \n      subSteps: [\"Plan Browsed\", \"Plan Selected\"], \n      errorSteps: [\"Plan Selection Abandoned\"], \n      errorProbability: 0.07,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        PlanType: [\"Basic\", \"Standard\", \"Premium\"],\n        SubscriptionChannel: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Account Registration\", \n      kpi: \"Registration Success Rate\", \n      details: \"Customer creates a new account for the streaming service\", \n      subSteps: [\"Account Created\", \"Email Verified\"], \n      errorSteps: [\"Registration Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        RegistrationMethod: [\"Email\", \"Social Media\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\"]\n      },\n    },\n    { \n      stepName: \"Subscription Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer activates their subscription\", \n      subSteps: [\"Activation Completed\", \"Content Access Granted\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DeviceUsed: [\"Smart TV\", \"Mobile\", \"Desktop\"],\n        ActivationMethod: [\"Self-Activation\", \"Customer Service\"]\n      },\n    },\n    { \n      stepName: \"Content Browsing\", \n      kpi: \"Browsing Success Rate\", \n      details: \"Customer browses content within the streaming service\", \n      subSteps: [\"Content Browsed\", \"Show/Film Selected\"],  \n      errorSteps: [\"Content Not Available\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ContentType: [\"TV Series\", \"Film\", \"Documentary\"],\n        Genre: [\"Drama\", \"Comedy\", \"Thriller\"]\n      },\n    },\n    { \n      stepName: \"Playback & Streaming\", \n      kpi: \"Playback Success Rate\", \n      details: \"Customer streams selected content\", \n      subSteps: [\"Playback Started\", \"Playback Completed\"],  \n      errorSteps: [\"Playback Interrupted\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PlaybackDevice: [\"Smart TV\", \"Mobile\", \"Tablet\"],\n        PlaybackQuality: [\"HD\", \"4K\"]\n      },\n    },\n    { \n      stepName: \"Subscription Renewal\", \n      kpi: \"Renewal Success Rate\", \n      details: \"Customer renews their subscription at the end of the billing cycle\", \n      subSteps: [\"Renewal Initiated\", \"Renewal Completed\"],  \n      errorSteps: [\"Renewal Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Direct Debit\"],\n        SubscriptionTerm: [\"Monthly\", \"Yearly\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 3
      },
      "predecessors": [
        "real_estate_journey"
      ],
      "conditions": {
        "states": {
          "real_estate_journey": "OK"
        }
      }
    },
    "online_shopping_journey": {
      "name": "online_shopping_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Shopping Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for products online\", \n      subSteps: [\"Search Started\", \"Product Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        SearchDevice: [\"Mobile\", \"Desktop\", \"Tablet\"],\n        SearchChannel: [\"Website\", \"App\"]\n      },\n    },\n    { \n      stepName: \"Cart Addition\", \n      kpi: \"Cart Addition Success Rate\", \n      details: \"Customer adds products to their shopping cart\", \n      subSteps: [\"Product Added to Cart\", \"Cart Updated\"], \n      errorSteps: [\"Cart Abandoned\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ProductType: [\"Clothing\", \"Electronics\", \"Home Goods\"],\n        CartAction: [\"Add\", \"Remove\"]\n      },\n    },\n    { \n      stepName: \"Checkout\", \n      kpi: \"Checkout Success Rate\", \n      details: \"Customer proceeds to checkout and enters payment information\", \n      subSteps: [\"Checkout Initiated\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Gift Card\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Order Confirmation\", \n      kpi: \"Order Confirmation Rate\", \n      details: \"Order is confirmed and a receipt is sent to the customer\", \n      subSteps: [\"Order Confirmed\", \"Email Sent\"],  \n      errorSteps: [\"Order Canceled\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        OrderChannel: [\"Website\", \"App\"],\n        ShippingMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Order Shipment\", \n      kpi: \"Shipment Success Rate\", \n      details: \"Order is shipped to the customer\", \n      subSteps: [\"Shipped\", \"Out for Delivery\"],  \n      errorSteps: [\"Shipment Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ShippingProvider: [\"DHL\", \"Royal Mail\", \"UPS\"],\n        ShippingSpeed: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after receiving the order\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackMethod: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Neutral\", \"Unsatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -1,
        "y": 3
      },
      "predecessors": [
        "citizen_public_services"
      ],
      "conditions": {
        "states": {
          "citizen_public_services": "OK"
        }
      }
    },
    "online_course_enrollment": {
      "name": "online_course_enrollment",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Online Course Enrollment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Course Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Student searches for available online courses\", \n      subSteps: [\"Search Initiated\", \"Courses Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CourseType: [\"Degree Program\", \"Certification\", \"Short Course\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Course Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Student selects a course to enroll in\", \n      subSteps: [\"Course Selected\", \"Enrollment Started\"], \n      errorSteps: [\"Course Unavailable\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        EnrollmentChannel: [\"Website\", \"App\"],\n        CourseLevel: [\"Undergraduate\", \"Postgraduate\", \"Professional\"]\n      },\n    },\n    { \n      stepName: \"Payment\", \n      kpi: \"Payment Success Rate\", \n      details: \"Student pays for the selected course\", \n      subSteps: [\"Payment Processed\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        PaymentCurrency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Course Access\", \n      kpi: \"Access Success Rate\", \n      details: \"Student gains access to the course materials\", \n      subSteps: [\"Access Granted\", \"Course Started\"],  \n      errorSteps: [\"Access Denied\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        AccessMethod: [\"Browser\", \"Mobile App\"],\n        StudyMode: [\"Full-Time\", \"Part-Time\"]\n      },\n    },\n    { \n      stepName: \"Course Completion\", \n      kpi: \"Completion Rate\", \n      details: \"Student completes the online course\", \n      subSteps: [\"Final Exam Completed\", \"Course Completion Confirmed\"],  \n      errorSteps: [\"Failed to Complete\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CompletionMethod: [\"Exam\", \"Project\"],\n        Certification: [\"Yes\", \"No\"]\n      },\n    },\n    { \n      stepName: \"Feedback Submission\", \n      kpi: \"Feedback Submission Rate\", \n      details: \"Student provides feedback on the course\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 4
      },
      "predecessors": [
        "media_and_entertainment"
      ],
      "conditions": {
        "states": {
          "media_and_entertainment": "OK"
        }
      }
    },
    "claims_processing_journey": {
      "name": "claims_processing_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Insurance Claims Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Claim Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an insurance claim\", \n      subSteps: [\"Claim Started\", \"Claim Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.08,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ClaimType: [\"Home\", \"Car\", \"Health\"],\n        SubmissionMethod: [\"Online\", \"Phone\", \"Agent\"]\n      },\n    },\n    { \n      stepName: \"Claim Acknowledgment\", \n      kpi: \"Acknowledgment Rate\", \n      details: \"Customer receives acknowledgment of their claim\", \n      subSteps: [\"Acknowledgment Sent\", \"Acknowledgment Received\"], \n      errorSteps: [\"No Acknowledgment\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CommunicationMethod: [\"Email\", \"SMS\", \"Phone\"],\n        ResponseTime: [\"Immediate\", \"Delayed\"]\n      },\n    },\n    { \n      stepName: \"Claim Review\", \n      kpi: \"Review Completion Rate\", \n      details: \"Insurance company reviews the claim\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"],  \n      errorSteps: [\"Review Rejected\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 48 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ReviewType: [\"Manual\", \"Automated\"],\n        ReviewerRole: [\"Adjuster\", \"Manager\"]\n      },\n    },\n    { \n      stepName: \"Claim Decision\", \n      kpi: \"Decision Rate\", \n      details: \"Insurance company makes a decision on the claim\", \n      subSteps: [\"Decision Made\", \"Customer Notified\"],  \n      errorSteps: [\"Decision Delayed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 72 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DecisionType: [\"Approval\", \"Denial\"],\n        DecisionMethod: [\"Email\", \"Phone\"]\n      },\n    },\n    { \n      stepName: \"Claim Payment\", \n      kpi: \"Payment Completion Rate\", \n      details: \"Customer receives payment for the approved claim\", \n      subSteps: [\"Payment Processed\", \"Payment Completed\"],  \n      errorSteps: [\"Payment Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Bank Transfer\", \"Cheque\"],\n        PaymentCurrency: [\"GBP\", \"USD\"]\n      },\n    },\n    { \n      stepName: \"Claim Closure\", \n      kpi: \"Claim Closure Rate\", \n      details: \"Claim is officially closed\", \n      subSteps: [\"Closure Processed\", \"Claim Closed\"],  \n      errorSteps: [\"Closure Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 12 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ClosureReason: [\"Resolved\", \"Withdrawn\"],\n        CommunicationMethod: [\"Email\", \"Letter\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 1,
        "y": 3
      },
      "predecessors": [
        "hotel_booking_journey"
      ],
      "conditions": {
        "states": {
          "hotel_booking_journey": "OK"
        }
      }
    },
    "flight_booking_and_travel": {
      "name": "flight_booking_and_travel",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Flight Booking & Travel\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Flight Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available flights\", \n      subSteps: [\"Search Initiated\", \"Flights Viewed\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TravelType: [\"One-Way\", \"Round-Trip\", \"Multi-City\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Flight Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer books a flight\", \n      subSteps: [\"Booking Completed\", \"Payment Made\"], \n      errorSteps: [\"Booking Canceled\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\"],\n        ClassType: [\"Economy\", \"Business\", \"First Class\"]\n      },\n    },\n    { \n      stepName: \"Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Customer checks in for their flight\", \n      subSteps: [\"Check-In Initiated\", \"Check-In Completed\"],  \n      errorSteps: [\"Check-In Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CheckInMethod: [\"Online\", \"In-Person\"],\n        BoardingPassMethod: [\"Mobile\", \"Printed\"]\n      },\n    },\n    { \n      stepName: \"Baggage Drop\", \n      kpi: \"Baggage Drop Success Rate\", \n      details: \"Customer drops off baggage at the airport\", \n      subSteps: [\"Baggage Tagged\", \"Baggage Dropped\"],  \n      errorSteps: [\"Baggage Not Tagged\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        BaggageType: [\"Carry-On\", \"Checked\"],\n        DropOffMethod: [\"Self-Service\", \"Staff-Assisted\"]\n      },\n    },\n    { \n      stepName: \"Boarding\", \n      kpi: \"Boarding Success Rate\", \n      details: \"Customer boards the flight\", \n      subSteps: [\"Boarding Initiated\", \"Boarding Completed\"],  \n      errorSteps: [\"Boarding Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        BoardingZone: [\"Zone 1\", \"Zone 2\", \"Zone 3\"],\n        SeatType: [\"Window\", \"Aisle\", \"Middle\"]\n      },\n    },\n    { \n      stepName: \"Flight Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their flight experience\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 0,
        "y": 4
      },
      "predecessors": [
        "patient_appointment_journey"
      ],
      "conditions": {
        "states": {
          "patient_appointment_journey": "OK"
        }
      }
    },
    "mobile_service_activation": {
      "name": "mobile_service_activation",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mobile Service Activation\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"SIM Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Customer purchases a SIM card\", \n      subSteps: [\"SIM Browsed\", \"SIM Purchased\"], \n      errorSteps: [\"Purchase Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PurchaseChannel: [\"In-Store\", \"Online\", \"Retail Partner\"],\n        SIMType: [\"Prepaid\", \"Postpaid\"]\n      },\n    },\n    { \n      stepName: \"SIM Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer activates their SIM card\", \n      subSteps: [\"Activation Requested\", \"Activation Completed\"], \n      errorSteps: [\"Activation Failed\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Phone\", \"In-Store\"],\n        NetworkType: [\"4G\", \"5G\"]\n      },\n    },\n    { \n      stepName: \"Plan Selection\", \n      kpi: \"Plan Selection Success Rate\", \n      details: \"Customer selects a mobile plan\", \n      subSteps: [\"Plan Browsed\", \"Plan Selected\"],  \n      errorSteps: [\"Plan Selection Abandoned\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PlanType: [\"Unlimited Data\", \"Pay As You Go\"],\n        PlanDuration: [\"Monthly\", \"Yearly\"]\n      },\n    },\n    { \n      stepName: \"Payment Setup\", \n      kpi: \"Payment Setup Completion Rate\", \n      details: \"Customer sets up payment for their plan\", \n      subSteps: [\"Payment Method Selected\", \"Payment Setup Completed\"],  \n      errorSteps: [\"Payment Setup Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Debit\", \"Credit Card\"],\n        BillingCycle: [\"Monthly\", \"Annually\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Service Activation Success Rate\", \n      details: \"Mobile service is activated for the customer\", \n      subSteps: [\"Service Activation Requested\", \"Service Activated\"],  \n      errorSteps: [\"Service Activation Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ServiceType: [\"Voice & Data\", \"Data Only\"],\n        ActivationChannel: [\"Online\", \"In-Store\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the service activation process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"SMS\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 2,
        "y": 3
      },
      "predecessors": [
        "banking_new_account_opening"
      ],
      "conditions": {
        "states": {
          "banking_new_account_opening": "OK"
        }
      }
    },
    "healthcare_patient_journey": {
      "name": "healthcare_patient_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Healthcare Patient Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Appointment Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Patient books an appointment\", \n      subSteps: [\"Appointment Created\", \"Confirmation Sent\"], \n      errorSteps: [\"Booking Failed\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        BookingMethod: [\"Phone\", \"Online\", \"In-Person\"],\n        AppointmentType: [\"GP Visit\", \"Specialist\", \"Diagnostic Test\"]\n      },\n    },\n    { \n      stepName: \"Consultation\", \n      kpi: \"Consultation Completion Rate\", \n      details: \"Patient attends consultation\", \n      subSteps: [\"Check-In\", \"Consultation Started\"],\n      errorSteps: [\"No-Show\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ConsultationMethod: [\"In-Person\", \"Telemedicine\"],\n        PhysicianType: [\"GP\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Diagnostic Testing\", \n      kpi: \"Testing Success Rate\", \n      details: \"Patient undergoes diagnostic tests\", \n      subSteps: [\"Test Scheduled\", \"Test Completed\"],  \n      errorSteps: [\"Test Cancelled\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TestType: [\"Blood Test\", \"X-Ray\", \"MRI\"],\n        Facility: [\"Hospital\", \"Clinic\"]\n      },\n    },\n    { \n      stepName: \"Treatment Plan Creation\", \n      kpi: \"Treatment Plan Completion Rate\", \n      details: \"Treatment plan is created based on diagnosis\", \n      subSteps: [\"Diagnosis Complete\", \"Plan Created\"],  \n      errorSteps: [\"Treatment Plan Delayed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TreatmentType: [\"Medication\", \"Surgery\", \"Therapy\"],\n        PlanApprovalMethod: [\"Doctor\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Follow-Up Appointment\", \n      kpi: \"Follow-Up Appointment Rate\", \n      details: \"Follow-up appointment is scheduled\", \n      subSteps: [\"Follow-Up Scheduled\", \"Appointment Confirmed\"],  \n      errorSteps: [\"Appointment Not Scheduled\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FollowUpType: [\"Routine Check\", \"Diagnostic Follow-Up\"],\n        BookingChannel: [\"Phone\", \"Online\"]\n      },\n    },\n    { \n      stepName: \"Billing & Insurance\", \n      kpi: \"Billing Success Rate\", \n      details: \"Patient billing and insurance claims are processed\", \n      subSteps: [\"Bill Generated\", \"Claim Submitted\"],  \n      errorSteps: [\"Billing Error\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Insurance\", \"Self-Pay\"],\n        Currency: [\"GBP\", \"USD\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "theme_park_visitor_journey": {
      "name": "theme_park_visitor_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Theme Park Visitor Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Ticket Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor purchases theme park tickets online or at the gate\", \n      subSteps: [\"Ticket Selected\", \"Payment Processed\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TicketType: [\"Single-Day\", \"Multi-Day\", \"Season Pass\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Gift Card\"]\n      },\n    },\n    { \n      stepName: \"Park Entry\", \n      kpi: \"Entry Success Rate\", \n      details: \"Visitor enters the park using a valid ticket\", \n      subSteps: [\"Ticket Scanned\", \"Entry Granted\"], \n      errorSteps: [\"Ticket Not Valid\"], \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        EntryMethod: [\"Main Gate\", \"Fast Pass Entry\"],\n        TicketType: [\"Regular\", \"VIP\"]\n      },\n    },\n    { \n      stepName: \"Ride Selection\", \n      kpi: \"Ride Selection Success Rate\", \n      details: \"Visitor selects a ride to experience\", \n      subSteps: [\"Ride Selected\", \"Queue Joined\"],  \n      errorSteps: [\"Ride Closed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        RideType: [\"Roller Coaster\", \"Water Ride\", \"Family Ride\"],\n        WaitTime: [\"Less than 30 min\", \"30-60 min\", \"More than 60 min\"]\n      },\n    },\n    { \n      stepName: \"Food & Beverage Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor purchases food and beverages at the park\", \n      subSteps: [\"Order Placed\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        FoodType: [\"Fast Food\", \"Snack\", \"Beverage\"],\n        PaymentMethod: [\"Credit Card\", \"Mobile Payment\", \"Cash\"]\n      },\n    },\n    { \n      stepName: \"Souvenir Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Visitor buys souvenirs from park stores\", \n      subSteps: [\"Item Selected\", \"Payment Processed\"],  \n      errorSteps: [\"Item Not Available\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        SouvenirType: [\"Plush Toy\", \"T-Shirt\", \"Keychain\"],\n        PaymentMethod: [\"Credit Card\", \"Gift Card\", \"Mobile Payment\"]\n      },\n    },\n    { \n      stepName: \"Exit & Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Visitor exits the park and provides feedback on their experience\", \n      subSteps: [\"Exit Completed\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ExitMethod: [\"Main Gate\", \"VIP Exit\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 1,
        "y": 4
      },
      "predecessors": [
        "claims_processing_journey"
      ],
      "conditions": {
        "states": {
          "claims_processing_journey": "OK"
        }
      }
    },
    "automobile_order_production": {
      "name": "automobile_order_production",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Automobile Order Production\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Order\", \n      kpi: \"Order Evaluation Success Rate\", \n      details: \"Customer places an order and it's evaluated for acceptance\", \n      subSteps: [\"Order Placed\", \"Order Confirmed\"],\n      errorSteps: [\"Order Denied\"], \n      errorProbability: 0.02, \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000, \n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        OrderOrigin: [\"Website\", \"Retailer\"],\n        PaymentMethod: [\"Credit Card\", \"PayPal\"],\n        Region: [\"North America\", \"Europe\"]\n      },\n    },\n    { \n      stepName: \"Production Planning\", \n      kpi: \"Car Production Success\", \n      details: \"Production of the car begins\", \n      subSteps: [\"Capacity Checked\", \"Capacity Available\", \"Production Scheduled\"],\n      errorSteps: [\"No Capacity Available\", \"Production Delay\"],\n      errorProbability: 0.05, \n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 3 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Production\", \n      kpi: \"Car Production Success\", \n      details: \"Car production in progress\", \n      subSteps: [\"Production Started\", \"In Production\", \"End of Production\"],\n      errorSteps: [\"Delay In Production\"],\n      errorProbability: 0.05, \n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 3 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Shipping\", \n      kpi: \"Shipping Success\", \n      details: \"Car shipping from plant to dealership\", \n      subSteps: [\"Ready for Shipping\", \"In Shipping\", \"Delivered\"], \n      errorSteps: [\"Delay in Shipping\"], \n      errorProbability: 0.03, \n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 5 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Handover\", \n      kpi: \"Handover Success\", \n      details: \"Car handed over to the customer\", \n      subSteps: [\"Handover Scheduled\", \"Handed Over\"],  \n      errorProbability: 0.0, \n      injectionMethod: \"Logs\", \n      stepTimeIncrement: 1 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    },\n    {\n      stepName: \"Finance Workflow\", \n      kpi: \"Finance Workflow Completion\", \n      details: \"Final payment and record update\", \n      subSteps: [\"Invoice Process Initiation\", \"Generate Invoice\", \"Review Invoice Data\", \"Verify Order Details\", \"Approve Invoice\", \"Send Invoice\", \"Receive Final Payment\", \"Update Accounting Records\"],  \n      errorProbability: 0.0, \n      includeTotal: true,\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000, \n      subStepTimeIncrement: 15 * 60 * 1000,\n      ...generateMTTD_MTTR_MTTI(),\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 0,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "banking_new_account_opening": {
      "name": "banking_new_account_opening",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Banking New Account Opening\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Account Selection\", \n      kpi: \"Account Selection Success Rate\", \n      details: \"Customer selects the type of account to open\", \n      subSteps: [\"Product Browsed\", \"Account Type Selected\"], \n      errorSteps: [\"Selection Abandoned\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        AccountType: [\"Savings\", \"Current\", \"ISA\"],\n        SelectionChannel: [\"Branch\", \"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an application for a new account\", \n      subSteps: [\"Form Filled\", \"Application Submitted\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Verification Success Rate\", \n      details: \"Customer undergoes identity verification\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],  \n      errorSteps: [\"Verification Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        IDType: [\"Passport\", \"Driver's License\"],\n        VerificationMethod: [\"Online\", \"In-Person\"]\n      },\n    },\n    { \n      stepName: \"Account Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Bank approves or rejects the account application\", \n      subSteps: [\"Application Reviewed\", \"Approval Decision\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApprovalMethod: [\"Automated\", \"Manual\"],\n        AccountLimit: [\"£10,000\", \"£50,000\", \"£100,000+\"]\n      },\n    },\n    { \n      stepName: \"Account Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Customer's new account is activated\", \n      subSteps: [\"Activation Requested\", \"Account Activated\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ActivationMethod: [\"Online\", \"Branch\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Customer Onboarding\", \n      kpi: \"Onboarding Completion Rate\", \n      details: \"Customer completes the onboarding process for their new account\", \n      subSteps: [\"Welcome Email Sent\", \"Onboarding Completed\"],  \n      errorSteps: [\"Onboarding Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        OnboardingChannel: [\"Mobile App\", \"Branch\"],\n        SupportRequested: [\"Yes\", \"No\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 2,
        "y": 2
      },
      "predecessors": [
        "insurance_and_risk_management"
      ],
      "conditions": {
        "states": {
          "insurance_and_risk_management": "OK"
        }
      }
    },
    "patient_appointment_journey": {
      "name": "patient_appointment_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Patient Appointment Journey\", \n  numberOfCustomers: 150, \n  steps: [\n    { \n      stepName: \"Appointment Booking\", \n      kpi: \"Booking Success Rate\", \n      details: \"Patient books a medical appointment\", \n      subSteps: [\"Booking Initiated\", \"Appointment Confirmed\"], \n      errorSteps: [\"Booking Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        BookingMethod: [\"Online\", \"Phone\", \"In-Person\"],\n        AppointmentType: [\"GP\", \"Specialist\", \"Dentist\"]\n      },\n    },\n    { \n      stepName: \"Appointment Reminder\", \n      kpi: \"Reminder Sent Rate\", \n      details: \"Patient receives an appointment reminder\", \n      subSteps: [\"Reminder Sent\", \"Reminder Confirmed\"], \n      errorSteps: [\"Reminder Not Received\"], \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ReminderMethod: [\"SMS\", \"Email\", \"Phone Call\"],\n        ReminderChannel: [\"Automated\", \"Manual\"]\n      },\n    },\n    { \n      stepName: \"Appointment Check-In\", \n      kpi: \"Check-In Success Rate\", \n      details: \"Patient checks in for their appointment\", \n      subSteps: [\"Check-In Started\", \"Check-In Completed\"],  \n      errorSteps: [\"Check-In Failed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        CheckInMethod: [\"Kiosk\", \"Receptionist\", \"Mobile\"],\n        ArrivalTime: [\"On-Time\", \"Late\"]\n      },\n    },\n    { \n      stepName: \"Consultation\", \n      kpi: \"Consultation Success Rate\", \n      details: \"Patient attends their consultation with the healthcare provider\", \n      subSteps: [\"Consultation Started\", \"Consultation Completed\"],  \n      errorSteps: [\"Consultation Delayed\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        ConsultationType: [\"In-Person\", \"Telehealth\"],\n        ProviderType: [\"GP\", \"Specialist\"]\n      },\n    },\n    { \n      stepName: \"Treatment & Prescription\", \n      kpi: \"Treatment Completion Rate\", \n      details: \"Patient receives treatment or prescription after consultation\", \n      subSteps: [\"Treatment Provided\", \"Prescription Issued\"],  \n      errorSteps: [\"Prescription Not Available\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PrescriptionType: [\"E-Prescription\", \"Paper Prescription\"],\n        TreatmentLocation: [\"Clinic\", \"Pharmacy\"]\n      },\n    },\n    { \n      stepName: \"Follow-Up Appointment\", \n      kpi: \"Follow-Up Booking Rate\", \n      details: \"Patient schedules a follow-up appointment\", \n      subSteps: [\"Follow-Up Suggested\", \"Follow-Up Scheduled\"],  \n      errorSteps: [\"Follow-Up Missed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FollowUpMethod: [\"In-Person\", \"Telehealth\"],\n        BookingChannel: [\"Online\", \"Phone\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 0,
        "y": 3
      },
      "predecessors": [
        "university_admissions"
      ],
      "conditions": {
        "states": {
          "university_admissions": "OK"
        }
      }
    },
    "tourism_guided_tour_booking": {
      "name": "tourism_guided_tour_booking",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Tourism Guided Tour Booking\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Tour Search\", \n      kpi: \"Search Success Rate\", \n      details: \"Customer searches for available guided tours\", \n      subSteps: [\"Tour Browsed\", \"Tour Selected\"], \n      errorSteps: [\"Search Abandoned\"], \n      errorProbability: 0.04,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TourType: [\"Cultural\", \"Adventure\", \"Historical\"],\n        SearchMethod: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Booking Confirmation\", \n      kpi: \"Booking Success Rate\", \n      details: \"Customer books a guided tour\", \n      subSteps: [\"Booking Confirmed\", \"Payment Made\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"PayPal\", \"Bank Transfer\"],\n        TourDuration: [\"Half-Day\", \"Full-Day\", \"Multi-Day\"]\n      },\n    },\n    { \n      stepName: \"Tour Guide Assignment\", \n      kpi: \"Assignment Success Rate\", \n      details: \"Tour guide is assigned to the tour\", \n      subSteps: [\"Guide Assigned\", \"Confirmation Sent\"],  \n      errorSteps: [\"Assignment Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        GuideExperience: [\"Novice\", \"Experienced\", \"Expert\"],\n        Language: [\"English\", \"Spanish\", \"French\"]\n      },\n    },\n    { \n      stepName: \"Tour Day\", \n      kpi: \"Tour Success Rate\", \n      details: \"Customer attends the guided tour\", \n      subSteps: [\"Tour Started\", \"Tour Completed\"],  \n      errorSteps: [\"Tour Canceled\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      AdditionalFields: { \n        Weather: [\"Sunny\", \"Rainy\", \"Cloudy\"],\n        GroupSize: [\"Small\", \"Medium\", \"Large\"]\n      },\n    },\n    { \n      stepName: \"Post-Tour Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their guided tour\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Mobile App\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 5
      },
      "predecessors": [
        "retail_in-store_purchase_journey"
      ],
      "conditions": {
        "states": {
          "retail_in-store_purchase_journey": "OK"
        }
      }
    },
    "broadband_service_activation": {
      "name": "broadband_service_activation",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Broadband Service Activation\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Service Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Customer selects a broadband or mobile service plan\", \n      subSteps: [\"Plan Selected\", \"Proceed to Checkout\"], \n      errorSteps: [\"Selection Abandoned\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        PlanType: [\"Broadband\", \"Mobile\", \"TV Bundle\"],\n        DeviceType: [\"Mobile\", \"Desktop\"]\n      },\n    },\n    { \n      stepName: \"Contract Signing\", \n      kpi: \"Contract Signing Success Rate\", \n      details: \"Customer signs the service contract\", \n      subSteps: [\"Contract Viewed\", \"Contract Signed\"], \n      errorSteps: [\"Contract Not Signed\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        SigningMethod: [\"Online\", \"In-Person\"],\n        ContractLength: [\"12 Months\", \"24 Months\", \"No Contract\"]\n      },\n    },\n    { \n      stepName: \"Identity Verification\", \n      kpi: \"Identity Verification Success Rate\", \n      details: \"Customer's identity is verified for service activation\", \n      subSteps: [\"Verification Initiated\", \"Verification Completed\"],\n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        VerificationMethod: [\"Online\", \"In-Person\"],\n        IDType: [\"Passport\", \"Driver’s License\"]\n      },\n    },\n    { \n      stepName: \"Equipment Shipment\", \n      kpi: \"Shipment Success Rate\", \n      details: \"Equipment is shipped to the customer\", \n      subSteps: [\"Order Shipped\", \"Delivered\"],  \n      errorSteps: [\"Shipment Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ShippingProvider: [\"Royal Mail\", \"DHL\", \"UPS\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Service Activation\", \n      kpi: \"Activation Success Rate\", \n      details: \"Service is activated for the customer\", \n      subSteps: [\"Activation Started\", \"Activation Completed\"],  \n      errorSteps: [\"Activation Failed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ActivationMethod: [\"Self-Install\", \"Technician Install\"],\n        ServiceType: [\"Broadband\", \"Mobile\", \"TV\"]\n      },\n    },\n    { \n      stepName: \"Onboarding & Support\", \n      kpi: \"Onboarding Success Rate\", \n      details: \"Customer completes the onboarding process\", \n      subSteps: [\"Onboarding Completed\", \"Support Contacted\"],  \n      errorSteps: [\"Onboarding Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        SupportMethod: [\"Phone\", \"Email\", \"Chat\"],\n        OnboardingChannel: [\"Mobile\", \"Desktop\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 2
      },
      "predecessors": [
        "healthcare_patient_journey"
      ],
      "conditions": {
        "states": {
          "healthcare_patient_journey": "OK"
        }
      }
    },
    "mortgage_application_process": {
      "name": "mortgage_application_process",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section (Mortgage Journey)\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Mortgage Application Process\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Application Submission Success Rate\", \n      details: \"Customer submits a mortgage application\", \n      subSteps: [\"Application Received\", \"Application Submitted\", \"Initial Review Started\"],\n      errorSteps: [\"Application Rejected\"], \n      errorProbability: 0.02,  // 2% chance of rejection\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 60 * 60 * 1000,  // 1 hour between steps\n      subStepTimeIncrement: 15 * 60 * 1000,  // 15 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\", \"By Agent\"],\n        EmploymentStatus: [\"Employed\", \"Self-Employed\", \"Retired\"],\n        IncomeVerificationMethod: [\"Pay Stubs\", \"Bank Statements\", \"Tax Returns\"],\n        ApplicationSource: [\"Mobile\", \"Desktop\", \"Branch Office\"]\n      },\n    },\n    { \n      stepName: \"Credit Check & Approval\", \n      kpi: \"Credit Check Success Rate\", \n      details: \"Credit check and initial approval\", \n      subSteps: [\"Credit Check Initiated\", \"Credit Score Verified\", \"Pre-Approval Decision\"],\n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.10,  // 10% chance of failure at this stage\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000,  // 2 hours between steps\n      subStepTimeIncrement: 30 * 60 * 1000,  // 30 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n       AdditionalFields: { \n        CreditReferenceAgency: [\"Experian\", \"Equifax\", \"TransUnions\"],\n        MortgageTerm: [\"15 Years\", \"30 Years\"],\n        CreditScoreRange: [\"300-500\", \"500-650\", \"650-750\", \"750-850\"]\n      },\n    },\n    { \n      stepName: \"Underwriting\", \n      kpi: \"Underwriting Approval Rate\", \n      details: \"Loan application is underwritten\", \n      subSteps: [\"Underwriting Started\", \"Document Review\", \"Risk Assessment\", \"Underwriting Completed\"],\n      errorSteps: [\"Application Declined by Underwriting\", \"Additional Documentation Required\"],\n      errorProbability: 0.05,  // 5% chance of underwriting failure\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 4 * 60 * 60 * 1000,  // 4 hours between steps\n      subStepTimeIncrement: 45 * 60 * 1000,  // 45 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n       AdditionalFields: { \n        RiskCategory: [\"Low Risk\", \"Moderate Risk\", \"High Risk\"],\n        DocumentTypeRequested: [\"Income Verification\", \"Asset Verification\", \"Property Valuation\"],\n        UnderwriterType: [\"Automated\", \"Manual\"],\n        UnderwriterDecision: [\"Approved\", \"Declined\", \"Conditional Approval\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"],\n        LoanToValueRatio: [\"<80%\", \"80-90%\", \">90%\"]      \n       },\n    },\n    { \n      stepName: \"Appraisal\", \n      kpi: \"Appraisal Completion Rate\", \n      details: \"Property appraisal process\", \n      subSteps: [\"Appraisal Ordered\", \"Appraisal Scheduled\", \"Appraisal Completed\"],\n      errorSteps: [\"Appraisal Delayed\", \"Property Value Too Low\"], \n      errorProbability: 0.08,  // 8% chance of issues during appraisal\n      injectionMethod: \"RestAPI\", \n      stepTimeIncrement: 8 * 60 * 60 * 1000,  // 8 hours between steps\n      subStepTimeIncrement: 60 * 60 * 1000,  // 1 hour between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        AppraisalProvider: [\"Internal\", \"Third-Party\"],\n        AppraisedValue: [\"<Market Value\", \"At Market Value\", \"Above Market Value\"],\n        AppraisalMethod: [\"In-Person\", \"Automated Valuation Model (AVM)\"],\n        PropertyCondition: [\"Good\", \"Fair\", \"Poor\"],\n        PropertyLocationRisk: [\"Low\", \"Medium\", \"High\"]\n      },\n    },\n    { \n      stepName: \"Final Approval\", \n      kpi: \"Final Loan Approval Rate\", \n      details: \"Final loan approval process\", \n      subSteps: [\"Final Review\", \"Conditions Cleared\", \"Final Approval Granted\"],  \n      errorSteps: [\"Conditions Not Met\", \"Approval Delayed\"],  \n      errorProbability: 0.03,  // 3% chance of delay\n      injectionMethod: \"Logs\", \n      stepTimeIncrement: 2 * 60 * 60 * 1000,  // 2 hours between steps\n      subStepTimeIncrement: 30 * 60 * 1000,  // 30 minutes between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AdditionalFields: {\n        ApprovalStatus: [\"Fully Approved\", \"Conditional Approval\", \"Declined\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"],\n        ClosingDateConfirmed: [\"Yes\", \"No\"],\n        FundingSource: [\"Bank\", \"Credit Union\", \"Private Lender\"],\n        InterestRateLockStatus: [\"Locked\", \"Floating\"]\n      }\n    },\n    { \n      stepName: \"Closing\", \n      kpi: \"Loan Closing Completion Rate\", \n      details: \"Loan closing process\", \n      subSteps: [\"Closing Documents Sent\", \"Documents Signed\", \"Loan Funded\", \"Keys Handed Over\"],\n      errorSteps: [\"Closing Delayed\"],  \n      errorProbability: 0.02,  // 2% chance of closing delay\n      includeTotal: true,\n      injectionMethod: \"OneAgent\", \n      stepTimeIncrement: 6 * 60 * 60 * 1000,  // 6 hours between steps\n      subStepTimeIncrement: 60 * 60 * 1000,  // 1 hour between sub-steps\n      ...generateMTTD_MTTR_MTTI(),\n      AddionalFields: {\n        ClosingAttorneyPresent: [\"Yes\", \"No\"],\n        ClosingMethod: [\"In-Person\", \"Remote/Virtual\", \"Hybrid\"],\n        LoanAmount: [\"$100,000-$200,000\", \"$200,000-$400,000\", \"$400,000-$600,000\"],\n        DocumentSignatureStatus: [\"Signed\", \"Pending\"],\n        FundsDisbursed: [\"Yes\", \"No\"],\n        TitleInsurancePurchased: [\"Yes\", \"No\"],\n        KeysHandedOver: [\"Yes\", \"No\"],\n        Region: [\"North America\", \"Europe\", \"Asia-Pacific\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions and Core Workflow\n// -----------------------------\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -1,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "passport_application_journey": {
      "name": "passport_application_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Passport Application Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Application Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Citizen submits a passport application\", \n      subSteps: [\"Application Form Submitted\", \"Payment Made\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApplicationMethod: [\"Online\", \"Postal\", \"In-Person\"],\n        PassportType: [\"Standard\", \"Urgent\", \"Child\"]\n      },\n    },\n    { \n      stepName: \"Document Verification\", \n      kpi: \"Verification Success Rate\", \n      details: \"Documents are verified for the passport application\", \n      subSteps: [\"Documents Submitted\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        IDType: [\"Passport\", \"Driver's License\", \"Utility Bill\"],\n        VerificationMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Application Review\", \n      kpi: \"Review Completion Rate\", \n      details: \"Government reviews the passport application\", \n      subSteps: [\"Review Initiated\", \"Review Completed\"],  \n      errorSteps: [\"Application Rejected\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 48 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ReviewType: [\"Manual\", \"Automated\"],\n        ReviewPriority: [\"Standard\", \"Expedited\"]\n      },\n    },\n    { \n      stepName: \"Passport Printing\", \n      kpi: \"Printing Success Rate\", \n      details: \"Passport is printed after approval\", \n      subSteps: [\"Printing Requested\", \"Passport Printed\"],  \n      errorSteps: [\"Printing Delayed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PrintingMethod: [\"In-House\", \"Outsourced\"],\n        PrintingLocation: [\"London\", \"Edinburgh\"]\n      },\n    },\n    { \n      stepName: \"Delivery & Dispatch\", \n      kpi: \"Dispatch Success Rate\", \n      details: \"Passport is dispatched to the applicant\", \n      subSteps: [\"Dispatch Scheduled\", \"Passport Delivered\"],  \n      errorSteps: [\"Delivery Delayed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DeliveryMethod: [\"Courier\", \"Royal Mail\"],\n        DeliveryWindow: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Feedback Submission\", \n      kpi: \"Feedback Rate\", \n      details: \"Citizen provides feedback on the passport application process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App Notification\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -1,
        "y": 4
      },
      "predecessors": [
        "online_shopping_journey"
      ],
      "conditions": {
        "states": {
          "online_shopping_journey": "OK"
        }
      }
    },
    "drug_development_and_approval": {
      "name": "drug_development_and_approval",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Drug Development & Approval\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Research & Discovery\", \n      kpi: \"Research Success Rate\", \n      details: \"Research team identifies potential drug candidates\", \n      subSteps: [\"Research Initiated\", \"Drug Candidate Identified\"], \n      errorSteps: [\"No Viable Candidates\"], \n      errorProbability: 0.15,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 72 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ResearchMethod: [\"In-Lab\", \"In-Silico\", \"Clinical Data Mining\"],\n        DrugType: [\"Small Molecule\", \"Biologics\", \"Gene Therapy\"]\n      },\n    },\n    { \n      stepName: \"Preclinical Testing\", \n      kpi: \"Preclinical Success Rate\", \n      details: \"Drug candidate undergoes preclinical testing\", \n      subSteps: [\"Animal Testing\", \"Safety Assessment\"], \n      errorSteps: [\"Preclinical Failure\"], \n      errorProbability: 0.10,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 120 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TestingMethod: [\"In-Vivo\", \"In-Vitro\"],\n        Outcome: [\"Success\", \"Failure\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 1\", \n      kpi: \"Phase 1 Success Rate\", \n      details: \"Phase 1 clinical trials are conducted to test safety\", \n      subSteps: [\"Trial Initiated\", \"Trial Completed\"],  \n      errorSteps: [\"Adverse Events\"],  \n      errorProbability: 0.12,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 240 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TrialLocation: [\"UK\", \"USA\", \"EU\"],\n        PatientGroup: [\"Healthy Volunteers\", \"Specific Condition\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 2\", \n      kpi: \"Phase 2 Success Rate\", \n      details: \"Phase 2 clinical trials are conducted to test efficacy\", \n      subSteps: [\"Patient Dosing\", \"Efficacy Measured\"],  \n      errorSteps: [\"Lack of Efficacy\"],  \n      errorProbability: 0.15,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 480 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TrialType: [\"Double-Blind\", \"Open Label\"],\n        PatientGroupSize: [\"100-500\", \"500-1000\"]\n      },\n    },\n    { \n      stepName: \"Clinical Trials Phase 3\", \n      kpi: \"Phase 3 Success Rate\", \n      details: \"Phase 3 trials confirm efficacy and monitor side effects\", \n      subSteps: [\"Dosing Completed\", \"Trial Concluded\"],  \n      errorSteps: [\"Adverse Effects\"],  \n      errorProbability: 0.10,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 720 * 60 * 60 * 1000,\n      AdditionalFields: { \n        TrialSize: [\"1000-5000\", \"5000+\"],\n        TrialRegion: [\"UK\", \"EU\", \"Asia\"]\n      },\n    },\n    { \n      stepName: \"Regulatory Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Regulatory submission to bodies such as the MHRA and EMA\", \n      subSteps: [\"Dossier Prepared\", \"Submission Filed\"],  \n      errorSteps: [\"Submission Rejected\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 180 * 60 * 60 * 1000,\n      AdditionalFields: { \n        RegulatoryAgency: [\"MHRA\", \"EMA\", \"FDA\"],\n        SubmissionType: [\"Standard\", \"Expedited\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 3,
        "y": 2
      },
      "predecessors": [
        "utilities_and_energy"
      ],
      "conditions": {
        "states": {
          "utilities_and_energy": "OK"
        }
      }
    },
    "insurance_and_risk_management": {
      "name": "insurance_and_risk_management",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Insurance Claim Processing\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Claim Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Customer submits an insurance claim\", \n      subSteps: [\"Claim Form Filled\", \"Submitted\"], \n      errorSteps: [\"Form Incomplete\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ClaimType: [\"Auto\", \"Home\", \"Health\"],\n        SubmissionMethod: [\"Online\", \"Agent\"]\n      },\n    },\n    { \n      stepName: \"Claim Review\", \n      kpi: \"Claim Review Success\", \n      details: \"Claim is reviewed by the insurance company\", \n      subSteps: [\"Documents Verified\", \"Claim Assessed\"],\n      errorSteps: [\"Claim Rejected\"], \n      errorProbability: 0.07,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        AdjusterType: [\"In-House\", \"Third-Party\"],\n        ClaimValue: [\"<£5,000\", \"£5,000-£50,000\", \">£50,000\"]\n      },\n    },\n    { \n      stepName: \"Claim Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Insurance company approves or denies the claim\", \n      subSteps: [\"Approval Review\", \"Decision Made\"],  \n      errorSteps: [\"Approval Denied\"],  \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApprovalStatus: [\"Approved\", \"Rejected\"],\n        PayoutMethod: [\"Direct Deposit\", \"Cheque\"]\n      },\n    },\n    { \n      stepName: \"Claim Payment\", \n      kpi: \"Payout Success Rate\", \n      details: \"Approved claim payout is processed\", \n      subSteps: [\"Payment Approved\", \"Funds Disbursed\"],  \n      errorSteps: [\"Payment Delayed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 6 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Direct Deposit\", \"Cheque\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Customer Follow-Up\", \n      kpi: \"Follow-Up Success Rate\", \n      details: \"Customer receives follow-up after claim completion\", \n      subSteps: [\"Follow-Up Initiated\", \"Follow-Up Completed\"],  \n      errorSteps: [\"No Follow-Up\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FollowUpMethod: [\"Phone\", \"Email\"],\n        SatisfactionLevel: [\"Satisfied\", \"Neutral\", \"Unsatisfied\"]\n      },\n    },\n    { \n      stepName: \"Feedback & Survey\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback after the claim is completed\", \n      subSteps: [\"Feedback Requested\", \"Survey Completed\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Phone\"],\n        FeedbackType: [\"Positive\", \"Neutral\", \"Negative\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 2,
        "y": 1
      },
      "predecessors": [],
      "conditions": {
        "states": {}
      }
    },
    "retail_supply_chain_fulfilment": {
      "name": "retail_supply_chain_fulfilment",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Retail Supply Chain Fulfilment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Order Placement\", \n      kpi: \"Order Placement Success Rate\", \n      details: \"Customer places an order for products\", \n      subSteps: [\"Order Submitted\", \"Order Confirmed\"], \n      errorSteps: [\"Order Canceled\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        ProductType: [\"Clothing\", \"Electronics\", \"Home Goods\"],\n        OrderChannel: [\"Website\", \"Mobile App\"]\n      },\n    },\n    { \n      stepName: \"Inventory Check\", \n      kpi: \"Inventory Availability Rate\", \n      details: \"Inventory is checked for product availability\", \n      subSteps: [\"Inventory Verified\", \"Products Reserved\"], \n      errorSteps: [\"Product Out of Stock\"], \n      errorProbability: 0.08,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        WarehouseLocation: [\"London\", \"Manchester\", \"Birmingham\"],\n        InventoryMethod: [\"Manual\", \"Automated\"]\n      },\n    },\n    { \n      stepName: \"Picking & Packing\", \n      kpi: \"Packing Success Rate\", \n      details: \"Products are picked and packed for shipment\", \n      subSteps: [\"Items Picked\", \"Items Packed\"],  \n      errorSteps: [\"Packing Delay\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PackagingType: [\"Standard\", \"Gift Wrap\"],\n        PickerType: [\"Manual\", \"Robotic\"]\n      },\n    },\n    { \n      stepName: \"Shipping & Dispatch\", \n      kpi: \"Dispatch Success Rate\", \n      details: \"Products are dispatched for delivery\", \n      subSteps: [\"Dispatch Scheduled\", \"Items Shipped\"],  \n      errorSteps: [\"Dispatch Delayed\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ShippingProvider: [\"DHL\", \"UPS\", \"Royal Mail\"],\n        DeliveryMethod: [\"Standard\", \"Next-Day\"]\n      },\n    },\n    { \n      stepName: \"Last-Mile Delivery\", \n      kpi: \"On-Time Delivery Rate\", \n      details: \"Products are delivered to the customer's address\", \n      subSteps: [\"Out for Delivery\", \"Delivered\"],  \n      errorSteps: [\"Delivery Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      AdditionalFields: { \n        CourierType: [\"Company Driver\", \"Third-Party\"],\n        DeliverySlot: [\"Morning\", \"Afternoon\", \"Evening\"]\n      },\n    },\n    { \n      stepName: \"Returns Processing\", \n      kpi: \"Returns Completion Rate\", \n      details: \"Customer returns an item and it is processed\", \n      subSteps: [\"Return Requested\", \"Item Received\"],  \n      errorSteps: [\"Return Rejected\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ReturnMethod: [\"In-Store\", \"Courier Pickup\"],\n        RefundMethod: [\"Credit Card\", \"Gift Card\"]\n      },\n    }\n  ]\n};\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 3
      },
      "predecessors": [
        "broadband_service_activation"
      ],
      "conditions": {
        "states": {
          "broadband_service_activation": "OK"
        }
      }
    },
    "finance_investment_account_setup": {
      "name": "finance_investment_account_setup",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Investment Account Setup\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Account Registration\", \n      kpi: \"Registration Success Rate\", \n      details: \"Customer registers for an investment account\", \n      subSteps: [\"Account Created\", \"Verification Completed\"], \n      errorSteps: [\"Verification Failed\"], \n      errorProbability: 0.05,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        AccountType: [\"Stocks\", \"Bonds\", \"Mutual Funds\"],\n        RegistrationMethod: [\"Online\", \"Advisor\"]\n      },\n    },\n    { \n      stepName: \"Deposit Funds\", \n      kpi: \"Deposit Success Rate\", \n      details: \"Customer deposits funds into their investment account\", \n      subSteps: [\"Deposit Initiated\", \"Deposit Completed\"], \n      errorSteps: [\"Deposit Failed\"], \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        DepositMethod: [\"Bank Transfer\", \"Credit Card\", \"Direct Debit\"],\n        Currency: [\"GBP\", \"USD\", \"EUR\"]\n      },\n    },\n    { \n      stepName: \"Investment Plan Selection\", \n      kpi: \"Selection Success Rate\", \n      details: \"Customer selects an investment plan\", \n      subSteps: [\"Plan Viewed\", \"Plan Selected\"],  \n      errorSteps: [\"Plan Selection Abandoned\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PlanType: [\"Aggressive\", \"Conservative\", \"Balanced\"],\n        InvestmentDuration: [\"1 Year\", \"5 Years\", \"10 Years\"]\n      },\n    },\n    { \n      stepName: \"Portfolio Setup\", \n      kpi: \"Portfolio Setup Success Rate\", \n      details: \"Customer sets up their investment portfolio\", \n      subSteps: [\"Portfolio Configured\", \"Portfolio Approved\"],  \n      errorSteps: [\"Portfolio Rejected\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 4 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PortfolioType: [\"Custom\", \"Managed\"],\n        RiskTolerance: [\"High\", \"Medium\", \"Low\"]\n      },\n    },\n    { \n      stepName: \"Investment Start\", \n      kpi: \"Investment Start Success Rate\", \n      details: \"Customer's investments are activated\", \n      subSteps: [\"Investment Confirmed\", \"Investment Active\"],  \n      errorSteps: [\"Investment Delayed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 5 * 60 * 60 * 1000,\n      AdditionalFields: { \n        InvestmentType: [\"Stocks\", \"Bonds\", \"Mutual Funds\"],\n        StartMethod: [\"Automatic\", \"Manual\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on the investment setup process\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"Advisor\"],\n        SatisfactionLevel: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 3,
        "y": 4
      },
      "predecessors": [
        "utilities_energy_setup"
      ],
      "conditions": {
        "states": {
          "utilities_energy_setup": "OK"
        }
      }
    },
    "retail_in-store_purchase_journey": {
      "name": "retail_in-store_purchase_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - In-Store Purchase Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Product Browsing\", \n      kpi: \"Browsing Success Rate\", \n      details: \"Customer browses products in-store\", \n      subSteps: [\"Products Viewed\", \"Product Selected\"], \n      errorSteps: [\"Browsing Abandoned\"], \n      errorProbability: 0.06,\n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ProductCategory: [\"Clothing\", \"Electronics\", \"Groceries\"],\n        StoreType: [\"Department Store\", \"Supermarket\", \"Boutique\"]\n      },\n    },\n    { \n      stepName: \"Add to Basket\", \n      kpi: \"Basket Success Rate\", \n      details: \"Customer adds items to their basket in-store\", \n      subSteps: [\"Item Selected\", \"Added to Basket\"], \n      errorSteps: [\"Item Not Available\"], \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        BasketType: [\"Physical Basket\", \"Trolley\"],\n        ProductType: [\"Promotional\", \"Regular Stock\"]\n      },\n    },\n    { \n      stepName: \"Checkout\", \n      kpi: \"Checkout Success Rate\", \n      details: \"Customer proceeds to the checkout for payment\", \n      subSteps: [\"Checkout Started\", \"Payment Processed\"],  \n      errorSteps: [\"Payment Declined\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Credit Card\", \"Cash\", \"Contactless\"],\n        CheckoutType: [\"Self-Checkout\", \"Cashier\"]\n      },\n    },\n    { \n      stepName: \"Receipt Issued\", \n      kpi: \"Receipt Issuance Rate\", \n      details: \"Customer receives a receipt for their purchase\", \n      subSteps: [\"Receipt Printed\", \"Receipt Issued\"],  \n      errorSteps: [\"Receipt Not Issued\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      AdditionalFields: { \n        ReceiptType: [\"Printed\", \"Email\"],\n        ReceiptMethod: [\"In-Store\", \"App\"]\n      },\n    },\n    { \n      stepName: \"Loyalty Points Redemption\", \n      kpi: \"Points Redemption Success Rate\", \n      details: \"Customer redeems loyalty points on their purchase\", \n      subSteps: [\"Points Applied\", \"Discount Provided\"],  \n      errorSteps: [\"Points Not Applied\"],  \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        LoyaltyProgram: [\"In-House\", \"Third-Party\"],\n        PointsRedeemed: [\"50 Points\", \"100 Points\", \"200 Points\"]\n      },\n    },\n    { \n      stepName: \"Customer Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Customer provides feedback on their in-store shopping experience\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackMethod: [\"In-Store\", \"Email\", \"App Notification\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -3,
        "y": 4
      },
      "predecessors": [
        "retail_supply_chain_fulfilment"
      ],
      "conditions": {
        "states": {
          "retail_supply_chain_fulfilment": "OK"
        }
      }
    },
    "pharmacy_prescription_fulfillment": {
      "name": "pharmacy_prescription_fulfillment",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Pharmacy Prescription Fulfillment\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Prescription Submission\", \n      kpi: \"Submission Success Rate\", \n      details: \"Patient submits a prescription to the pharmacy\", \n      subSteps: [\"Prescription Submitted\", \"Prescription Verified\"], \n      errorSteps: [\"Submission Failed\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        SubmissionMethod: [\"Online\", \"In-Person\", \"Mail\"],\n        PrescriptionType: [\"New\", \"Refill\"]\n      },\n    },\n    { \n      stepName: \"Prescription Approval\", \n      kpi: \"Approval Success Rate\", \n      details: \"Prescription is approved by a pharmacist\", \n      subSteps: [\"Approval Requested\", \"Approval Granted\"], \n      errorSteps: [\"Approval Denied\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        ApprovalType: [\"Standard\", \"Urgent\"],\n        PharmacistMethod: [\"In-House\", \"Third-Party\"]\n      },\n    },\n    { \n      stepName: \"Medication Preparation\", \n      kpi: \"Preparation Success Rate\", \n      details: \"Medication is prepared and packaged\", \n      subSteps: [\"Medication Prepared\", \"Packaging Completed\"],  \n      errorSteps: [\"Medication Not Available\"],  \n      errorProbability: 0.06,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 2 * 60 * 60 * 1000,\n      AdditionalFields: { \n        MedicationType: [\"Generic\", \"Branded\"],\n        PackagingType: [\"Blister Pack\", \"Bottle\"]\n      },\n    },\n    { \n      stepName: \"Pickup or Delivery\", \n      kpi: \"Delivery Success Rate\", \n      details: \"Patient picks up or receives the medication\", \n      subSteps: [\"Pickup Confirmed\", \"Delivery Confirmed\"],  \n      errorSteps: [\"Pickup Missed\", \"Delivery Failed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"Logs\", \n      includeTotal: true,\n      stepTimeIncrement: 3 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PickupMethod: [\"In-Store\", \"Drive-Thru\"],\n        DeliveryMethod: [\"Standard\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Payment Processing\", \n      kpi: \"Payment Success Rate\", \n      details: \"Patient pays for the medication\", \n      subSteps: [\"Payment Submitted\", \"Payment Confirmed\"],  \n      errorSteps: [\"Payment Failed\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: true,\n      stepTimeIncrement: 1 * 60 * 60 * 1000,\n      AdditionalFields: { \n        PaymentMethod: [\"Insurance\", \"Credit Card\", \"Cash\"],\n        PaymentType: [\"Co-Pay\", \"Full Payment\"]\n      },\n    },\n    { \n      stepName: \"Patient Feedback\", \n      kpi: \"Feedback Rate\", \n      details: \"Patient provides feedback on the pharmacy service\", \n      subSteps: [\"Feedback Requested\", \"Feedback Provided\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackChannel: [\"Email\", \"App\", \"In-Store\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": -2,
        "y": 5
      },
      "predecessors": [
        "online_course_enrollment"
      ],
      "conditions": {
        "states": {
          "online_course_enrollment": "OK"
        }
      }
    },
    "transportation_public_transit_journey": {
      "name": "transportation_public_transit_journey",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// -----------------------------\n// Configuration Options\n// -----------------------------\n// activeConfig: Main object controlling the behavior of the script.\n\n// sector: The business area for generating events (e.g., \"Business Analytics - Automobile Order Production\").\n\n// numberOfCustomers: Number of unique customers to simulate.\n\n// steps: An array representing each phase of the business process. Fields include:\n//    - stepName: Name of the workflow step (e.g., \"Order\", \"Production\").\n//    - kpi: KPI to track for this step.\n//    - details: Description of the action in this step.\n//    - subSteps: Regular sub-steps in this phase (e.g., [\"Order Placed\", \"Order Confirmed\"]).\n//    - errorSteps: Possible failure steps (e.g., [\"Order Denied\"]).\n//    - errorProbability: Likelihood of an error (e.g., 0.02 for 2% chance).\n//    - injectionMethod: How data is injected (e.g., \"OneAgent\", \"RestAPI\").\n//    - includeTotal: Include total transaction values (true/false).\n//    - stepTimeIncrement: Time between steps in milliseconds.\n//    - subStepTimeIncrement: Time between sub-steps in milliseconds.\n//    - MTTD, MTTR, MTTI: Mean Time to Detect, Recover, and Identify issues.\n//    - AdditionalFields: Custom fields for each step, like \"OrderOrigin\", \"PaymentMethod\".\n\nimport { businessEventsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport crypto from 'crypto';\n\nfunction generateMTTD_MTTR_MTTI() {\n  const MTTD = Math.floor(Math.random() * 6) + 1;  \n  const MTTI = Math.floor(Math.random() * 10) + MTTD + 1; \n  const MTTR = Math.floor(Math.random() * 10) + MTTI + 1; \n  return { MTTD, MTTI, MTTR };\n}\n\n// -----------------------------\n// Configuration Section\n// -----------------------------\n\nconst activeConfig = {\n  sector: \"BizAnalytics - Transportation Public Transit Journey\", \n  numberOfCustomers: 100, \n  steps: [\n    { \n      stepName: \"Ticket Purchase\", \n      kpi: \"Purchase Success Rate\", \n      details: \"Customer buys a transit ticket\", \n      subSteps: [\"Ticket Selected\", \"Payment Processed\"], \n      errorSteps: [\"Payment Declined\"], \n      errorProbability: 0.03,\n      injectionMethod: \"OneAgent\", \n      includeTotal: true,\n      stepTimeIncrement: 30 * 60 * 1000,\n      AdditionalFields: { \n        TicketType: [\"Single\", \"Return\", \"Monthly Pass\"],\n        PaymentMethod: [\"Credit Card\", \"Mobile Payment\", \"Cash\"]\n      },\n    },\n    { \n      stepName: \"Boarding\", \n      kpi: \"Boarding Success Rate\", \n      details: \"Customer boards the bus or train\", \n      subSteps: [\"Ticket Scanned\", \"Entry Granted\"], \n      errorSteps: [\"Ticket Invalid\"], \n      errorProbability: 0.04,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      AdditionalFields: { \n        TransportType: [\"Bus\", \"Train\", \"Tram\"],\n        BoardingStation: [\"Central\", \"Suburban\"]\n      },\n    },\n    { \n      stepName: \"Journey\", \n      kpi: \"Journey Success Rate\", \n      details: \"Customer completes their public transit journey\", \n      subSteps: [\"Journey Started\", \"Journey Completed\"],  \n      errorSteps: [\"Journey Delayed\"],  \n      errorProbability: 0.07,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 45 * 60 * 1000,\n      AdditionalFields: { \n        JourneyLength: [\"Short\", \"Medium\", \"Long\"],\n        ServiceType: [\"Regular\", \"Express\"]\n      },\n    },\n    { \n      stepName: \"Transfer\", \n      kpi: \"Transfer Success Rate\", \n      details: \"Customer transfers between transit lines or modes\", \n      subSteps: [\"Transfer Started\", \"Transfer Completed\"],  \n      errorSteps: [\"Transfer Missed\"],  \n      errorProbability: 0.05,  \n      injectionMethod: \"RestAPI\", \n      includeTotal: false,\n      stepTimeIncrement: 15 * 60 * 1000,\n      AdditionalFields: { \n        TransferType: [\"Bus to Train\", \"Train to Bus\", \"Train to Train\"],\n        TransferStation: [\"Central\", \"Suburban\"]\n      },\n    },\n    { \n      stepName: \"Exit\", \n      kpi: \"Exit Success Rate\", \n      details: \"Customer exits the public transit system\", \n      subSteps: [\"Exit Processed\", \"Exit Completed\"],  \n      errorSteps: [\"Exit Failed\"],  \n      errorProbability: 0.02,  \n      injectionMethod: \"Logs\", \n      includeTotal: false,\n      stepTimeIncrement: 10 * 60 * 1000,\n      AdditionalFields: { \n        ExitStation: [\"Central\", \"Suburban\"],\n        JourneyFeedback: [\"Positive\", \"Neutral\", \"Negative\"]\n      },\n    },\n    { \n      stepName: \"Post-Journey Feedback\", \n      kpi: \"Feedback Submission Rate\", \n      details: \"Customer provides feedback on their transit journey\", \n      subSteps: [\"Feedback Requested\", \"Feedback Submitted\"],  \n      errorSteps: [\"No Feedback\"],  \n      errorProbability: 0.03,  \n      injectionMethod: \"OneAgent\", \n      includeTotal: false,\n      stepTimeIncrement: 24 * 60 * 60 * 1000,\n      AdditionalFields: { \n        FeedbackMethod: [\"Email\", \"Mobile App\"],\n        SatisfactionRating: [\"Very Satisfied\", \"Satisfied\", \"Dissatisfied\"]\n      },\n    }\n  ]\n};\n\n\n\n// -----------------------------\n// Utility Functions\n// -----------------------------\n\nfunction generateRandomTimestampWithin24Hours() {\n  const now = new Date();\n  const past24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);  \n  return new Date(past24Hours.getTime() + Math.random() * (now.getTime() - past24Hours.getTime()));\n}\n\nfunction generateAddress() {\n  const streets = [\"Main St\", \"High St\", \"Elm St\", \"Oak St\", \"Pine St\"];\n  const cities = [\"Springfield\", \"Rivertown\", \"Lakeside\", \"Greenville\"];\n  const states = [\"CA\", \"NY\", \"TX\", \"FL\", \"WA\"];\n  const zip = Math.floor(Math.random() * 90000) + 10000; \n  return `${Math.floor(Math.random() * 1000)} ${streets[Math.floor(Math.random() * streets.length)]}, ${cities[Math.floor(Math.random() * cities.length)]}, ${states[Math.floor(Math.random() * states.length)]}, ${zip}`;\n}\n\nfunction generateFirstName() {\n  const firstNames = [\"John\", \"Jane\", \"Michael\", \"Emily\"];\n  return firstNames[Math.floor(Math.random() * firstNames.length)];\n}\n\nfunction generateCustomerId() {\n  return `CUST${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateLastName() {\n  const lastNames = [\"Doe\", \"Smith\", \"Johnson\", \"Brown\"];\n  return lastNames[Math.floor(Math.random() * lastNames.length)];\n}\n\nfunction generateEmail(customerId) {\n  const domains = [\"example.com\"];\n  return `${customerId.toLowerCase()}@${domains[Math.floor(Math.random() * domains.length)]}`;\n}\n\nfunction generateOrderId() {\n  return `ORD${Math.floor(Math.random() * 1e12).toString().padStart(12, '0')}`;\n}\n\nfunction generateIncidentNumber() {\n  return `INC000${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;\n}\n\nfunction generateTransactionAmount() {\n  return (Math.floor(Math.random() * 5000) + 20); \n}\n\n// -----------------------------\n// Core Functions\n// -----------------------------\n\nfunction createSubStep(baseStep, stepNumber, config, subStepIndex, timestamp, totalRevenue) {\n  const step = config.steps[stepNumber - 1];\n  const subStepDescription = step.subSteps[subStepIndex - 1];\n  const errorStep = step.errorSteps && step.errorSteps.includes(subStepDescription);\n  const errorTriggered = Math.random() < step.errorProbability && errorStep;\n  \n  const subStepError = errorTriggered;\n  const incidentNumber = subStepError ? generateIncidentNumber() : null;\n\n  return {\n    ...baseStep,\n    step: subStepError ? `Step${stepNumber}.${subStepIndex}e` : `Step${stepNumber}.${subStepIndex}`,\n    type: subStepError ? step.errorSteps[subStepIndex - 1] : `${baseStep.type.split(' - ')[0]} - ${subStepDescription}`,\n    timestamp: timestamp.toISOString(),\n    total: baseStep.step.startsWith('4') ? totalRevenue : 0, \n    error: subStepError ? subStepDescription : null,\n    injectionMethod: step.injectionMethod, \n    incidentNumber: incidentNumber\n  };\n}\n\nfunction createStep(orderId, config, stepNumber, customerId, firstName, lastName, date, address, email, isError = false, totalRevenue = null, initialTotal = null) {\n  const step = config.steps[stepNumber - 1];\n  const error = isError || (Math.random() < step.errorProbability && step.errorSteps.length > 0); \n\n  const products = step.products ? (Array.isArray(step.products) ? step.products : [step.products]) : null;\n  const MTTD = error ? step.MTTD : null;\n  const MTTR = error ? step.MTTR : null;\n  const MTTI = error ? step.MTTI : null;\n  const incidentNumber = error ? generateIncidentNumber() : null;\n\n  const totalValue = stepNumber === 1 ? totalRevenue : initialTotal;\n\n  // Process AdditionalFields\n  let AdditionalFields = {};\n  if (step.AdditionalFields) {\n    for (const group in step.AdditionalFields) {\n      const values = step.AdditionalFields[group];\n      AdditionalFields[group] = values[Math.floor(Math.random() * values.length)];\n    }\n  }\n\n  return {\n    orderId: orderId,\n    incidentNumber: incidentNumber,\n    total: step.includeTotal ? totalValue : null,  \n    customer: JSON.stringify({ firstName, lastName }), \n    orderItemsProductIDs: step.includeOrderItems && products ? JSON.stringify(products.map(p => `PROD-${p.productName}`)) : null,\n    products: products, \n    kpi: step.kpi,\n    details: step.details,\n    step: error ? `Step${stepNumber}e` : `Step${stepNumber}`,\n    customerId: customerId,\n    timestamp: date.toISOString(),\n    address: address,\n    customerEmail: email,\n    apiCallName: \"API Call\",\n    serviceResponseTime: (Math.random() * 5).toFixed(2), \n    error: error ? step.errorSteps[0] : null,  \n    MTTD: MTTD,    \n    MTTR: MTTR,    \n    MTTI: MTTI,    \n    incidentNumber: incidentNumber,  \n    type: step.stepName,\n    injectionMethod: step.injectionMethod, \n    source: config.sector,\n    AdditionalFields: AdditionalFields\n  };\n}\n\n// Function to generate a complete order journey\nfunction generateOrderJourney(config, customerId, firstName, lastName, address, email) {\n  const steps = [];\n  const orderId = generateOrderId(); \n  const timestamps = Array.from({ length: config.steps.length }, generateRandomTimestampWithin24Hours).sort((a, b) => a - b);\n\n  let totalRevenue = generateTransactionAmount();\n  let handoverCompleted = false;  \n  let journeyStopped = false;\n\n  for (let i = 0; i < config.steps.length && !journeyStopped; i++) {\n    const stepTimestamp = timestamps[i];\n\n    const step = createStep(orderId, config, i + 1, customerId, firstName, lastName, stepTimestamp, address, email, false, totalRevenue, totalRevenue);\n    steps.push(step);\n\n    if (step.error) {\n      console.log(`Error encountered: ${step.error}. Stopping journey.`);\n      journeyStopped = true;\n\n      // Inject the failure step (error event) in the flow\n      steps.push({\n        ...step,\n        step: `Step${i + 1}e`,\n        error: step.error,\n        type: step.error\n      });\n\n      break;\n    }\n\n    for (let subStepIndex = 1; subStepIndex <= config.steps[i].subSteps.length && !journeyStopped; subStepIndex++) {\n      const subStepTimestamp = new Date(stepTimestamp.getTime() + subStepIndex * 60000);\n      const subStep = createSubStep(step, i + 1, config, subStepIndex, subStepTimestamp, totalRevenue);\n\n      steps.push(subStep);\n      if (subStep.error) {\n        console.log(`Error encountered in substep: ${subStep.error}. Stopping journey.`);\n        journeyStopped = true;\n        break;\n      }\n    }\n\n    if (step.stepName === \"Handover\" && step.subSteps.includes(\"Handed Over\")) {\n      handoverCompleted = true;\n    }\n  }\n\n  if (handoverCompleted && !journeyStopped) {\n    const invoiceStepIndex = config.steps.length;\n    for (let invoiceSubStepIndex = 1; invoiceSubStepIndex <= config.steps[invoiceStepIndex - 1].subSteps.length; invoiceSubStepIndex++) {\n      const invoiceSubStepTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + invoiceSubStepIndex * 60000); \n      const invoiceSubStep = createSubStep(steps[steps.length - 1], invoiceStepIndex, config, invoiceSubStepIndex, invoiceSubStepTimestamp, totalRevenue);\n      steps.push(invoiceSubStep);\n    }\n  }\n\n  return steps;\n}\n\n// Function to retrieve customer data based on sector\nasync function getCustomerData() {\n  const customers = [];\n  \n  for (let i = 0; i < activeConfig.numberOfCustomers; i++) {\n    const customerId = generateCustomerId();\n    const firstName = generateFirstName();\n    const lastName = generateLastName();\n    const address = generateAddress();\n    const email = generateEmail(customerId);\n    customers.push(...generateOrderJourney(activeConfig, customerId, firstName, lastName, address, email));\n  }\n\n  return customers;\n}\n\n// Function to send data to Dynatrace\nasync function sendDataToDynatrace(data) {\n  try {\n    const bizevents = data.map(event => ({\n      id: crypto.randomUUID(),\n      'event.provider': event.source,\n      'event.type': event.type,\n      step: event.step,\n      orderId: event.orderId,\n      incidentNumber: event.incidentNumber, \n      total: event.total,\n      customer: event.customer, \n      orderItemsProductIDs: event.orderItemsProductIDs, \n      products: event.products, \n      kpi: event.kpi,\n      details: event.details,\n      customerId: event.customerId,\n      timestamp: event.timestamp,\n      address: event.address,\n      customerEmail: event.customerEmail,\n      apiCallName: \"API Call\",\n      serviceResponseTime: event.serviceResponseTime,\n      error: event.error,\n      MTTD: event.MTTD, \n      MTTR: event.MTTR, \n      MTTI: event.MTTI, \n      injectionMethod: event.injectionMethod,\n\n      // Spread out AdditionalFields key-value pairs into the payload\n      ...event.AdditionalFields\n    }));\n\n    console.log('Payload being sent:', JSON.stringify(bizevents, null, 2));\n\n    const response = await businessEventsClient.ingest({\n      type: 'application/json',\n      body: bizevents\n    });\n\n    console.log('Data sent successfully:', response);\n  } catch (error) {\n    console.error('Error sending data to Dynatrace:', error);\n  }\n}\n\n// Function to ingest data for the active sector\nasync function ingestData() {\n  try {\n    const customerData = await getCustomerData();\n    await sendDataToDynatrace(customerData);\n    console.log(`${activeConfig.sector} data ingested successfully`);\n  } catch (error) {\n    console.error('Error in ingestData function:', error);\n  }\n}\n\n// Call the ingestData function\ningestData();\n"
      },
      "position": {
        "x": 2,
        "y": 4
      },
      "predecessors": [
        "mobile_service_activation"
      ],
      "conditions": {
        "states": {
          "mobile_service_activation": "OK"
        }
      }
    }
  },
  "description": "",
  "actor": "fa94290b-310d-429d-a688-9fe5484de482",
  "owner": "fa94290b-310d-429d-a688-9fe5484de482",
  "ownerType": "USER",
  "isPrivate": true,
  "trigger": {},
  "schemaVersion": 3
}